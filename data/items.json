{"readCount": "458", "article": "网上关于Android 的view坐标挺多的，写这篇的目的是因为网上搜到的文章大多较简单，几乎都是简单的介绍下获取的几个方法坐标的几个方法罢了，但在实战中，你会发现可能你学会的那几个获取坐标的方法并没有正确的使用，导致当你要计算坐标的时候可能会试过几遍才找到正确的办法（其实这也正是我容易混淆的地方，所以特地写篇博客记录下）\n\n关于那几个获取坐标的方法我就懒得说了 \n\n （这篇博客有记载，大家可以去看看http://blog.csdn.net/jason0539/article/details/42743531）\n\n点击B点后（可以看到先是回调TestTextView中的onTouchEvent方法，然后才是MainActivity中的onTouchEvent，因为我在二者的onTouchEvent方法中都没有进行点击事件的消费处理，所以会往上传递，突然扯到了事件分发机制，2333~这里就是突然想补充一点，还是扯回坐标吧） 2.MainActivity中getY和getRawY取得的值一样！（我们注意到点击A,B点都是如此）原因在于，当点击事件没有被消费，往上传递时，此刻onTouchEvent参数列表中的MotionEvent是来自ViewGroup，而对于ViewGroup来说getY和getRawY其实是一样的。\n\n测试2：类似在ListView这种有滚动轴的控件中会是什么样的呢？\n\n这次我们点击的是item7的顶部，发现一致，按照刚才我们得到的规律应该很好理解，ListView是ViewGroup，所以getY和getRawY取得的值是一样的。 \n\n （PS：这时可能会有点好奇，我们明明点击的接近是item7的顶部，为啥得到的Y指却不是接近0呢，原因后面讲）\n\n在上面我们留下了一个疑问：我们明明点击的接近是item7的顶部，得到的Y指却不是接近0。 \n\n 原因在于getRawY返回的是点击事件距离整个屏幕顶边的距离，所以点击item7的顶部，得到的Y值其实就是状态栏的值。\n\n这里为了让大家更清晰的了解，大家可以看看这篇文章http://bbs.51cto.com/thread-1072344-1.html（Android4.0窗口机制和创建过程分析 ）\n\n下面我们用图来初略说明（这是我的理解，有误欢迎指正）\n\n看到这，你可能会说，那还不简单当布局被加载出来的时候，我们去获取不就OK了吗？ \n\n 于是我们就会看到这样的错误：在一个Activity的onCreate方法中，设置完setContentView后，就开始View的getLeft，getTop等方法，结果发现为0，为啥？\n\n那要是我们想要在onCreate中取到我们想要的值，我们应该怎么做呢？ \n\n 大家可以参考这两篇博文 \n\n （http://www.cnblogs.com/kissazi2/p/4133927.html） \n\n （http://blog.csdn.net/codezjx/article/details/45341309）\n\n我觉得写得很好了\n\n这里我推荐2,4这两种，即\n\n\n\n （为了好计算，图片中的坐标单位是px）\n\n（下面就以这个为例，我们要将View从原点移动到（200,400）的位置，即B点与C点重合）\n\n我就以ObjectAnimator为例子\n\n我们经常用这样的需求，要求一个popupwindow从屏幕底部弹出或者从屏幕顶部弹出。 \n\n 这里的位移设置同样还是如此（原点在屏幕左上角，向右x为正，向下y为正）\n\n这篇博文可以参考学习下，下面这张神图也是来自这篇博文（Android动画之translate(位移动画)） \n\n http://www.cnblogs.com/bavariama/archive/2013/01/29/2881225.html \n\n\n\n坐标分析上面都分析完了，基本上涵盖了自定义View坐标计算、滑动、事件分发等常见场景的坐标问题，希望大家能从中得到收获。 \n\n 水平很菜，有错误的地方欢迎指正，大家一起学习进步！ ☻ 反正撸完这篇，我算是对于坐标系有了更深刻的认识，给自己点个赞~❤", "link": "http://blog.csdn.net/mr_immortalz/article/details/51168278", "publishDate": "2016-04-19 00:14", "title": "\r\n        "}
{"readCount": "4177", "article": "前面我们利用腾讯的分析系统分析了我们的访问数据，但是腾讯不太好的地方就是他只能提供国内的访问数据，同时腾讯的访问功能也比较纯粹，而百度在这方面就强大很多，这篇文章和大家一起讨论下怎么将百度统计功能嵌入到我们CSDN博客，同时可能带来一些潜在的访问量：\n\n1. 首先我们注册一个百度统计账户，注意不是百度账户，这两者在百度定义的是两套业务系统。所以我们必须注册站长版：\n\n3.填入必要的信息后点击注册，注册应该需要激活，在邮件中激活相关的网站即可：\n\n到此我们的博客这边设置已经设置完毕，经过一段时间的统计，我们基本上在百度那边就可以抓取到相应的数据了。百度比腾讯体验好的地方在于实时访客这边记录的信息更加相信，有可能是因为百度本身就是搜索引擎吧，在于对于关键字的抓取更加细致。", "link": "http://blog.csdn.net/fogyisland2000/article/details/51175055", "publishDate": "2016-04-17 20:44", "title": "\r\n        利用百度统计的功能统计CSDN的访问数据！            \r\n        "}
{"readCount": "6485", "article": "看我技术博客的朋友可能有注意到，最近更新了一系列与CEF、PPAPI、Skia相关的文章。在研究它们的过程中，有一些有意思的经历，非常典型，可以从一个方面解释“技术债务”的由来。\n\n接下来我会讲讲这次经历，并从此展开，看看形成技术债务的原因及应对策略。\n\n因为业务需要，我得在PPAPI插件中显示另一个模块（已有模块，基于C++代码完成）传递过来的图像数据。那个模块提供的数据，图像格式是RGBA32，我在Intel Pentium主机上编译出的Skia库，默认的颜色类型是kBGRA_8888_SkColorType（kN32_SkColorType），这导致在使用Skia绘制之前，必须将收到的RGBA32格式的数据转换为BGRA，否则就什么也画不出来。转换确实可行，我试了试，不过在图像分辨率较高时，耗时会明显增加。因为需要逐像素转换，一个像素转换至少需要三次赋值和两次索引操作，百万像素的图片就需要百万次操作。\n\n当我完成像素格式转换，看到CEF中显示出颜色正常的数据后，大大松了口气。此时我有两个想法：\n\n那天腊月二十八，马上要过年了，第一种选择所需要的工作仅仅是找理由说服自己，说服领导。这很容易，我们程序员老这么干啊，不是吗？\n\n第二种选择就要困难一些，得做实验，得硬着头皮看Skia源码……这且不说，做了努力也不见得就能解决，说不定耽搁了时间和进度，最后还得回到第一种选择上去。总之我发现自己内心有点儿小拒绝，也能找到各种理由让自己放弃这个相对较难的选择。你遇到过这种情况吗？\n\n哦卖糕的，我该怎么做呢？\n\n后来过完年，2.14号情人节那天我就去上班了。大部分人还没到岗，我觉得研究一下第2种选择里那个问题很有必要——有时慢就是最大的缺陷啊。于是就做了下面这些事情：\n\n选择容易的路，这种想法貌似难以避免，往往是不经意间就冒出来了。而真正去解决问题，则需要鼓足勇气努力说服自己。\n\n第二天我觉得研究SkCanvas到底怎样使用SkBitmap来绘图的，花了大半天时间做实验、阅读Skia的源码，终于发现SkCanvas基于SkBitmap绘图时会创建一个SkBitmapDevice，而SkBitmapDevice会根据kN32_SkColorType来分支操作，而Intel Pentium主机是小端字节序，Skia的默认编译选项编译出来的库kN32_SkColorType就是BGRA，所以当我传递把SkBitmap的ColorType设置为kRGBA_8888_SkColorType，再将这个SkBitmap传递给SkCanvas时，SkCanvas构建SkBitmapDevice来作为绘图的backend，就注定了失败！\n\n原因明白了，我又有两个选择：\n\n第一个选择，工作就到此完了，也可以解释给领导和小伙伴了。\n\n第二个选择，得研究Skia的构建系统，还得了解控制颜色类型的那些宏定义，还得看SkBitmapDevice、SkBitmap到底如何使用颜色类型……就这还不知道编译出来的库是否有其它副作用（结果证明是有的，后话）……\n\n我又为这个纠结了一阵，这天就这么下班了……\n\n第二天上班，我鼓起勇气选择了研究Skia，嘿，别说，经过对ninja脚本、config头文件以及SkImageInfo相关类库的研究，我真了解清楚了怎样才能编译出默认使用RGBA的库，并且下班前编译出来了哦。哇，我做实验时写的小demo，使用这个新版本的库，RGBA的Bitmap用作后端正常了！\n\n接下来的一天，我修改了PPAPI插件的代码框架，取得了大大的进步：接收到的数据可以不经转换就正常显示了！\n\n心里挺高兴：我战胜了自己从权的想法。\n\n然而问题来了，从本地图片文件加载图片时，Red和Blue通道反了，用到的图标看起来诡异得很，效果全部不对……折腾了三种加载本地图片的方法，都不行。可是内存里绘制是正确滴……\n\n又来到了十字路口，面临了几个选择：\n\n第2个，前面干过了，就是复制点儿代码，工作量很小，很有诱惑力。\n\n第1个，bitmap用Windows API，png、jpeg也都有解码库，之前也用过其他的图像库，解码出的数据也是RGBA的，看起来也没什么难的，就是多一些工作量。\n\n第3个，充满未知和阻力。要知道看别人的代码总是很头疼的，尤其想Skia这种优秀的开源库，代码很棒很巧妙，模块间设计的接口挺简洁的，很多东西都抽象、封装了，要理解需要不少时间……还有，缺少文档（好吧，代码就是最好的文档，永不会遭遇文档和实现脱节的问题）……\n\n找了会图像库，什么FreeImage、CxImage，看了会Skia源码，……思想斗争到下班也没决定，记录到本子上，第二天接着选择吧。\n\n我回到家里就琢磨这个问题：为什么我老想选择容易的路？\n\n此时我脑子里就回想之前的工作历程，哪些能Run能出结果的代码被迫重构了，哪些临时策略导致了技术债务造成了恶劣影响……\n\n程序员出于（我不代表所有程序员）本能都想省事儿，选择容易的路、确定性高的路，这没什么好非议的——假如容易的路能漂亮的解决问题，它就是最好的选择。\n\n然而为了摆脱压力而采用易行的、凑合的、从权的、临时的技术方案，多数时候会带来技术债务。\n\n如你所见，我在使用Skia在PPAPI插件中绘制另一个模块传递过来的RGBA图像数据时遇到了问题，在解决问题的过程中，经历了三次选择，每一次都面临容易的妥协方案和较难的、不确定的但真正解决问题的方案。我在这三个时刻，都倾向于选择容易的、工作量小的、耗时短的方案。\n\n这不单是我个人的情况，而是大多数程序员从某个问题的多个备选解决方案中选择时的习惯性行为。这种习惯性行为，一方面出自人的一种本能——人总是不假思索地放弃挑战选择那条容易的路。因为挑战伴随着不确定性和自我控制，不如唾手可得的方法来得快速。以小孩子为例，你在他面前放两颗糖，告诉他有如果明天吃掉就可以再得到两颗糖现在吃掉就再也没有了，他很可能稍稍犹豫后就抓起那两颗糖吃掉。\n\n我们倾向于即刻的满足，延迟满足是需要经过练习才能形成的思维和行为习惯。这是程序员选择易行解决方案的一个重要缘由。\n\n避免麻烦和烦恼是本性，所以即便没有外界压力，我们还是倾向于选择看起来更省事儿的方案。然而这并不是程序员做出这种选择的所有原因。程序员这么做，往往还有其它的原因：\n\n这是导致选择简单粗暴解决方案的最常见最直接的原因。\n\n回到我前面说的问题，其实是个小问题，在这样的小问题上花将近一周的时间，在交付时间紧张的情况下是很难被允许的（我是刚好在过完春节这个缓冲期才有可能从容来解决它），自己不允许领导也不允许。当你感知到交付时间的强大压力，结果往往就是先实现再说，以后有时间再来优化。然而这是程序员说过的最大的、最堂而皇之的谎言，那些凑合事儿的实现，往往就那么着了，直到它出问题被用户和领导逼着限时修改，才开始新一轮的循环。\n\n很多公司鼓（qiang）励（po）大家干更多的活，如果你能更多的并行工作、更快的交付、完成更多的版本，绩效就会更好。在这种导向（制度）下，我们就会更重视数量和速度，忽略质量和可维护性，眼前不出问题就得过且过，慢慢形成只管拉屎不管擦屁股的开发习惯。\n\n不但是程序员，程序员的领导的绩效往往也是这么个导向，所以一线管理者往往会接受中层、高管的不合理交付要求，转身就会给程序员更紧迫的交付时间把压力传递下来。\n\n这也是一个重要原因，有时程序员遇到的问题他眼下根本解决不了，只能粉饰过去或绕道而行——要从根儿上解决那就花得时间太久了，谁都无法接受（参考前面两点）。\n\n这也是很多程序员做事儿时的常见心态：能Run就先Run，不出问题就先这么着，想那么多干嘛，出了问题再说，反正干不完的活。\n\n过年时和我原来的老板吃饭，他说了一句让我印象深刻的话：如果一个公司不能让员工觉得是给自己工作，那这个公司迟早完蛋。这其实说的是事业心态。\n\n你觉得自己是在干活还是干事业，是给自己干还是给公司干，很大程度上决定了你怎么干。\n\n回头来看我前面的经历，有两点是需要特别注意的：\n\nOk，这也是软件开发过程中避免堆积技术债务时需要参考的非常重要的两点。\n\n关于这两点，做过两年开发的都有体会。然而深有体会的人往往并不掌握决定权，所以，我们还要让管理层和老板们意识到下面几点：\n\n只有意识到了这几点，技术氛围、绩效导向才会改变，才有利于形成向技术债务说No的文化。\n\n更多文章，请关注我的微信订阅号“程序视界”或专栏“漫谈程序员”。", "link": "http://blog.csdn.net/foruok/article/details/51176303", "publishDate": "2016-04-18 07:16", "title": "\r\n        技术债务可能是这样来的            \r\n        "}
{"readCount": "88", "article": "，是面向对象语言的重要机制。 \n\n 概念：一个类（子类）可以使用从另一个类（父类、超类）继承 。 \n\n java中的继承是 ，即一个子类只能有一个父类。 \n\n 当然， 也可以继承。 \n\n 了解什么是类看这里:类、对象到底有什么秘密 \n\n 了解接口的概念看这里:java接口到底是什么 \n\n 接口和抽象类的区别看这:接口和抽象类有什么区别\n\n广义上讲，继承类、继承抽象类、实现接口都可以称为继承，但目前所说的java继承只是继承类或抽象类，即 最直接的体现。 \n\n 了解更多is-a模式看这里：is-a，has-a，like-a是什么 \n\n 继承类、抽象类使用 ，实现接口使用 。通过使用这些关键字，我们可以使一个对象获得另一个对象的属性及方法。\n\n根据上面的例子，面向对象的术语即：\n\n要注意的一个非常重要的事实是，Java只支持 。这意味着，一个类不能扩展多个类。因此，以下是非法的：\n\n接口也可以扩展另一个接口，类似于一个类扩展另一个类中的方法。同样使用 来扩展接口，使子接口继承父接口的方法。 \n\n 下面的Sports接口是由Hockey和Football接口扩展。\n\nHockey接口有四个方法，但它继承了两个Sports接口的方法，因此，实现Hockey类需要实现六个方法。同样地，一个实现Football类需要实现Football的三个方法，以及Sports的两个方法。\n\n我们知道，一个java类只能继承一个父类，所以，多重继承是 。 \n\n 但是，一个接口可以扩展 父接口。 \n\n 例如，Sports和Event都是接口：", "link": "http://blog.csdn.net/ooppookid/article/details/51193477", "publishDate": "2016-04-19 20:01", "title": "\r\n        Java技术_Java千百问（0035）_java类的继承有什么意义            \r\n        "}
{"readCount": "68", "article": "这几天一直在学习UML的十种图，之前是对UML十种图的主要概念进行理解，现在对其及其之间的关系进行理解\n\n最开始学习的第一个图是用例图，用例图主要用于为系统的功能需求建模，它主要描述系统功能，也就是从外部\n\n用户的角度观察，系统应该完成哪些功能，有利于开发人员以一种可视化的方式理解系统的功能需求，可以说用例图\n\n是对系统功能的一个宏观描述。在学习用例图的过程中第一次接触了粒度和范围这两个概念，用例粒度的好坏直接影\n\n响到后面设计过程中类图设计的好坏，类图设计的好坏又直接影响代码设计的难度，还会影响到未来软件的维护和修\n\n补工作，所以在用UML设计的时候，从第一步就要严格把关。\n\n \n\n\n\n包图是一种维护和描述系统总体结构的模型的重要建模工具，通过对图中各个包以及包之间关系的描述，展现出\n\n系统的模块与模块之间的依赖关系。\n\n \n\n        在UML的建模机制中，模型的组织是通过包（package）来实现的。包可以把所建立的各种模型（包括静态和动\n\n态）组织起来，形成各种功能或用途的模块，并可以控制包中元素的可见性和描述包之间的依赖关系。通过这种方式\n\n系统模型的实现者能够在高层把握系统的机构。\n\n \n\n\n\n类图显示了系统的静态结构，标识了不同的实体（人、事物、数据）是怎样彼此相关联的。在类图中不仅包含了\n\n为系统定义的各种类（包含类的属性和操作），也包含了它们之间的关系（依赖、关联、聚合等）。为了能够使系统\n\n具有足够的灵活性和可变性，类的抽象程度和好坏成为描述系统的关键。对象是类的实例化，因此对象图具有与类图\n\n在对象图里面每个属性都会有一个具体的值，因为它是一个实例相关的，而类图则从抽象的角度描述系统的静态\n\n包图是对一个程序、软件系统进行模块划分，使得我们的源码结构更加的清晰；类图是对一个系统的静态部分进\n\n行呈现；而对象图是这个系统在某一时刻的展现。\n\n \n\n\n\n时序图是对对象之间传送消息的时间顺序的可视化表示，从一定程度上更加详细地描述了用例表达的需求，将其\n\n转化为进一步、更加正式层次的精细表达，这也是时序图的主要用途之一。它的目的是描述系统中各个对象按照时间\n\n协作图是对在一次交互过程中有意义对象和对象间的链建模，显示了对象之间是如何进行交互的，以执行特定用\n\n例或用例中特定部分的行为。在协作图中，类元角色描述了一个对象，关联角色描述了协作关系中的链，并通过几何\n\n从本质上来讲这个图是等价的，只是表示的方法不同，但可以通过适当的方式将它们进行转换。与时序图不同是\n\n，在协作图中明确表示了角色之间的关系，通过协作角色来限定协作中的对象或链。另一方面，协作图不将时间作为\n\n单独的维来表示所以必须使用顺序号来判断消息顺序以及并行线程。\n\n \n\n        二者侧重点不同：时序图侧重时间顺序，协作图侧重对象之间的关系。\n\n \n\n        一般来说建模的时候画时序图（Sequence Diagram)就可以。用不同的方式展示系统剖面图或是侧面图，如果你\n\n的系统的交互的消息比较多，希望来清晰地描述它的组织结构的话呢，可以再辅助画协作图。\n\n \n\n\n\n用来描述一个特定对象的所有可能状态以及由于各种事件的发生随时间变化而引起的状态之间的转移。由于系统\n\n中对象的状态最易发现和理解，所以建模时往往首先考虑基于状态之间的控制流。\n\n \n\n\n\n活动图是状态机的一个特殊的例子，它强调计算过程中的顺序和并发步骤，活动图所有或多数状态都是活动状态\n\n或动作状态，它阐明了业务用例实现的工作流程。\n\n \n\n\n\n状态图侧重从行为的结果来描述（状态），活动图侧重从行为的动作来描述（活动）；活动图中的动作可以放在\n\n泳道中，而状态图则不可以。泳道可以将模型中的活动按照职责组织起来。\n\n \n\n        在实际项目中，活动图并不是必须的。一般在以下情况需要使用活动图：\n\n \n\n       （1）描述一个并行的过程或者行为\n\n \n\n       （2）描述一个算法\n\n \n\n       （3）描述一个跨越多个用例的活动\n\n \n\n\n\n活动图和流程图非常相似，往往流程图所能表达的内容，在大多数情况下活动图也可以表达。二者的区别：\n\n（1）活动图是面向对象的，而流程图是面向过程的\n\n组件图用来表示系统中组件和组件、类或接口与组件之间的关系图，组件与组件之间的关系表现为依赖关系，定\n\n义的类或接口与类之间的关系表现为依赖关系或实现关系。\n\n \n\n        组件图的作用：\n\n \n\n       （1）为架构设计师提供了一个系统解决方案模型的自然形式\n\n \n\n       （2）在系统完成后允许一个架构设计师验证系统的必须功能是由组件实现的\n\n \n\n       （3）是不同开发小组之间交流的有用工具\n\n \n\n       （4）有利于系统开发者决定开发的任务分配和需求分析\n\n \n\n       （5）有利于系统管理员较早地提供关于组件及其关系的信息\n\n \n\n\n\n配置图显示了运行软件系统的物理硬件，以及如何将软件部署到硬件上。也就是说，这些图描述了执行处理过程\n\n的系统资源元素的配置情况以及软件到这些资源元素的映射。配置图中可以包括包和子系统，它们可以将系统中的模\n\n型元素组织成更大的组块。有时，当系统需要可视化硬件拓扑结构的一个实例时，还需要在配置图中加入实例。配置\n\n图中还可以包含组件，这些组件都必须存在于配置图中的节点上。\n\n \n\n\n\n在对软件建模的过程中，通过用例图我们可以知道这个系统的期望行为是什么；通过类图可以描述这个问题域的\n\n词汇，也就是说问题域里面有哪些类，以及这些类的属性和方法都概括出来得到这个问题域的词汇；通过创建时序\n\n图、协作图、状态图、活动图，可以来说明所定义的词汇中的事物是如何共同协作来完成这个行为的。在这一切完成\n\n之后，开始人员需要把这些逻辑设计图转化成实际的事物，如可执行文件、库、表和文档，组件图和配置图是面向对\n\n象的系统的物理方面建模时用的，也就是说组件图和配置图与系统的最后实现密切相关。\n\n \n\n        把UML的四类事物、四种关系和十种图学完之后，这些都只是在理论上的学习，接下来就是对理论的结合进行实\n\n践啦，结合之前所做的机房收费系统用UML进行建模。", "link": "http://blog.csdn.net/erlian1992/article/details/51193407", "publishDate": "2016-04-19 19:58", "title": "\r\n        UML基本构造块之十种图（二）            \r\n        "}
{"readCount": "83", "article": "分析： \n\n \n\n \n\n b[p]为p在原序列中出现的次数 \n\n", "link": "http://blog.csdn.net/d_x_d/article/details/51193394", "publishDate": "2016-04-19 19:50", "title": "\r\n        HDU5439 Aggregated Counting （找规律+预处理+二分）            \r\n        "}
{"readCount": "94", "article": "一棵树的每个节点都是0-9中的某一个数字，现在把从根节点到某一个叶子节点之间所有节点的数字依次连接起来组成一个新的数字。要求所有从根节点到叶子节点组成的数字的和。\n\n如果在叶子节点下再添加一个节点，则表示的数字可以通过将之前的数字乘以10再加上添加节点的数字。通过这一递推关系，我们可以递归地计算每条路径上的表示的数字，代码中参数s表示到当前节点之前该路径上所组成的数字。\n\n欢迎查看我的Github (https://github.com/gavinfish/LeetCode-Python) 来获得相关源码。", "link": "http://blog.csdn.net/u013291394/article/details/51193356", "publishDate": "2016-04-19 19:38", "title": "\r\n        LeetCode Sum Root to Leaf Numbers            \r\n        "}
{"readCount": "157", "article": "前一篇文章中刚刚分析完HDFS的异构存储以及相关的存储类型选择策略,浏览量还是不少的,说明大家对于HDFS的异构存储方面的功能还是很感兴趣的.但是其实一个文件Block块从最初的产生到最后的落盘,存储类型选择策略只是其中1步,因为存储类型选择策略只是帮你先筛选了一些符合存储类型要求的存储节点目录位置列表,通过这些候选列表,你还需要做进一步的筛选,这就是本文所准备阐述的另外一个主题,HDFS的副本放置策略.在写本文之前,我搜过网上关于此方面的资料与文章,还是有许多文章写的非常不错的,所以我会在本文中涉及到其他相关方面的个人感觉有用的知识点与大家分享,不至于文章显得太千篇一律了.\n\n首先这里要花一些篇幅来介绍什么是副本放置策略, 有人也会叫他为副本选择策略,这源于此策略的名称, BlockPlacementPolicy.所以这个策略类重在block placement.先来看下这个策略类的功能说明:\n\n目前在HDFS中现有的副本防止策略类有2大继承子类,分别为BlockPlacementPolicyDefault, BlockPlacementPolicyWithNodeGroup,其中继承关系如下所示:\n\n我们日常生活中提到最经典的3副本策略用的就是BlockPlacementPolicyDefault策略类.3副本如何存放在这个策略中得到了非常完美的实现.在BlockPlacementPolicyDefault类中的注释具体解释了3个副本的存放位置:\n\n这里橙色区域表示的就是writer写请求者,绿色区域就是1个副本.从这里可以看出,HDFS在容错性的设计上还是做了很多的思考的.从下文开始主要分析的就是BlockPlacementPolicyDefault默认放置策略,至于BlockPlacementPolicyWithNodeGroup也会稍微提一提,但是二者主要区别其实不大.\n\nBlockPlacementPolicyDefault这个类中的选择目标节点的处理逻辑还是有些复杂的,我会尽量讲的简单化,如有不理解之处,读者可以自己对照源码进行进一步的学习.\n\n在默认放置策略方法类中,核心方法就是chooseTargets,但是在这里有2种同名实现方法,唯一的区别是有无favoredNodes参数.favoredNodes的意思是偏爱,喜爱的节点.这2个方法的介绍如下\n\n在chooseTargets传入偏爱的节点参数会使得方法在选择节点时候优先选取偏爱节点参数中的节点.这是这个参数的最根本的影响.\n\n我们先来分析 chooseTarget无favoredNodes参数的实现过程,最终会进入到真正的同名实现方法中.我将此过程分为了3个子阶段\n\n在上述的3个子阶段中,第二阶段是其中最主要的策略选择操作同样也是最具复杂性的,所以这里先分析第三个阶段的工作,就是根据已经选择好的目标节点存放位置,然后形成pipeline进行返回.\n\n整个过程就是传入目标节点列表参数,经过getPipeline方法的处理,然后返回此pipeline.先来看getPipeline的注释:\n\n关键是这句The pipeline is formed finding a shortest path that \n\n starts from the writer,就是说从writer所在节点开始,总是寻找相对路径最短的目标节点,最终形成pipeline,学习过算法的人应该知道,这其实也是经典的TSP旅行商问题.下面是具体的源码实现:\n\n一句话概况来说,就是选出一个源节点,根据这个节点,遍历当前可选的下一个目标节点,找出一个最短距离的节点,作为下一轮选举的源节点,这样每2个节点之间的距离总是最近的,于是整个pipeline节点间的距离和就保证是足够小的了.那么现在另外一个问题还没有解决,如何定义和计算2个节点直接的距离,就是下面这行代码\n\n要计算其中的距离,我们首先要了解HDFS中如何定义节点间的距离,其中涉及到了拓扑逻辑结构的概念,结构图如下:\n\n这里显示的是一个三层结构的树形效果图,Root可以看出是一个大的集群,下面划分出了许多个机架,每个机架下面又有很多属于此机架的节点.在每个连接点中,是通过交换机和路由器进行连接的.每个节点间的距离计算方式是通过寻找最近的公共祖先所需要的距离作为最终的结果.比如Node1到Node2的距离是2,就是Node1->Rack1, Rack1->Node2.同理,Rack1的Node1到Rack2的Node1的距离就是4.大家有兴趣的可以学习一下相关算法LCA最近公共祖先算法.\n\n下面介绍chooseTarget主要选择逻辑,因为个人感觉是最复杂的,所以放在最后分析.首先,务必要明确以下几个涉及参数的作用和所代表的意义:\n\n我们可以对照上文提到的3副本的存放方式.首先是第一个节点的选择,第一个节点其实是最好选择的,因为他不用其他2个节点的位置影响,但是他同样要约束于请求方所在位置,这里满足2个原则:\n\n后续还进行了如下的操作\n\n下面是非常巧妙的3副本存储位置的选取,需要与上图描述的存放方式进行对照,可能会好理解一些\n\n如果看完这段逻辑,你还不理解的话,没有关系,只要明白经典的3副本存放位置,多余的副本随机存放的原理即可.当然在其间选择的过程中可能会发生异常,因为有的时候我们没有配置机架感知,集群中都属于一个默认机架的default-rack,则会导致chooseRemoteRack的方法出错,因为没有满足条件的其余机架,这时需要一些重试策略.\n\n标题显示的四个选择目标节点位置的方法其实是一个优先级渐渐降低的方法,首先选择本地存储位置.如果没有满足条件的,再选择本地机架的节点,如果还是没有满足条件的,进一步降级选择不同机架的节点,最后随机选择集群中的节点,关系图如下\n\n但是这里还是要区分一下,chooseLocalStorage方法,与其余的3个方法稍显不同,单独实现,而其余的方法是通过传入不同参数直接或间接调用 \n\n chooseRandom方法.\n\n从这里我们可以看到,这里最明显的区别就是chooseRandom的scope参数的传入,scope参数的直接作用就是会选择出是否属于此机架下的节点列表\n\n在NetworkTopology下有了具体的实现\n\n具体细节的实现,读者可以自行研究.根据机架选择好节点之后,同样会进行Storage存储位置的选择判断,然后加入到result目标列表中.\n\n如果block放置节点位置已经初步选择好了,是否意味着此位置就可以加入最终的result列表中呢,答案是否定的,因为这里还要经过最后一道严谨的对于Storage的验证.(这里要明确一点:目标位置result类别存储的对象是DatanodeStorageInfo,这个类表示的是具体到节点存储磁盘目录级别的信息,并不是广义上的Node),需要满足以下几个条件\n\nchooseTargets的调用分为有favoredNodes参数和无favoredNodes参数参数2类. \n\n 无参数的chooseTargets主要被BlockManager对象所调用,如图\n\n其中RepliactionWork主要做的就是集群中待复制的副本块. \n\n 而带favoredNodes参数的调用则是外界主动设置进来的,调用场景如下\n\nfavoredNodes的源头是DFSClient客户端主动设置进来,然后创建到DFSOutputStream的DataStream中,然后被后续方法所调用.但是DFSClient在创建默认DFSOutputStream时是默认不带favoredNodes传入的\n\n就是最后一个参数null.其实传入的favoredNodes更多的是一种期望,并不一定真正能被namenode最后真正存放,因为中间会经过很多因素的判断,而且在后面的Balance数据平衡的过程中,某些block还是会被挪走,就不会按照原来的位置存.\n\nBlockPlacementPolicyWithNodeGroup是BlockPlacementPolicyDefault的继承子类.前者与后者在原理上十分类似,不过在逻辑上从机架是否相同的判断变为了是否为同个Node-Group的判断.下面是其中的注释声明:\n\n他是一个4层层级结构,在Rack机架层下还多了Node-Group层,结构图如下:\n\n由于与其父类的逻辑没有很大的差别,就不展开做阐述了.\n\n以上内容就是本文所要表达的HDFS放置策略的内容了,可能内容量上有点大,部分地方描述的可能也有不够好的地方,希望大家通过此文能对HDFS的3副本策略以及背后的HDFS的放置策略有更深的了解.", "link": "http://blog.csdn.net/androidlushangderen/article/details/51178253", "publishDate": "2016-04-19 19:36", "title": "\r\n        HDFS副本放置策略            \r\n        "}
{"readCount": "52", "article": "刚入门的小伙伴们是不是还在迷惑到底系统从我们按下电源键的那一刻，是如何进行一步一步运行的，知道我们输入用户名和密码进入系统，来操作电脑，今天我们就来写一下开机的启动过程以及相关服务的控制。\n\n设定形式是“：id:3:initdefault:”，表明Linux运行在等级3上\n\n根据运行级别的不同，系统会运行rc0.d到rc6.d中的相应的脚本程序，来完成相应的初始化工作和启动相应的服务\n\nrc.local配置文件就是在一切初始化工作后，Linux留给用户进行个性化的地方，你可以进行一些开机加载的自定义设置，只限制于当前登录的用的个人设置。\n\n到此为止，小伙伴是否了解了系统是如何进行启动的以及启动时加载所需的配置文件的顺序，对于系统的启动过程来说是我们入IT这一行的所要必须掌握的。掌握了此启动过程，当系统出毛病的时候，我们才能根据启动顺序来进行分析并解决问题。", "link": "http://blog.csdn.net/xuxingzhuang/article/details/51191970", "publishDate": "2016-04-19 19:36", "title": "\r\n        Linux系统启动引导过程和服务控制            \r\n        "}
{"readCount": "82", "article": "题意： \n\n 给出n个点，m条无向边，m实际上就是n-1，组成的一棵树，拆掉一条边后，树会变为两个，问两个树的差最小是多少？\n\n思路： \n\n 树形ＤＰ(连ｄｐ数组都没好吧。。。) \n\n dfs的过程中维护一个ｍｉｎ值（即枚举删的边）；", "link": "http://blog.csdn.net/alps233/article/details/51193338", "publishDate": "2016-04-19 19:35", "title": "\r\n        [poj 3140] Contestants Division 　树形ＤＰ            \r\n        "}
{"readCount": "55", "article": "今天我们开始第一次课，我们本门课的题目叫“C#面向对象程序设计语言”。那么什么是“C#”,什么又是“面向对象”呢？，程序设计语言的概念，我们在ITFC中已经学习过了（程序：为了让计算机执行某些操作或解决某个问题而编写的一系列有序指令的集合；语言：此处指与计算机进行交流的代码、指令）。\n\nC#外行的人也叫做“C井”，我们采用微软的标准称呼“C Sharp”，意味着“开发利器”。C#语言在语法方面兼顾了Java和C++的特点，在应用方面它吸收了VB、Delphi等的优点。C#的出现使我们在掌握主流面向对象思想的同时，可以快速的开发人事管理系统、酒店管理系统等，可以轻松完成大型商业网站、电子商务应用等。C#语言可以应用在视频、游戏、科学计算、网络软件、移动电话等领域，当然更为重要的是为在最短的时间内创造最大的价值的吸引力，这一切都是我们学习C#的吸引力。\n\n首先提到“对象”二字，有的朋友可能马上就想到BF、GF了，^.^。在我们程序设计里面“对象”的概念要比BF、GF要宽泛的多的多。那么，在程序设计中，何谓“对象”呢？一言以蔽之：万事万物皆为对象。\n\n那么，拿我正在使用的这个笔记本来说吧，它就是个“对象”。下面来分析一下这个电脑对象具有的状态和行为吧。\n\n按照这个思路，请大家每人想3个对象，并列举出其状态和行为。\n\n刚才有同学提到了对象是：人、电脑、鼠标等，那么人、电脑、鼠标是对象吗？请大家注意老师的案例，对象：老张的HP笔记本电脑，而不是电脑；同理，人不是对象，而胡一刀这个人是对象。那么有思考能力的同学会问，二者有什么联系呢？\n\n大家考虑一下，胡一刀、周杰杰、李春春这些是不是具体的人呢？而我们说的“人“是上面这些人的什么呢？统称。那么在面向对象里面，我们称这个统称为类。\n\n我们可以把类比做模板（模子），是对象的蓝图。下面是类和对象的区别：\n\n不管是Java还是C#，还是其他的支持面向对象的语言，类指的是设计期的对象，当然不会占用运行期的内存空间，因为到了运行期就无所谓类了，都是实例在那里运作了，因此类当然不会占用内存空间，即便是你看到了new的语句，那也只不过是你设想的内存空间。\n\n \n\n 类好比就是图纸，而实例就是房子，图纸上的房子当然不会占用实际的空间，但是那个想象中的房子将会占用多少空间却是图纸上已经标明了的，一旦付诸实施，那个房子的样子肯定是预期的。一个类设计完成，那么它的大小以及代码的运作都固定了，一旦其实例运行起来，其效果当然也是预期的。\n\n \n\n 那么问你图纸上画的是什么？当然是“房子”，那么这个抽象的“房子”实际上相当于对象，虽然它并不实实在在存在，这就是对象的抽象意义。根据图纸造好的房子当然也是对象，这就是对象的实际意义。\n\n关键字：是指在C#中具有特殊意义的单词，不能随意使用。例如class 、static、void等都是关键字。(总数)\n\n编译器概念：类似于日常生活的翻译。可以将我们不懂的外文书籍或其他文化产品翻译为我们看得懂的书籍或其他文化产品。\n\nà环境变量配置：即指定我们C#翻译的地址（翻译的家在哪里？）\n\n1.找到C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.50727,这个地址，大家会发现有个,这个就是我们要找的C#的翻译。\n\n项目背景：对于每位学习程序的朋友来说，都有自己的第一个激动人心的程序。\n\nSystem.Console.WriteLine(\"偶滴第1个程序^.^\");//用来在屏幕上显示一句话\n\n3.在C#程序中，哪个地方是程序的入口点_______\n\n1.在DOS时代，有经典的黑屏游戏选择界面，现请大家做出我们自己的游戏选择界面：", "link": "http://blog.csdn.net/zhangchen124/article/details/51193269", "publishDate": "2016-04-19 19:32", "title": "\r\n        C#OOP之一面向对象简介            \r\n        "}
{"readCount": "98", "article": "生成圆和椭圆等基本曲线的函数并未作为图元功能包含在OpenGL核心库中。但该库包含了显示Bezier样条的功能，该曲线是由一组离散点定义的多项式。OpenGL实用库(GLU)中包含有球面和柱面等三维曲面函数以及生成B样条的函数，它是包含简化Bezier曲线的样条曲线的总集。我们可以使用有理B样条显示圆、椭圆和其他二维曲线。此外，OpenGL实用工具包(GLUT)中还有可以用来显示某些三维曲面(如球面、锥面和其他形体)的函数。然而，所有这些函数比本章中介绍的基本图元应用得更多，因此我们将在第7章进一步讨论这一组函数。\n\n我们还可以使用折线来近似地显示简单曲线。仅需确定一组曲线上的点并将它们连接成一组直线段。折线中的线段越多，曲线越平滑。图3.15给出了用于表示弧的几种折线显示。\n\n第三种可选方法是按下面将给出的算法写出自己的曲线生成函数。首先讨论生成圆和椭圆的高速算法，然后再看一个生成其他二次曲线、多项式和样条曲线的函数。\n\n由于圆是图形中经常使用的元素，因此在大多数图形软件中都包含生成圆和圆弧的函数。这些软件有时也会提供一个能显示包括圆和椭圆在内的多种曲线的通用函数。\n\n\n\n我们将圆定义为所有距中心位置(xc，yc)为给定值r的点集(参见图3.16 )。对于任意的圆点(x,y),这个距离关系可用笛卡儿坐标系中的勾股(Pythagorean)定理定义为\n\n\n\n利用这个方程，我们可以沿x轴从xc-r到xc+r以单位步长计算对应的y值，从而得到圆周上每点的位置:但这并非是生成圆的最好方法。这个方法的一个问题是每一步包含很大的计算量。而且，如图3.17所示，所画像素位置间的间距是不一致的。我们可以在圆斜率的绝对值大于1后，交换x和y(即步进y值并计算x值)来调整间距。但是，这种方法增加了算法所需的计算量和处理过程。另一种消除图3.17中不等间距的方法是使用极坐标r和θ(参见图3.16)来计算沿圆周的点。以参数极坐标形式表示圆方程，可以得到方程组:\n\n\n\n \n\n        使用上述方法以固定角度为步长生成显示结果时，就可以利用沿圆周的等距点来绘制出圆。为了减少计算量，我们可以在相邻点间使用较大的角度间隔并用线段连接相邻点来逼近圆的路径。在光栅显示中设定角度间隔为1/r可获得较连续的边界。这样绘出的像素位置大约间隔一个单位。尽管极坐标系统提供了等距点，但三角函数计算是十分耗时的。\n\n        对于上述任何一种圆生成算法，考虑圆的对称性可以减少计算量。圆的形状在每个象限中是相似的。因此，如果我们确定了在第一象限中圆的位置，则可以生成该圆在xy平面中第二象限的部分，这是因为两个圆弧段对于y轴是对称的。考虑对于x轴的对称性，根据第一和第二象限中的圆弧可以得到第三和第四象限的圆弧。在八分圆之间也有对称性，因此可以进一步细化，一个象限内的相邻八分圆的圆弧对于分割两个部分的45度直线是对称的。这种对称情况可参见图3.18，图中八分之一圆上的一点(x,y)将映射到xy平面的其他七个八分圆的点。这种方法利用了圆的对称性，仅需计算从x=0到x = y分段内的点就可得到整个圆的所有像素位置。在这个八分圆中，圆弧斜率绝对值小于或等于1.0 。x = 0时圆的斜率是0，而当x = y时圆的斜率是-1.0。\n\n\n\n使用对称性及方程(3.26)或方程(3.28)来确定圆周上的像素位置，仍然需要大量的计算时间。笛卡儿方程(3.26)包括乘法和平方根运算，而参数方程中包含乘法和三角运算。更有效的画圆算法是如同Bresenham画线算法一样以决策参数的增量计算为基础，这样仅仅包括简单的整数处理。通过设定在每一取样步骤中寻找最接近圆周像素的决策参数，可以将光栅系统的Bresenham画线算法移植为画圆算法。然而，圆方程(3.26)是非线性的，计算像素与圆的距离必须进行平方根运算。Bresenham画圆算法则通过比较像素与圆的距离的平方而避免了平方根运算。然而，不做平方运算而直接比较距离是可能的。该方法的基本思想是检验两像素间的中间位置以确定该中点是在圆边界之内还是之外。这种方法更易应用于其他圆锥曲线，并且对于整数圆半径，中点方法生成与Bresenham画圆算法相同的像素位置。而且使用中点检验时，沿任何圆锥截面曲线所确定的像素位置，其误差限制在像素间隔的1/2以内。", "link": "http://blog.csdn.net/heyuchang666/article/details/51193199", "publishDate": "2016-04-19 19:25", "title": "\r\n        计算机图形学（二）输出图元_6_OpenGL曲线函数_1_圆生成算法            \r\n        "}
{"readCount": "89", "article": "没装此插件之前的VC代码窗口是如下的；\n\n在左侧会列出全部文件和扫描到的符号；\n\n此工具的设置选项；下图是对C++代码提示的设置；\n\n在代码窗口中，按下t，会列出t打头的成员；\n\n此工具解压后仅有一个可执行文件，运行后有如下界面；运行时关闭VC；\n\n下面设定代码窗口字体大一些；字体为微软雅黑；雅黑者，雅且黑是也；\n\n如果各位还有其他好的省事的VC辅助编程工具；可以推荐给我；", "link": "http://blog.csdn.net/bcbobo21cn/article/details/51193074", "publishDate": "2016-04-19 19:24", "title": "\r\n        图解VC6辅助编程工具的使用            \r\n        "}
{"readCount": "66", "article": "ECMAScipt中的变量又是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。所以javascript中用var关键字来定义变量，所以无法确定变量一定会存储什么值，也就不知道变量到底会是什么类型，因为可以随时改变变量的类型。今天这篇文章就和大家一起来学习javascript中的类型，虽然很简单，但是我感觉数据类型是学习某种语言的前提，所以必须掌握它。\n\ntypeof操作符是用来检测变量的数据类型。对于值或变量使用typeof操作如会返回如下的字符串\n\nUndefined类型只有一个值，即特殊的Undefined。在使用var声明变量，但没有对其初始化时，这个变量的值就是Undefined。\n\n注意：我们在定义变量的时候，尽可能的不要只声明，不赋值。\n\nNull也是一个只有一个值得数据类型，它的值就是null，任何变量只要给其赋值为null的话这个变量的数据类型就是Null类型。null值表示控对象指针，所以申明的变量要是想用来保存对象并且在申明之初还不能确定具体保存哪个对象的时候就将其赋值为null，在使用的时候只要检查该变量是否为null就可以知道该变量是否保存了对象。\n\n\n\n在javascript中Boolean类型用还是比较多的一种简单数据类型，它有两个值，分别是true和false，因为在javascript中字母是区分大小写的，所以True和False不是Boolean的值。\n\n 可以通过如下方式给Boolean类型的变量赋值：\n\n\n\n  调用Boolean()方法可以将任何类型的值转化成与之相对应的Boolean类型的值，也就是可以将其转化成true或者false。\n\n 例如：\n\nJavaScript中的字符串String一个特殊的基本数据类型，在很多语言中，String是以对象的形式表示的，但在JavaScript里，String是当作一种基本数据类型，是通值传递的方式来操作。但它是一个比较特殊的基本类型。\n\n\n\n\n\n 从运行结果可以看到，仿佛strA通过值传递的方式复制了一份给了strB。当strA改变的时候，strB并没有改变，似乎我们已经可以下结论，String就是个基本数据类型。\n\n\n\n运行结果显示，String无法当作一个对象来处理。这也证明了一点：基本类型虽然也可以添加属性，也不会报错，经测试添加完之后却是无法访问的，实际上，javascript里的String是不可以改变的，javascript也没有提供任何一个改变字符串的方法和语法。\n\n对象其实就是一组数据和功能的集合。对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。而创建Object类型的实例并为其添加属性和（或）方法，就可以创建自定义对象。\n\n\n\n\n\n \n\n \n\n \n\n hasOwnProperty(propertyName)——用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名(propertyName)必须以字符串形式指定（例如：o.hasOwnProperty(\"name\")） \n\n \n\n isPrototypeOf(object)——用于检查传入的对象是否是另一个对象的原型 \n\n \n\n \n\n \n\n \n\n \n\n valueOf()——返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同 \n\n \n\n\n\nUndefined、Null、Boolean、Number、String是javascript中的基本数据类型，而Object属于引用类型。用typeof检测其他类型会返回相应的字符串，但是检测null或对象时，会返回”object\"，Boolean、Number、String 这三个是Javascript中的基本包装类型，也就是这三个其实是一个构造函数，他们是Function的实例，是引用类型。JavaScript是最麻烦的一种语言，没有之一，所有要想熟悉，还得多加练习啊。\n\n", "link": "http://blog.csdn.net/lxd8731247769/article/details/51188698", "publishDate": "2016-04-19 19:22", "title": "\r\n        "}
{"readCount": "73", "article": "上一篇我们研究了创建型模式，这一篇们开始研究结构模型，这里主要解决合成还是继承的问题。如何通过适当的方法给类解耦。这里是我们主要考虑的问题，这里6种设计模式的关系我就先不研究，了解每一种模式再说。\n\n这里主要介绍六中设计模式的特点与结构，记录下自己的想法。\n\n将一个类的接口转换成客户希望的另外一个接口。 A d a p t e r模式使得原本由于接口不兼容 \n\n 而不能一起工作的那些类可以一起工作。\n\n类适配器和对象适配器有不同的权衡。类适配器\n\n这里面比价复杂，适配器模式主要是转换数据格式的。也就是接口，listview中的adapter就是adapter模式\n\n将抽象部分与它的实现部分分离，使它们都可以独立地变化。\n\n将对象组合成树形结构以表示“部分 -整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。\n\n这里最好的例子是view类其实就是一个递归调用。来解析特定的内容。有利于解耦。并且对于自己不知道内容的编程非常重要\n\n为子系统中的一组接口提供一个一致的界面， F a c a d e模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n\nFlyweight模式的有效性很大程度上取决于如何使用它以及在何处使用它。当以下情况都成立时使用Flyweight模式：\n\n使用Flyweight模式时，传输、查找和 /或计算外部状态都会产生运行时的开销，尤其当Flyweight原先被存储为内部状态时。然而，空间上的节省抵消了这些开销。共享的Flyweight越多，空间节省也就越大。 \n\n 存储节约由以下几个因素决定： \n\n • 因为共享，实例总数减少的数目 \n\n • 对象内部状态的平均数目 \n\n • 外部状态是计算的还是存储的\n\n我不是很明白。在当前我考虑不到大量的类对象的创建。\n\n为其他对象提供一种代理以控制对这个对象的访问。\n\n在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用Proxy模式。下面是一些可以使用Proxy模式常见情况：\n\nProxy模式在访问对象时引入了一定程度的间接性。根据代理的类型，附加的间接性有多种用途：\n\n这是个很有用的模式，", "link": "http://blog.csdn.net/qq_28282317/article/details/51192501", "publishDate": "2016-04-19 19:22", "title": "\r\n        GOF设计模笔记式之结构模型            \r\n        "}
{"readCount": "122", "article": "归并算法的中心是归并两个已经有序的数组。归并两个有序数组A和B，就生成了第三个数组C，数组C包含数组A和B的所有数据项，并且使它们有序的排列在数组C中。首先我们来看看归并的过程，然后看它是如何在排序中使用的。\n\n假设有两个有序数组，不要求有相同的大小。设数组A有4个数据项，数组B有6个数据项，它们要被归并到数组C中，开始时数组C有10个存储空间，归并过程如下图所示：\n\n归并排序的思想是把一个数组分成两半，排序每一半。然后用merge方法将数组的两半归并成一个有序的数组。被分的每一半使用递归，再次划分排序，直到得到的子数组只含有一个数据项为止。正如上面所说的，归并排序需要额外的一个和AB两个数组总和相等的空间，如果初始数组几乎沾满了整个存储器，那么归并排序就不能工作了。\n\n算法分析：归并排序的运行时间最差、最好和平均都是O(NlogN)，但是它需要额外的存储空间，这在某些内存紧张的机器上会受到限制。归并算法是由分割和归并两部分组成的，对于分各部分，如果我们使用二分查找，时间是O(NlogN)，在最后归并的时候时间是O(N)，所以总时间是O(NlogN)。空间复杂度为O(N)。", "link": "http://blog.csdn.net/eson_15/article/details/51193139", "publishDate": "2016-04-19 19:17", "title": "\r\n        数据结构和算法14 之归并排序            \r\n        "}
{"readCount": "55", "article": "接口是面向对象编程的基础，它是一组包含了函数型方法的数据结构，与类一样，都是编程语言中比较抽象的概念。比如生活中的接口，机顶盒，人们利用它来实现收看不同频道和信号的节目，它犹如对不同类型的信息进行集合和封装的设备，最后把各种不同类型的信息转换为电视能够识别的信息。在编程语言中的接口，实际上是不同类的封装并提供统一的外部联系通道，这样其他对象就可以利用接口来调用不同类的成员了。\n\n——整理自《jQuery开发从入门到精通》\n\n构造函数(类)是具体的实现，接口是类的约定。API接口(应用程序接口)、人机交互接口、电源接口、USB接口等虽然用途不同，功能各异，但是都包含一个共同的特性：约定、规范。可以说，接口就是一张契约和合同，它约定了设计者和使用者都必须遵循的要求。\n\n举一个很有必要的例子，在java中实现接口，比如下面的代码：\n\n乙方负责实现接口约定的功能。功能的实现就是所谓的类。如下实例：\n\n这样，乙方实现了这个接口，而甲方也应该来按照接口的约定去使用类App就行了。 这样，乙方实现了这个接口，而甲方也应该来按照接口的约定去使用类App就行了。 所以说，接口(interface)和类(class)，实际上都是相同的数据结构。 在接口中可以声明属性，方法，事件，类型，但不能声明变量，且不能设置被声明成员的具体值(功能实现)。 也就是说，接口只能定义成员，不能给定义的成员赋值。而接口作为它的继承类或派生类的约定，继承类或派生类共同完成接口属性、方法、事件、类型的实现。在接口和实现类之间，不管是方法名还是属性调用顺序上都应保持一致。 接口的目的就是约束编码，促使代码规范，对于强类型语言是必须的，也是非常重要的环节。但是对于JavaScript弱类型语言来说，严格的类型检查会束缚JavaScript的灵活性。很多前端开发人员根本不用接口，但不会影响脚本的设计。 使用接口的好处：降低对象间的耦合度，提高代码的灵活性。学会使用接口，能够让手中的函数变得灵巧，这在大型开发中是很重要的。 对于JavaScript来说，本身不支持接口功能，没有提供内置方法。但是人工设计一个额外的接口程序，又会对程序的性能产生影响。项目越大，这种开销越大。所以，用不用接口可以遵循两个条件： ① 项目大小，如果是一个框架，使用接口在一定程度上会提高程序的性能。如果是简单的应用，就不必使用接口了。 ② 如果对JavaScript接口比较熟练，多用接口也可以，如果担心过多使用接口影响性能，则可以在考虑产品发布前，清除接口功能模块，或者设置接口的执行条件。防止它被频繁执行，影响性能。 (1) 设计一个接口辅助的类结构，这个构造函数相当于一个过滤器，用于在接口实例化过程中，检测初始化参数是否合法。如果符合接口设计标准，则把第2个参数中每个方法名和参数个数以数组元素的形式输入接口内部属性methods。在输入前分别检测每个参数类型是否符合规定。同时检查参数是否存在残缺，并即时以0补齐参数。 function Interface(name,methods){ // 接口辅助类，参数包括接口实例的名称和方法集   if(arguments.length!=2){ // 如果参数个数不等于2，抛出异常。     throw new Error('标准接口约定，需要两个参数');   }   this.name = name; // 存储第一个参数值，实例化后就是接口实例的名称   this.methods = []; // 接口实例的方法存储器   if(methods.length < 1){ // 如果第二个参数的元素个数为0，说明是空数组，抛出异常。     throw new Error('接口的第二个参数不能为空');   }   for(var i = 0; i < methods.length; i++){ // 开始对第2个参数的元素进行遍历检测     var item = methods[i];     if(typeof item[0] !== 'string') { // 如果第二个参数的第一个元素不是string类型，抛出异常       throw new Error(\"接口约定的第一个参数应为字符串\");     }     if(item[1]&&typeof item[1] !== 'number'){ // 如果第二个参数有第二个元素，且第二个元素不是number类型，抛出异常       throw new Error('接口约定的第个参数应为数值');     }     if(item.length == 1){ // 如果第二个参数只有一个元素，那么手动给它添加第二个元素 0       item[1] = 0;     }     this.methods.push(item); // 把符合规定的方法存储到数组存储器中。   } } (2) 为接口辅助类 Interface 定义一个方法 implements，该方法将检测实现类是否符合接口实例的约定。它至少包含两个参数，第1个参数o表示实现类，第2个参数及其后面的参数表示该类将要实现的接口标准。也就是说，可以为一个类指定多个接口约定，这样就可以更灵活的分类设计接口实例。然后遍历第二个及其后面的所有参数，在循环结构中，先洁厕接口是否为接口标准的实例，否则就会抛出异常。再从接口实例的方法存储器中逐一读取方法名，填入类中来验证类的方法是否符合接口实例设置的标准，验证包括方法名、function类型和参数个数。如果有问题，立即抛出异常。 (2) 为接口辅助类 Interface 定义一个方法 implements，该方法将检测实现类是否符合接口实例的约定。它至少包含两个参数，第1个参数o表示实现类，第2个参数及其后面的参数表示该类将要实现的接口标准。也就是说，可以为一个类指定多个接口约定，这样就可以更灵活的分类设计接口实例。然后遍历第二个及其后面的所有参数，在循环结构中，先洁厕接口是否为接口标准的实例，否则就会抛出异常。再从接口实例的方法存储器中逐一读取方法名，填入类中来验证类的方法是否符合接口实例设置的标准，验证包括方法名、function类型和参数个数。如果有问题，立即抛出异常。 Interface.implements = function(o){  // 用于检测类方法是否符合接口实例的约定 ，此处的o,将来会是类中的this   if(arguments.length<2){ // 检测该方法传递的数值是否符合规定     throw new Error(\"接口约定类应包含至少两个参数。\");   }   for(var i=1;i<arguments.length; i++){ // 遍历检测类所遵循的实例是否合法     var interface = arguments[i]; // 这里interface表示接口的实例对象。     if(interface.constructor !== Interface){       throw new Error('从第2个以上的参数必须为接口实例');     }     for(var j=0;j<interface.methods.length;j++){ // 检测类方法是否符合接口实例的约定       var method = interface.methods[j][0];       if(!o[method] || typeof o[method] !== 'function' || o[method].length!==interface.methods[j][1]) {         throw new Error(\"该实现类没能履行\" + interface.name + \"接口方法\" + method + \"约定\");       }     }   } } (3) 实例化接口标准，Interface 接口仅仅是个构造函数，也就是个框架协议，还没有制定类应该遵循的具体标准。框架协议中，已经设计好了监测逻辑，一旦实例化接口，并指明类应遵守的约定，那么应用该标准的实例的类就必须准守。 (3) 实例化接口标准，Interface 接口仅仅是个构造函数，也就是个框架协议，还没有制定类应该遵循的具体标准。框架协议中，已经设计好了监测逻辑，一旦实例化接口，并指明类应遵守的约定，那么应用该标准的实例的类就必须准守。 \n\n (4) 在类中定义应该实现的标准，即类应该遵循的接口约定。 下面根据Interface接口标准定义了6个具体的接口实例。(4) 在类中定义应该实现的标准，即类应该遵循的接口约定。 // 创建一个木驴类 function Neddy(){ this.name = ''; Interface.implements(this,Base,Get,Set); // 让木驴类实现接口的实例,可以指定多个，也可以只有一个。 } // 按照接口实例来定义 两个方法get,set Neddy.prototype.get = function(){ return this.name; } Neddy.prototype.set = function(name){ this.name = name; } (5) 在类中设置了多个接口实例，我们来进行检测\n\n 成功完成接口的应用，这里，如果在Neddy类中，我们让它实现的接口实例和 Neddy.prototype中给类定义的方法不统一，或者接口与接口之间有冲突，就会抛出异常。比如我们可以修改Neddy中的接口实现，再给它添加一个接口实例Base2，就会报异常，因为我们没有按照接口的协议，给Neddy添加saying()方法。\n\n (5) 在类中设置了多个接口实例，我们来进行检测成功完成接口的应用，这里，如果在Neddy类中，我们让它实现的接口实例和 Neddy.prototype中给类定义的方法不统一，或者接口与接口之间有冲突，就会抛出异常。比如我们可以修改Neddy中的接口实现，再给它添加一个接口实例Base2，就会报异常，因为我们没有按照接口的协议，给Neddy添加saying()方法。 上面的举例只是用js来模拟实现接口功能，在实际开发中，我们需要根据不同的需求，开发不同的接口。 \n\n", "link": "http://blog.csdn.net/tyro_java/article/details/51191007", "publishDate": "2016-04-19 19:17", "title": "\r\n        面向对象在JavaScript中的接口实现            \r\n        "}
{"readCount": "45", "article": "题意：先给两个整数n和nc，然后给出一个字符串，问有多少种不同的长度为n的子串，nc为字符串中不同的字符数。\n\n问题的形式定义: 假设文本（Text）是一个长度为n的数组T[1…n], 模式(Pattern)是一个长度为m ≤ n.的数组P[1..m];. 又假设P和T中的元素都属于有限字母表Σ 中的字符。 P和T常称为字符串。\n\n如果0 ≤ s ≤ n – m 且T[s+1..s+m]=P[1…m], 则说P在T中出现且位移为s，此时成s为一个有效位移。\n\n字符串匹配问题就变成在一个在一段制定的文本T中找出模式P的所有有效位移的问题。\n\n下图给出了将要介绍的字符串匹配算法以及它们的预处理时间和匹配时间。\n\n用Σ* 表示用字母表Σ中的所有有限长度的字符串的集合\n\n如果某个字符串 y ∈ Σ*，使得x＝wy 。则称w是x的前缀, 记为w � x 。 如果w是x的后缀，记为w � x\n\n可以把字符串匹配问题描述为 找出0 ≤ s ≤ n-m 并满足P � T 的所有位移s\n\n时间复杂度为O((n - m + 1)m), 如果m = �n/2�. 那么时间复杂度为Θ(n2), 这个算法效率不高，原因在于对于s的一个值，获得的关于文本的信息在考虑s的其他值时完全被忽略了。 例如，如果 P＝aaab，设s＝0 是有效的，那么 s＝1， 2， 3 就不可能是有效位移，因为T[4]=b. 实际应用中，Rabin和Karp建议的字符串匹配算法能较好地运行，还可以归纳出有关问题地其他算法，如二维模式匹配。 （一般情况, 假定每个字符是基数为d的表示法中的一个数字， d=|Σ|。)可以用一个长度为k的十进制数字来表示由k个连续字符组成的字符串. 已知模式P[1..m]，设p表示其相应十进制数地值，类似地， 对于给定的文本T[1..n]. 用 t  表示长度为m的子字符串 T[s + 1 ‥ s + m]（ s = 0, 1, . . . , n – m）， t  = p 当且仅当 [s + 1 ‥ s + m] = P[1 ‥m]; 因此s是有效位移当且仅当 t  = p. (暂不考虑p和t 可能是很大的数的情况)。 可以用霍纳规则(Horner’s rule) 在Θ(m) 的时间内计算p的值 如果能在总共Θ(n - m + 1) 时间内计算出所有的t 的值，那么通过把p值与每个t （有n－m＋1个）进行比较，就能够在Θ(m) + Θ(n - m + 1)= Θ(n) 时间内求出所有有效位移。（计算出1个t 就跟p比较，处理结果。） 为了在Θ(n - m) 时间内计算出剩余的值t , t , . . . , t 可以在常数的时间内根据t 计算出t ，先看例子，假如m = 5，t  = 31415, 我们去掉高位数字T [s + 1] = 3，然后在加入一个低位数字T [s + 5 + 1]（假设为2)，得到： 如果预先计算出10m-1（通过数论中的技术可以在O(lg m)完成, 在这里只需简单地在O(m）时间内计算出就可以)。那么就可以在常数时间计算出t 因此，可以在Θ(m)时间内计算出p和t 然后在Θ(n - m + 1)时间内计算出t , . . . , t  并完成匹配。 现在来解决唯一的问题，就是计算中p和t 的值可能太大，超出计算机字长，不能方便地进行处理。如果p包含m个字符，那么， 关于在p上地每次算术运算需要“常数”时间这一假设就不合理了，幸运的是，对这一问题存在一个简单的补救方法，对一个合适的模q来计算p和t 的模，每个字符是一个十进制数，因为p和t 以及公式1计算过程都可以对模q进行，所以可以在Θ(m)时间内计算出模q的p值，在Θ(n - m + 1)时间内计算出模q的所有t 值，通常选模q为一个素数，使得10q正好为一个计算机字长，单精度算术运算就可以执行所有必要的运算过程。 一般情况下，采用d进制的字母表{0, 1, . . . , d - 1}, 所选的q要满足d*q < 字长，调整公式1， 使其为： 但是加入模q后，由t  ≡ p (mod q)不能说明 t  = p. 但t  � p (mod q), 可以说明 t  ≠ p, 因此当t  ≡ p (mod q)时， 再用朴素的字符串匹配算法验证t  = p。. 如果q足够大，可以期望伪命中很少出现。 搜索P在T中出现的位置 参数d :字母表的进制，亦即是字母表的元素个数 参数q : 一个较大的素数， 只需d*q < 字长 搜索P在T中出现的位置参数d :字母表的进制，亦即是字母表的元素个数参数q : 一个较大的素数， 只需d*q  因为Rabin_Karp算法跟朴素的字符串匹配算法一样，对每个有效位移进行显示验证，如果P = am and T = an, 则验证所需时间为Θ((n - m + 1)m), 因为n - m + 1个可能的位移中每一个都是有效位移。 实际应用中，有效位移数很少（常数c个），因此期望的匹配时间为O((n - m + 1) + cm) = O(n+m), 选取的素数q比p的长度m大得多。 \n\n", "link": "http://blog.csdn.net/rachelsg/article/details/51193172", "publishDate": "2016-04-19 19:15", "title": "\r\n        Pku1200 Crazy Search（Rabin Karp）            \r\n        "}
{"readCount": "58", "article": "深度神经网络，即含有多个隐藏层的神经网络。通过引入深度网络，我们可以计算更多复杂的输入特征。因为每一个隐藏层可以对上一层的输出进行非线性变换，因此深度神经网络拥有比“浅层”网络更加优异的表达能力（例如可以学到更加复杂的函数关系）。\n\n其实三层网络，只要能无限增加隐层的单元数就能拟合任何函数。而使用深度网络的最主要优势是：它能以更加紧凑简洁的方式来表达比浅层网络大得多的函数集合。正式点说，我们可以找到一些函数，这些函数可以用k层网络简洁地表达出来（这里的简洁是指隐层单元数目只需与输入单元数目呈多项式关系）。但是对于一个只有k-1层的网络而言，除非它使用与输入单元数目呈指数关系的隐层单元数目，否则不能表达这些函数。\n\n举一个简单的例子，比如我们打算构建一个布尔网络来计算 n 个输入比特的奇偶校验码（或者进行异或运算）。假设网络中的每一个节点都可以进行逻辑“或”运算（或者“与非”运算），亦或者逻辑“与”运算。如果我们拥有一个仅仅由一个输入层、一个隐层以及一个输出层构成的网络，那么该奇偶校验函数所需要的节点数目与输入层的规模n呈指数关系。但是，如果我们构建一个更深点的网络，那么这个网络的规模就可做到仅仅是n的多项式函数。\n\n逐层贪婪训练方法是取得一定成功的一种方法。逐层贪婪算法的主要思路是每次只训练网络的一层，即我们首先训练一个只含一个一个隐藏层的网络，仅当这层网络训练结束之后才开始训练一个有两个隐藏层的网络，一次类推。在每一步中，我们把已经训练好的前 k-1 层固定，然后增加第 k 层（也就是将我们已经训练好的前 k-1 的输出作为输入）。每一层的训练可以是有监督的（例如，将每一步的分类误差作为目标函数），但更通常使用无监督方法（例如自动编码器，我们会在后边的章节中给出细节）。这些各层单独训练所得到的权重被用来初始化最终（或者说全部）的深度网络的权重，然后对整个网络进行“微调”（即把所有层放在一起来优化有标签训练集上的训练误差）.\n\n逐层贪婪法的好处是：相比于随机初始化而言，各层初始权重会位于参数空间中较好的位置上。然后我们可以从这些位置出发进一步微调权重。从经验上来说，以这些位置为起点开始梯度下降更有可能收敛到比较好的局部极值点，这是因为无标签数据已经提供了大量输入数据中包含的模式的先验信息。\n\n栈式自编码神经网络是一个由多层稀疏自编码器组成的神经网络，其前一层自编码器的输出作为其后一层自编码器的输入。在训练每一层参数的时候，会固定其它各层参数保持不变。所以，如果想得到更好的结果，在上述预训练过程完成之后，可以通过反向传播算法同时调整所有层的参数以改善结果，这个过程一般被称作“微调（fine-tuning）”。\n\n如果你只对以分类为目的的微调感兴趣，那么惯用的做法是丢掉栈式自编码网络的“解码”层，直接把最后一个隐藏层的 a^{(n)} 作为特征输入到softmax分类器进行分类，这样，分类器（softmax）的分类错误的梯度值就可以直接反向传播给编码层了。\n\n这里是对手写数字进行分类，神经网络的层数是4层。最后一层是一个softmax分类器。即手写数字先通过两层隐层把一些特征组合起来，softmax分类器根据这些特征进行分类。", "link": "http://blog.csdn.net/aisikaov5/article/details/51193137", "publishDate": "2016-04-19 19:07", "title": "\r\n        栈式自编码算法            \r\n        "}
{"readCount": "81", "article": "wireshark抓包为：（wireshark会将seq序号和ACK自动显示为相对值） 　　 \n\n 　　 \n\n 　　 \n\n 　　1）主机A发送 =1234567的数据包到服务器，主机B由syn=1知道，A要求建立连接； 　　 \n\n 　　 \n\n 　　 \n\n 　　2）主机B收到请求后要确认连接信息，向A发送 =7654321的包 　　 \n\n 　　 \n\n 　　 \n\n 　　3）主机A收到后检查ack 是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送 ，主机B收到后确认seq值与ack=1则连接建立成功。 　　 \n\n 　　 \n\n \n\n\n\n断开连接过程与建立连接类似 \n\n 1）主机A发送位码为 ，用来关闭客户A到服务器B的数据传送 \n\n 2）服务器B收到这个FIN，它发回一个 ，确认序号为收到的序号加1 \n\n 3）服务器B关闭与客户端A的连接，发送一个 给客户端A \n\n 4）客户端A发回 报文确认，并将确认序号设置为收到序号加1 \n\n \n\n\n\n因为每个方向都需要一个FIN和ACK，当一端发送了FIN包之后，处于半关闭状态，此时仍然可以接收数据包。 \n\n 　　在建立连接时，服务器 发送。 \n\n 　　但是在断开连接时，如果一端收到FIN包，但此时仍有数据未发送完，此时就需要先向对端回复FIN包的ACK。等到将剩下的数据都发送完之后，再向对端发送FIN，断开这个方向的连接。 \n\n 　　因此很多时候 发送，因此需要四次握手 \n\n \n\n\n\n持续时间未2MSL，一个数据包在网络中的最长生存时间为MSL。 \n\n 　　 \n\n 　　ACK和FIN在网络中的最长生存时间就为2MSL，这样就可以可靠的断开TCP的双向连接。 \n\n \n\n\n\nTCP首部选项字段多达40B，一些常用的字段有： \n\n 　　1）选项结束字段（EOP，0x00），占1B，一个报文段仅用一次。放在末尾用于填充，用途是说明：首部已经没有更多的消息，应用数据在下一个32位字开始处 \n\n 　　2）无操作字段（NOP, 0x01），占1B，也用于填充，放在选项的开头 \n\n 　　3）MSS（最大报文段长度），格式如下：种类（1B，值为2），长度（1B，值为4），数值（2B） \n\n 　　用于在连接开始时确定MSS的大小，如果没有确定，就用默认的（一般实现是536B） \n\n 　　4）窗口扩大因子，格式如下：种类（1B，值为3），长度（1B，值为3),数值（1B） \n\n 　　新窗口值 = 首部窗口值 * 2的（扩大因子）次方 \n\n 　　当通信双方认为首部的窗口值还不够大的时候，在连接开始时用这个来定义更大的窗口。仅在连接开始时有效。一经定义，通信过程中无法更改。 \n\n 　　5）时间戳（应用测试RTT和防止序号绕回） \n\n 　　6）允许SACK和SACK选项 \n\n \n\n\n\nlinux内核中会维护两个队列： \n\n 　　1）未完成队列：接收到一个SYN建立连接请求，处于SYN_RCVD状态 \n\n 　　2）已完成队列：已完成TCP三次握手过程，处于ESTABLISHED状态 \n\n 　　当有一个SYN到来请求建立连接时，就在未完成队列中新建一项。当三次握手过程完成后，就将套接口从未完成队列移动到已完成队列。 \n\n 　　backlog曾被定义为两个队列的总和的最大值，也曾将backlog的1.5倍作为未完成队列的最大长度 \n\n 一般将backlog指定为5 \n\n \n\n\n\naccept会监听已完成队列是否非空，当队列为空时，accept就会阻塞。当队列非空时，就从已完成队列中取出一项并返回。 \n\n 　　而已完成队列中的都是三次握手过程已经完成的，因此accept发生在三次握手之后。 \n\n \n\n\n\n1）伪装的IP向服务器发送一个SYN请求建立连接，然后服务器向该IP回复SYN和ACK，但是找不到该IP对应的主机，当超时时服务器收不到ACK会重复发送。当大量的攻击者请求建立连接时，服务器就会存在大量未完成三次握手的连接，服务器主机backlog被耗尽而不能响应其它连接。即 \n\n 　　防范措施： \n\n 　　1、降低SYN timeout时间，使得主机尽快释放半连接的占用 \n\n 　　2、采用SYN cookie设置，如果短时间内连续收到某个IP的重复SYN请求，则认为受到了该IP的攻击，丢弃来自该IP的后续请求报文 \n\n 　　3、在网关处设置过滤，拒绝将一个源IP地址不属于其来源子网的包进行更远的路由 \n\n 　　2）当一个主机向服务器发送SYN请求连接，服务器回复ACK和SYN后，攻击者截获ACK和SYN。然后伪装成原始主机继续与服务器进行通信。 \n\n 　　\n\n", "link": "http://blog.csdn.net/u012658346/article/details/51192944", "publishDate": "2016-04-19 19:03", "title": "\r\n        TCP相关面试题总结            \r\n        "}
{"readCount": "208", "article": "", "link": "http://blog.csdn.net/daidaineteasy/article/details/51192124", "publishDate": "2016-04-19 19:00", "title": "\r\n        Linux学习笔记--free命令(查看内存信息的命令)            \r\n        "}
{"readCount": "100", "article": "把RTT和Syscalls添加到工程里面。在Syscalls里面只要要选择对应的开发环境对用文件即可，我用的是keil所以选择\n\n调试接口：用的是SWD。\n\n注意：output file 是打印出来的Log。文件默认放在Segger的\\SEGGER\\JLink_V502这个路径下面\n\n打印出来了 Hello,rtt   这是在主函数里面添加的打印代码。。OK。。。。。。\n\n", "link": "http://blog.csdn.net/a369000753/article/details/51192707", "publishDate": "2016-04-19 19:00", "title": "\r\n        SEGGER_RTT的使用            \r\n        "}
{"readCount": "74", "article": "当你的app的组件启动了，并且app中没有其他的组件的时候，Android系统会自动为为这个应用启动一个linux进程，其中有一个执行的线程。默认时，一个app的所有的组件运行在同一个进程的同一个线程，也就是主线程。如果一个组件启动的时候，app已经有一个进程了，（因为可能这个应用中其他的组件已经运行了），那么这个组件就在这个进程中被运行，而且使用同一个线程。但是你可以你的应用中的不同的组件在不同的进程中运行，而且可以给一个进程添加新的线程。\n\n下面的教程讲述Android应用中进程和线程是如何工作的。\n\n默认而言，同一个应用中的组件运行在同一个进程中，应用不应该改变这种设定。但是如果你需要控制某一个组件对应一个线程，那么你可以在manifest文件中进行设定。\n\nmanifest文件给四大组件元素——<activity>，<service>,<receriver>和<provider>都提供了一个android:process的属性，来指定组件可以在哪一个进程中运行。你可以设定来使得所有的组件都在各自的进程中运行，也可以让其中几个共享一个进程。你也可以通过设定android：process属性来使得不同应用中的组件在同一个进程中运行，这样就可以实现不同的应用使用同一个Linux用户ID，并且使用同一个证书签名。\n\n<application>元素也支持android：process属性，可以为其中的元素都设定一个默认的属性。\n\n当内存不足的时候，或者用户启动了更加迫近使用的程序的时候，Android可能会在一些时刻关闭一些进程。而在被关闭进程中的组件，会按照顺序被销毁。当这个进程里面的组件又有任务的时候，这个进程就会被重新创建。\n\nAndroid系统会通过衡量进程相对于用户的权重，来决定销毁哪些的进程。比如销毁一个含有一个很久都没有显示过的activity的进程，要比销毁一个正在显示的activity所在的进程好。进程是否被销毁取决于在进程中运行的组件的状态。用来判别是否结束线程规则将在下文讨论。\n\nAndroid系统会尽可能长时间地维护一个进程，但是终究会为了更新更重要的进程来将旧的进程结束，以回收空间。系统根据进程中拥有的组件和组件的状态来给进程设立优先级等级，每一个进程都在优先级等级当中。最低重要性的进程会最先被淘汰，然后是次不重要的，以此类推，直到系统回收了足够的所需空间。\n\n在重要性等级中有五个层次。下面按照重要性的顺序来列举这些等级。（最前面的是最重要的，最不能被杀死的）\n\n这是个用户正在使用的进程。如果下面的情况成立就认为一个进程是前台进程。\n\n- 其中包含一个正在和用户交互的activity（activity的onResume方法被调用过）。\n\n-包含一个与正在和用户交互的activity绑定的service。\n\n- 包含了一个运行在前台的service，也就是service调用过startForeground\n\n通常来讲，只有一些的前台进程才会一直都存在。他们只是最后被杀死，如果内存很低他们就不能都运行。通常在这些时候设备已经进入了内存分页状态，所以需要保证杀掉一些进程的时候用户交互的界面得以保留。\n\n这是一种虽然已经不包含任前台的组件，但是仍然影响用户用户的屏幕显示的进程。如果下面任意的情况都属于可视进程。\n\n- 包含一个不在前台了的activity，但是仍然可以被用户看到（调用了onPause方法）。比如一个前台的activity开启了一个对话框，与此同时之前的那个activity仍然在后面可见。\n\n包含一个使用startService启动的服务，并且服务不在上面两种的级别里面。尽管服务的进程的功用用户不能直接可见，但是他们通常都和用户关心的业务相关。比如说后台播放音乐以及从网络下载数据。所以系统会尽量保证其运行，除非内存空间很低，为了保护前两者等级。\n\n后台进程是包含现在用户不可见的的activity的进程（调用过activity的onStop方法）。它们对用户体验没有直接影响，系统可以在任何时候杀掉他们，给前台，可视，或者服务进程腾出空间。总是有很多的后台进程，所以系统会维护一个LRU（多久没用了的列表least recent used）来使得最近刚刚用过的那些activity最后被杀死。如果一个activity正确地实现了他的生命周期方法，保存了当前的状态，那么杀死他不会对用户体验造成可以看见的影响。因为当用户从新进入这些activity的时候，activity恢复了它的所有的可见状态。关于存储和恢复状态，可以参见Activity文档。\n\n这是不包含任何的activity和组建的进程。保留这种进程唯一目的是用作缓存，来提升下此次其中组件启动需要运行的时间。系统通过杀掉这种进程，来平衡整个系统的里的，进程缓存和底层的内核的缓存。\n\nAndroid系统按照他们包含组件的最高等级的情况来判断优先级。例如如果一个进程包含了一个service和一个可视的activity，那么就被判定为可视进程而非服务进程。\n\n另外，一个进程可能因为被其他的进程所依赖而提升等级。一个被依赖进程的等级一定会比依赖它的进程等级高。例如A进程中的content provider正在为进程B的客户端服务，或者进程A中的服务被B中的组件绑定了，那么A的重要性就会比B高。（至少相同）。因为一个运行了service的进程优先级高于后台activity的优先级，所以与其启动了一个进行长时间运行操作的activity（通过建立一个线程）不如启动一个service更好。特别是这个操作要比activity的生存更长时间的时候。例如如果一个activity通过启动一个service来用网路上传图片，那么即使用户离开了这个activity，图片仍然在被上传。使用service可以保证操作至少拥有service级别的优先级，无论activity发生了什么。这也是为什么broadcast应该使用service，而不是仅仅把费时操作放入一个线程中。\n\n当启动一个应用的时候，为其创建一个执行线程，叫主线程。这个线程十分重要，因为它肩负着派发事件到合适的用户交互的的组件上去的任务，包括绘制事件。她也是你的应用和Android UI工具箱（android.widget和android.view包中的组件）中的组件进行交互的线程。这样而言，主线程有时候也叫作UI线程。（用户交互线程）\n\n系统不会为每一个组件创建分别的线程。 在同一个进程中的组件都是有UI线程实例化的，并且系统对每一个组件的调用都被派发到这个线程中。因此，响应系统调用的方法，比如说onKeyDown方法，用来汇报用户动作的，或者声明周期调用，都是在进程的UI线程中调用的。\n\n例如，当用户用户点了一下屏幕上的按钮，你的应用的UI线程就会把这个触控事件派发给控件，反过来它会设定成按下的状态，并且发送一个使之无效的请求给事件队列（因为已经响应过了）。UI线程会把请求出列，并且向控件发出重绘自己的通知。\n\n如果你的app要在响应用户交互中运行高负荷，那么如果你没有合适地构造你的应用，单线程模型就会性能很差。特别是如果什么事情都交给UI线程去做的话，网络访问或者数据库查询，就会使得整个UI都阻塞。当线程被阻塞的时候，就无法再派发事件，包括绘制事件。从用户的角度来说，就是应用卡了。更差劲的是如果UI线程阻塞了大概5秒以上，就会弹出一个恼人的应用没有响应ANR对话框。用户会为此不开心，从而关掉甚至卸载你的应用。\n\n另外，Android UI工具箱是线程不安全的。所以你不可以在你的工作线程中（也就是非UI线程）操作篡改UI——你只能也必须在UI线程中操作UI。如此仅有两个Android单线程模型的规则：\n\n基于上面讨论的单线程模型的特性，保持你的应用UI的响应性，不阻塞UI线程是至关重要的。如果你有一些不是瞬时性的操作，你应该确保在其他的线程中进行这些操作。（也就是后台线程，或者叫工作线程）\n\n下面是一个通过点击监听者的例子，通过点击来从网络上下载一个图片并在ImageView中现实：\n\n这个看起来一开始工作的不错，因为它创建了一个新的线程来处理网络操作。但是它触犯了规则里面的第二条，即不要在非UI线程中操作UI。例子中是在工作线程中进行了UI操作，而不是在UI线程中。这会导致一个未定义的和出乎意料的结果，这会很难也很费时间来追踪这种错误。\n\n为了修整这种错误，Android提供了多种从其他的线程访问UI线程的方式。\n\n例如下面就是用View.post（Runnable）方法修改上面的代码的例子。\n\n现在这个构造就线程安全了：网络操作在另外的线程中进行，并且ImageView的操作是在UI线程中。\n\n然而随着操作的复杂度的上升，这样的代码会变得很难维护。想要用工作线程进行更复杂的交互，你应该考虑在工作线程中使用Handler，来处理从UI线程中发过来的消息。可能最好的解决办法通过扩展AsynTask类，它简化了工作线程需要跟UI线程交互需要做的工作。\n\nAsyncTask可以让你在你的UI上进行异步的工作。它将阻塞的进程放在工作线程，并在UI线程中发布工作进展的情况。不需要你自己处理thread和handler。\n\n你需要继承AsyncTask并且实现doInBackgound()的回调方法，这个方法会在后台的线程池里面运行。如果要一边更新你的UI，你需要实现onPostExcecute方法，它会发送doInBackground()的结果，并且在UI线程中运行，所以你可以安全地更新你的UI。你可以在UI线程中调用execute()方法来启动这个task。\n\n现在UI是安全的情况下，代码也更简单了，因为它将应该在UI线程和工作线程中进行的业务分离了。\n\n你可以阅读AsyncTask的文档来全面的了解怎样使用这个类，下面是一个快速一览：\n\n- 你可以使用泛型来制定传入的参数类型，过程变量，和任务的结果返回类型。\n\n- onPreExcecute(),onPostExecute()和onProgressUpdate()都是在UI线程中执行的。\n\n-在doInBackground()中返回的参数被传入到onPoastExecute()中。\n\n- 你可以在doInBackground中的任何时候调用publishProgress()来在UI线程上执行onProgressUpdate()。\n\n- 你可以在任何时候，任何线程中来取消任务。\n\n警告：当你使用工作线程的时候可能会遇到一个问题。就是因为运行时适配变化导致的activity的重启（比如说当用户改变了屏幕的方向），这可能会销毁掉你的工作线程。想知道怎样在这种重启中继续保持你的任务，和怎样在activity销毁的时候合适地取消任务，请参见Shelves 例子的源代码。\n\n有时候你写的方法可能会被很多的线程调用，所以你的方法需要写的线程安全。\n\n对于远程调用的方法而言，确实是这样，比如说bound service中的方法。当调用运行在同一个进程中的IBinder中的方法时，方法会在调用者的线程中执行。当这个调用在另一个进程的时候，方法会在IBinder所在的进程中维护的线程池中选择一个，在其中来执行方法（排除进程中的UI线程）。例如一个service的onBind方法可能被service进程中的UI线程调用，onBind返回对象（比如说实现了RPC方法的子类）中的方法就会从线程池中的一个线程中调用。因为一个service可能有很多个客户端，多个在线程池中的方法都可以同时调用同一个IBinder中的方法。因此IBinder一定要构造地线程安全。\n\n类似地，一个content provider可能同时接收其他进程中的数据请求。尽管ContentResolver和ContentProvider隐藏了跨进程的通信是怎样管理的，ContentProvider中的响应请求的方法-query(),insert(),delete(),update(),getType-都是在content provider所在的进程的线程池的线程中调用的。因为这些方法可能被任意数量的线程同时调用，所以它们也一定要被定义为线程安全。\n\nAndroid提供了一种跨进程通信机制（IPC），它使用远程调用来实现（RPCs）。其中的方法从一个activity或者其他的应用组件中发起调用，在远程（其他进程）中执行，并且可以返回给调用者结果。这就需要把调用的方法和其数据分解为一个操作系统可以理解的层面上，把它们从本地进程和地址空间传送到远程的进程和地址空间，在那里重新组装以后再重新激活。返回值同样的方式传回。Android系统提供了所有实现IPC传送的代码，所以你需要关注的就是定义和实现RPC编程接口。\n\n要实现IPC，你的应用需要使用bindServie来绑定（bind）一个服务。更多的信息可以参见教程的Service文档。", "link": "http://blog.csdn.net/wallezhe/article/details/51190834", "publishDate": "2016-04-19 18:59", "title": "\r\n        进程和线程（Processes and Threads）——翻译自developer.android.com            \r\n        "}
{"readCount": "226", "article": "在这篇微信公众平台开发教程中，我们将介绍如何在网页中实现获取收货地址的功能。\n\n收货地址共享接口 在2016年4月13日 进行过升级，2016年5月20日之后只能使用新接口，本教程为新版接口的教程！\n\n生成签名之前必须先了解一下jsapi_ticket，jsapi_ticket是公众号用于调用微信JS接口的临时票据。正常情况下，jsapi_ticket的有效期为7200秒，通过access_token来获取。由于获取jsapi_ticket的api调用次数非常有限，频繁刷新jsapi_ticket会导致api调用受限，影响自身业务，开发者必须在自己的服务全局缓存jsapi_ticket 。\n\n参考以下文档获取access_token（有效期7200秒，开发者必须在自己的服务全局缓存access_token）：\n\n用第一步拿到的access_token 采用http GET方式请求获得jsapi_ticket（有效期7200秒，开发者必须在自己的服务全局缓存jsapi_ticket），接口地址如下\n\n签名生成规则如下：参与签名的字段包括noncestr（随机字符串）, 有效的jsapi_ticket, timestamp（时间戳）, url（当前网页的URL，不包含#及其后面部分） 。对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，使用URL键值对的格式（即key1=value1&key2=value2…）拼接成字符串string1。这里需要注意的是所有参数名均为小写字符。对string1作sha1加密，字段名和字段值都采用原始值，不进行URL 转义。\n\n步骤1. 对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，使用URL键值对的格式（即key1=value1&key2=value2…）拼接成字符串string1：\n\n微信收货地址共享，是指用户在微信浏览器内打开网页，填写过地址后，后续可以免填写支持快速选择，也可增加和编辑。此地址为用户属性，可在各商户的网页中共享使用。支持原生控件填写地址，地址数据会传递到商户。\n\n地址共享是基于微信JavaScript API 实现，只能在微信内置浏览器中使用，其他浏览器调用无效。同时，需要微信5.0 版本才能支持，建议通过user agent 来确定用户当前的版本号后再调用地址接口。以iPhone 版本为例，可以通过useragent可获取如下微信版本示例信息：\"Mozilla/5.0(iphone;CPU iphone OS 5_1_1 like Mac OS X)AppleWebKit/534.46(KHTML,like Geocko) Mobile/9B206MicroMessenger/5.0\"其中5.0 为用户安装的微信版本号，商户可以判定版本号是否高于或者等于5.0。\n\n其中，地区对应是国标三级地区码，如“广东省-广州市-天河区”，对应的邮编是是510630。详情参考链接：http://www.stats.gov.cn/tjsj/tjbz/xzqhdm/201401/t20140116_501070.html", "link": "http://blog.csdn.net/pondbay/article/details/51193081", "publishDate": "2016-04-19 18:58", "title": "\r\n        微信支付开发(7) 收货地址共享接口V2            \r\n        "}
{"readCount": "62", "article": "在iOS开发中，苹果提供了许多机制给我们进行回调。 是一种十分有趣的回调机制，在某个对象注册监听者后，在被监听的对象发生改变时，对象会发送一个通知给监听者，以便监听者执行回调操作。最常见的KVO运用是监听 的 属性，来完成用户滚动时动态改变某些控件的属性实现效果，包括渐变导航栏、下拉刷新控件等效果。\n\n\n\nKVO的使用非常简单，使用KVO的要求是对象必须能支持kvc机制——所有NSObject的子类都支持这个机制。拿上面的渐变导航栏做，我们为tableView添加了一个监听者controller，在我们滑动列表的时候，会计算当前列表的滚动偏移量，然后改变导航栏的背景色透明度。\n\n毫无疑问，kvo是一种非常便捷的回调方式，但是编译器是怎么完成监听这个任务的呢？先来看看苹果文档对于KVO的实现描述\n\n简要的来说，在我们对某个对象完成监听的注册后，编译器会修改监听对象（上文中的tableView）的isa指针，让这个指针指向一个新生成的中间类。从某个意义上来说，这是一场骗局。\n\n这里要说明的是isa这个指针，isa是一个Class类型的指针，对象的首地址一般是isa变量，同时isa又保存了对象的类对象的首地址。我们通过object_getClass方法来获取这个对象的元类，即是对象的类对象的类型(正常来说，class方法内部的实现就是获取这个isa保存的对象的类型，在kvo的实现中苹果对被监听对象的class方法进行了重写隐藏了实现)。class方法是获得对象的类型，虽然这两个返回的结果是一样的，但是两个方法在本质上得到的结果不是同一个东西\n\n 在oc中，规定了只要拥有isa指针的变量，通通都属于对象。上面的objc_object表示的是NSObject这个类的结构体表示，因此oc不允许出现非NSObject子类的对象（block是一个特殊的例外）*\n\n 当然了，苹果并不想讲述更多的实现细节，但是我们可以通过运行时机制来完成一些有趣的调试。\n\n根据苹果的说法，在对象完成监听注册后，修改了被监听对象的某些属性，并且改变了isa指针，那么我们可以在监听前后输出被监听对象的相关属性来进一步探索kvo的原理。为了保证能够得到对象的真实类型，我使用了object_getClass方法，这个方法在runtime.h头文件中\n\n在看官们运行这段代码之前，可以先思考一下上面的代码会输出什么。\n\n除了通过object_getClass获取的类型之外，其他的输出没有任何变化。 方法跟 方法可以重写实现上面的效果，但是为什么连地址都是一样的。\n\n 这里可以通过一句小代码来说明一下：\n\n上面这段代码不管你怎么输出，两个结果都是一样的。这是由于super本质上指向的是父类内存。这话说起来有点绕口，但是我们可以通过对象内存图来表示：\n\n\n\n\n\n 每一个对象占用的内存中，一部分是父类属性占用的；在父类占用的内存中，又有一部分是父类的父类占用的。前文已经说过isa指针指向的是父类，因此在这个图中，Son的地址从Father开始，Father的地址从NSObject开始，这三个对象内存的地址都是一样的。通过这个，我们可以猜到苹果文档中所提及的中间类就是被监听对象的子类。并且为了隐藏实现，苹果还重写了这个子类的class方法跟description方法来掩人耳目。另外，我们还看到了新类相对于父类添加了一个 前缀，添加这个前缀是为了避免多次创建监听子类，节省资源\n\n既然知道了苹果的实现过程，那么我们可以自己动手通过运行时机制来实现KVO。runtime允许我们在程序运行时动态的创建新类、拓展方法、method-swizzling、绑定属性等等这些有趣的事情。\n\n 在创建新类之前，我们应该学习苹果的做法，判断当前是否存在这个类，如果不存在我们再进行创建，并且重新实现这个新类的class方法来掩盖具体实现。基于这些原则，我们用下面的方法来获取新类\n\n另外，在判断是否需要中间类来完成监听的注册前，我们还要判断监听的属性的有效性。通过获取变量的setter方法名（将首字母大写并加上前缀set），以此来获取setter实现，如果不存在实现代码，则抛出异常使程序崩溃。\n\n在重新实现setter方法的时候，有两个重要的方法： 和 ，分别在赋值前后进行调用。此外，还要遍历所有的回调监听者，然后通知这些监听者：\n\n所有的监听者通过动态绑定的方式将其存储起来，但这样也会产生强引用，所以我们还需要提供释放监听的方法：\n\n虽然上面已经粗略的实现了kvo，并且我们还能自定义回调方式。使用target-action或者block的方式进行回调会比单一的系统回调要全面的多。但kvo真正的实现并没有这么简单，上述代码目前只能实现对象类型的监听，基本类型无法监听，况且还有keyPath可以监听对象的成员对象的属性这种更强大的功能。\n\n对于基本类型的监听，苹果可能是通过 类型对对象进行桥接转换，然后直接获取内存，通过type encoding我们可以获取所有setter对象的具体类型，虽然实现比较麻烦，但是确实能够达成类似的效果。\n\n 钻研kvo的实现可以让我们对苹果的代码实现有更深层次的了解，这些知识涉及到了更深层次的技术，探究它们对我们的开发视野有着很重要的作用。同时，对比其他的回调方式，KVO的实现在创建子类、重写方法等等方面的内存消耗是很巨大的，因此博主更加推荐使用delegate、block等回调方式，甚至直接使用method-swizzling来替换这种重写setter方式也是可行的。\n\n ps:昨天有人问我说为什么kvo不直接通过重写setter方法的方式来进行回调，而要创建一个中间类。诚然，method_swizzling是一个很赞的机制，完全能用它来满足监听需求。但是，如果我们要监听的对象是tableView呢？正常而言，一款应用中远不止一个列表，使用method_swizzling会导致所有的列表都添加了监听回调，先不考虑这可能导致的崩溃风险，所有继承自tableView的视图（包括自身）的setter都受到了影响。而使用中间类却避免了这个问题", "link": "http://blog.csdn.net/zuojinmin/article/details/51193054", "publishDate": "2016-04-19 18:52", "title": "\r\n        ios /解密 kvo            \r\n        "}
{"readCount": "116", "article": "题意： \n\n 一颗树，n个点（1-n），n-1条边，每个点上有一个权值，求从1出发，走V步，最多能遍历到的权值；\n\n思路： \n\n 树形ＤＰ； \n\n dp[i][j][0/1]表示在ｉ的子树下走ｊ步（回到ｉ点用１表示）；", "link": "http://blog.csdn.net/alps233/article/details/51193014", "publishDate": "2016-04-19 18:46", "title": "\r\n        [Poj 2486]  Apple Tree　树形DP            \r\n        "}
{"readCount": "141", "article": "但是IE6并不支持除超链接元素之外的:hover伪类选择符，此时可以用jquery来弥补ie6对css支持的不足\n\n然后，需要思考以下两种情况 \n\n (1)当单击放大按钮后，如果评论框的高度小于500px，则在原有高度的基础上增加50px。 \n\n (2)当单击”缩小”按钮后，如果评论框的高度大于50px，则在原有高度的基础上减去50px。\n\n通过控制多行文本框的滚动条的变化，使文本框里的内容滚动。\n\n对复选框最基本的应用，就是对复选框进行全选、反选和全不选等操作。复杂的操作要与选项挂钩，来达到各种级联反应效果。\n\n如果需要使复选框处于选中或者不选状态，必须通过控制元素的checked属性来达到目的。 \n\n 如果属性checked的值为true，说明被选中；如果值为false，说明没被选中。因此可以基于这个属性来完成需求。\n\n如果我们要实现，用一个checkbox选项，代替全选和全不选操作。将如何实现呢？\n\n进一步观察思考后发现，所有复选框的checked属性的值和控制全选的复选框的checked属性的值是相同的，因此可以省略if判断，直接赋值。\n\n当单击id为CheckedAll的复选框后，复选框组将被选中。当在复选框组里取消某一个选项的选中状态时，id为“CheckedAll”的复选框并没有被取消选中状态，而此时需要它和复选框组能够联系起来，即复选框组里如果有一个或者更多没选中时，则取消id为CheckedAll复选框的选中状态；如果复选框组都被选中时，则id为CheckedAll的复选框也自动被选中。 \n\n 因此需要对复选框组进行操作，以通过它们来控制id为CheckedAll的复选框。具体实现思路如下：\n\n在表单内class属性为required的文本框式必填项，因此要与非必填表单元素加以区别。可以用append()来完成\n\n当用户名文本框中填写完信息后，将光标的焦点从用户名移出时，需要判断用户名是否符合验证规则。当光标的焦点从邮箱文本框移出时，需要即时判断邮箱填写是否正确，因此需要给表单元素添加失去焦点事件，即blur。\n\n由于每次在元素失去焦点后，都会创建一个新的提醒元素，然后将它追加到文档中，最后出现了多次的提醒信息。因此，需要在创建提醒元素之前，将当前元素以前的提醒元素都删除。可以使用remove()方法来完成。\n\n当鼠标在表单元素中多次失去焦点时，都可以提醒用户填写是否正确。但是，如果用户无视错误提醒，执意要单击提交按钮时，为了使表单那填写元素进行一次整体的验证。可以使用trigger()方法来触发blur事件，从而达到验证效果。如果填写错误，就会以红色提醒用户；如果用户名和邮箱都不符合规则，那么就有两处错误，即有两个class为onError的元素，因此可以根据class为onError 元素的长度来判断是否可以提交。\n\n这样，就可以通过单击每行来实现表格行高亮，同时此行所在的单选框也被选中。 \n\n 上面代码中使用了end()方法。当前对象是$(this),当进行addClass(“selected”)操作时，对象并未发生改变，当执行\n\n那么，什么时候使用attr()，什么时候使用prop()？ \n\n 1.添加属性名称该属性就会生效应该使用prop(); \n\n 2.是有true,false两个属性使用prop(); \n\n 3.其他则使用attr(); \n\n 项目中jquery升级的时候大家要注意这点！ \n\n 3.复选框控制表格行高亮\n\n复选框控制表格行与单选框不同，复选框能选择多行变色，并没有限制被选择的个数。当单击某行时，如果已经高亮了，则移除高亮样式并去掉当前行复选框的选中状态；如果还没高亮，则添加高亮样式并将当前行的复选框选中。\n\n在上例的人员表格的基础上，增加人员分类。\n\n现在需要实现的是单击分类行时，可以关闭相应的内容。例如单击前台设计组行，则它对应的张三李四两行收缩 \n\n 在这个表格中，给每个tr元素设置属性是非常重要的。分类行设置了class=parent属性，同时给他们设置了id属性，而在他们下面的行，只设置了class属性，并且这个class值是在id值的基础上通过加上child_来设置的。基于以上规则，jquery实现代码如下：\n\n在前面的例子中，如果要高亮显示王五那一行，可以使用contains选择器来完成。\n\n利用该选择器再结合jquery的filter()筛选发那个发，可以实现表格内容的过滤。 \n\n 例如使用下面的jquery代码就可以筛选出含有文本“李”的表格行\n\n在某些网站经常有放大和缩小字号的控制按钮，通过单击他们，可以使网页的文字呈现不同的大小。 \n\n 首先在空白的网页上添加两个字号控制按钮和一些文字，HTML代码如下：\n\nparseFloat()方法是去掉单位。slice()方法返回字符串中从指定的字符开始的一个子字符串。因为这里使用的度量单位px是两个字符，所以指定字符串应该从倒数第2个字符开始。\n\n制作选项卡的原理比较简单，通过隐藏和显示来切换不同的内容\n\n按钮切换了，但是选项卡内容没有切换。 \n\n 从选项卡的基本结构可以知道，每个li元素都分别对应一个div区域。因此可以根据当前单击的li元素在所有li元素中的索引，然后通过索引来显示对应的区域。\n\n要注意 (“div.tab_box div”)子选择器，当子节点里再包含div元素时，就会引起程序错乱。因此获取当前选项卡下的子节点，才是这个例子所需要的。\n\n自从Web2.0开始流行后，很多网站更加注重用户自定义，例如在网页上用户可以自定义新闻内容，可以任意拖动网页内容，也可以给网页选择一套自己喜欢的颜色等。 \n\n 网页换肤的原理就是通过调用不同的样式表文件来实现不同皮肤的切换，并且需要将换好的皮肤计入Cookie中，这样用户下次访问时，就可以显示用户自定义的皮肤了。 \n\n 首先设置HTML的结构，在网页中添加选择按钮《li》元素和基本内容，代码如下。\n\n在设计HTML代码时，用了一些小技巧，就是将皮肤选择按钮li元素的id与网页皮肤样式文件名称设置的相同。这样就可以使完成换肤操作简化很多。\n\n为皮肤选择按钮添加单击事件， \n\n 当皮肤选择按钮被单击后，当前皮肤就被勾选。 \n\n 将网页内容换肤\n\n然后完成第2步，即设置网页内容皮肤。前面为link元素设置id此时可以通过attr()方法为link元素的href属性设置不同的值。\n\n但是当客户刷新网页或者关闭浏览器后，皮肤又会被初始化，因此需要将当前选则的皮肤进行保存。\n\n此时，网页换肤功能不仅能正常切换，而且也能保存到Cookie中，当用户刷新网页仍然是当前选择的皮肤\n\n然后再单击事件和if(cookie_skin){}内分别调用对应的参数。", "link": "http://blog.csdn.net/li286487166/article/details/51192963", "publishDate": "2016-04-19 18:37", "title": "\r\n        jQuery中常用网页效果应用            \r\n        "}
{"readCount": "137", "article": "我们在应用开发中，时常需要和时间打交道，比如获取当前时间，获取两个时间点相隔的时间等等，在iOS开发中与时间相关的类有如下几个： \n\n 1. ：表示一个绝对的时间点 \n\n 2. ：时区信息 \n\n 3. ：本地化信息 \n\n 4. ：一个封装了具体年月日、时秒分、周、季度等的类 \n\n 5. ：日历类，它提供了大部分的日期计算接口 \n\n 6. ：用来在日期和字符串之间转换", "link": "http://blog.csdn.net/liuting5521826/article/details/51192956", "publishDate": "2016-04-19 18:35", "title": "\r\n        iOS学习笔记37-时间和日期计算            \r\n        "}
{"readCount": "136", "article": "宗旨：技术的学习是有限的，分享的精神的无限的。\n\n\n\n串行外围设备接口，是一种高速全双工的通信总线。在ADC/LCD等与MCU间通信。\n\n（1）SS（SlaveSelect）：片选信号线，当有多个 SPI 设备与 MCU 相连时，每个设备的这个片选信号线是与 MCU 单独的引脚相连的，而其他的 SCK、MOSI、MISO 线则为多个设备并联到相同的 SPI 总线上，低电平有效。\n\n（2）SCK （Serial Clock）：时钟信号线，由主通信设备产生，不同的设备支持的时钟频率不一样，如 STM32 的 SPI 时钟频率最大为 f PCLK /2。\n\n（3）MOSI （Master Output, Slave Input）：主设备输出 / 从设备输入引脚。主机的数据从这条信号线输出，从机由这条信号线读入数据，即这条线上数据的方向为主机到从机。\n\n（4）MISO（Master Input, Slave Output）：主设备输入 / 从设备输出引脚。主机从这条信号线读入数据，从机的数据则由这条信号线输出，即在这条线上数据的方向为从机到主机。\n\n根据 SPI 时钟极性（CPOL）和时钟相位（CPHA） 配置的不同，分为 4 种 SPI 模式。时钟极性是指 SPI 通信设备处于空闲状态时（也可以认为这是 SPI 通信开始时，即SS 为低电平时），SCK 信号线的电平信号。CPOL=0 时， SCK 在空闲状态时为低电平，CPOL=1 时则相反。时钟相位是指数据采样的时刻，当 CPHA=0 时，MOSI 或 MISO 数据线上的信号将会在 SCK 时钟线的奇数边沿被采样。当 CPHA=1 时，数据线在 SCK 的偶数边沿采样。\n\n首先，由主机把片选信号线SS 拉低，意为主机输出，在SS 被拉低的时刻，SCK 分为两种情况，若我们设置为 CPOL=0，则 SCK 时序在这个时刻为低电平，若设置为 CPOL=1，则 SCK 在这个时刻为高电平。采样时刻都是在 SCK 的奇数边沿(注意奇数边沿有时为下降沿，有时为上升沿)。\n\n（4）数据顺序的传输顺序可进行编程选择，MSB 在前或 LSB 在前。\n\n（5）可触发中断的专用发送和接收标志。\n\nMISO 数据线接收到的信号经移位寄存器处理后把数据转移到接收缓冲区，然后这个数据就可以由我们的软件从接收缓冲区读出了。\n\n当要发送数据时，我们把数据写入发送缓冲区，硬件将会把它用移位寄存器处理后输出到 MOSI 数据线。\n\nSCK 的时钟信号则由波特率发生器产生，我们可以通过波特率控制位（BR）来控制它输出的波特率。\n\n控制寄存器 CR1 掌管着主控制电路，STM32 的 SPI 模块的协议设置（时钟极性、相位等）就是由它来制定的。而控制寄存器 CR2 则用于设置各种中断使能。\n\n最后为 NSS 引脚，这个引脚扮演着 SPI 协议中的SS 片选信号线的角色，如果我们把 NSS 引脚配置为硬件自动控制，SPI 模块能够自动判别它能否成为 SPI 的主机，或自动进入 SPI 从机模式。但实际上我们用得更多的是由软件控制某些 GPIO 引脚单独作为SS信号，这个 GPIO 引脚可以随便选择。\n\n各信号线相应连接到 Flash（型号 ：W25X16/W25Q16）的 CS、CLK、DO 和 DIO 线，实现SPI 通信，对 Flash进行读写，其中 W25X16 和 W25Q16 在程序上不同的地方是 FLASH 的ID 不一样。\n\n读取 Flash 的 ID 信息，写入数据，并读取出来进行校验，通过串口打印写入与读取出来的数据，输出测试结果。\n\n不同的设备都会相应的有不同的指令，如 EEPROM 中会把第一个数据解释为存储矩阵的地址（实质就是指令）。而 Flash 则定义了更多的指令，有写指令、读指令、读ID 指令等。\n\n（2）根据将要进行通信器件的 SPI模式，配置 STM32的 SPI，使能 SPI时钟。\n\n（3）配置好 SPI后，根据各种 Flash定义的命令控制对它的读写。\n\n注意在写操作前要先进行存储扇区的擦除操作，擦除操作前也要先发出“写使能”命令\n\n（5）若读取得的ID正确， 则调用 SPI_FLASH_SectorErase()把 Flash 的内 容擦除，擦除后调用SPI_FLASH_BufferWrite() 向Flash 写入数据，然后再调用SPI_FLASH_BufferRead()从刚刚写入的地址中读出数据。最后调用 Buffercmp() 函数对写入的数据与读取的数据进行比较，若写入的数据与读出的数据相同，则把标志变量TransferStatus1 赋值为 PASSED（自定义的枚举变量）。\n\n（6）最后调用 SPI_Flash_PowerDown()函数关闭 Flash 设备的电源，因为数据写入到Flash 后并不会因断电而丢失，我们在使用它时才重新开启 Flash 的电源\n\n（1）SPI_Mode ：主机模式（SPI_Mode_Master）或从机模式（SPI_Mode_Slave），这两个模式的最大区别为 SPI 的 SCK 信号线的时序，SCK 的时序是由通信中的主机产生的。若被配置为从机模式，STM32 的 SPI 模块将接受外来的 SCK 信号。\n\n （2）SPI_DataSize ： SPI 每次通信的数据大小（称为数据帧）为 8 位还是 16 位。\n\n（3）SPI_CPOL 和 SPI_CPHA ：配置SPI的时钟极性（CPOL）和时钟相位CPHA），这两个配置影响到 SPI 的通信模式，该设置要符合将要互相通信的设备的要求。CPOL 分别可以取 SPI_CPOL_High（SPI 通信空闲时 SCK 为高电平）和SPI_CPOL_Low（SPI 通信空闲时 SCK 为低电平）。CPHA 则可以取 SPI_CPHA_1Edge（在 SCK 的奇数边沿采集数据） 和 SPI_CPHA_2Edge（在 SCK偶数边沿采集数据）。\n\n（4）SPI_NSS ：配置NSS引脚的使用模式，硬件模式（SPI_NSS_Hard）与软件模式（SPI_NSS_Soft），在硬件模式中的 SPI 片选信号由硬件自动产生，而软件模式则需要我们亲自把相应的 GPIO 端口拉高或置低产生非片选和片选信号。如果外界条件允许，硬件模式还会自动将 STM32 的 SPI 设置为主机。我们使用软件模式，向这个成员赋值为 SPI_NSS_Soft。\n\n（5）SPI_BaudRatePrescaler：本成员设置波特率分频值，分频后的时钟即为 SPI 的 SCK信号线的时钟频率。这个成员参数可设置为 f PCLK 的 2、4、6、8、16、32、64、128、256 分频。赋值为 SPI_BaudRatePrescaler_4，即 f PCLK 的 4 分频。\n\n（6）SPI_FirstBit：所有串行的通信协议都会有 MSB 先行（高位数据在前）还是 LSB先行（低位数据在前）的问题，而 STM32 的 SPI 模块可以通过这个结构体成员，对这个特性编程控制。据 Flash 的通信时序，我们向这个成员赋值为MSB先行（SPI_FirstBit_MSB）。\n\n（7）SPI_CRCPolynomial：这是 SPI 的 CRC 校验中的多项式，若我们使用 CRC 校验时，就使用这个成员的参数（多项式）来计算 CRC 的值。由于本实验的 Flash 不支持 CRC校验，所以我们向这个结构体成员赋值为 7 实际上是没有意义的。\n\n配置完这些结构体成员后，我们要调用 SPI_Init() 函数把这些参数写入寄存器中，实现SPI 的初始化，然后调用 SPI_Cmd() 来使能 SPI1。", "link": "http://blog.csdn.net/wqx521/article/details/51035372", "publishDate": "2016-04-19 18:27", "title": "\r\n        STM32——SPI接口            \r\n        "}
{"readCount": "113", "article": "什么是原型模式？ \n\n Prototype模式是一种对象创建型模式，它采取复制原型对象的方法来创建对象的实例。使用Prototype模式创建的实例，具有与原型一样的数据。 原型模式的特点 \n\n <1> 由原型对象自身创建目标对象。也就是说，对象创建这一动作发自原型对象本身。 \n\n <2> 目标对象是原型对象的一个克隆。也就是说，通过Prototype模式创建的对象，不仅仅与原型对象具有相同的结构，还与原型对象具有相同的值。 \n\n <3> 根据对象克隆深度层次的不同，有浅度克隆与深度克隆。 原型模式的应用场景 \n\n <1> 在创建对象的时候，我们不只是希望被创建的对象继承其基类的基本结构，还希望继承原型对象的数据。 \n\n <2> 希望对目标对象的修改不影响既有的原型对象（深度克隆的时候可以完全互不影响）。 \n\n <3> 隐藏克隆操作的细节。很多时候，对对象本身的克隆需要涉及到类本身的数据细节。\n\n可以发现p2与p1相比，只有name不同，所以，我们不需要自己new一个p2，只需要从p1中克隆即可。\n\n注意：Person p2 = p1.clone();和Person p2 = p1;这两句是截然不同的。\n\n下面我们看一下浅克隆和深克隆，和C++中的深拷贝和浅拷贝类似。\n\n就是，如果Person对象中有引用类型的成员，克隆给p2的时候，会不会也另外单独开辟引用类型指向的内存块？我们看一下：\n\n可见，在克隆对象的时候，引用类型的成员变量，只是将值简单的拷贝过去，而没有开辟另外的内存可见，这样导致的潜在问题就是当释放其中一个对象释放掉该内存空间的时候，如果另一个对象再访问该成员变量指向的内存空间的是时候就会报错。这就是浅度克隆，只是简单的复制数据值。\n\n这样的话，原对象和克隆对象中的引用类型的成员变量就各自指向单独的内存空间，而不会相互影响。 \n\n", "link": "http://blog.csdn.net/birdflyto206/article/details/51192891", "publishDate": "2016-04-19 18:24", "title": "\r\n        设计模式(5)之原型模式            \r\n        "}
{"readCount": "149", "article": "前面已学习了两种自定义控件的实现，分别是自定义控件之对现有控件拓展（一）和 自定义控件之直接继承View创建全新视图（二）,还没学习的同学可以学习下，学习了的同学也要去温习下，一定要自己完全的掌握了，再继续学习，贪多嚼不烂可不是好的学习方法，我们争取学习了一种技术就会一种技术，而且不光看了就算了，最好的方法就是看完我自己再练习下，再扩展下，在原来的基础上在添加一些东西，比如，增加一些功能实现等等。\n\n今天我们打算学习下另外一种自定义控件，就是创建可重复使用的组合控件，那么问题来了： \n\n - 什么是可重复使用？ \n\n 就是在应用中，可以在多个地方共同使用一套代码。这样不仅能减少我们的工作量，而且还能保持应用风格的一致，这种应用最多最直接的体现就是统一风格样式的标题栏。 \n\n - 那什么又是组合控件呢？ \n\n 组合控件，顾名思义就是多个控件组合在一起，相互协作共同完成某些特定的功能。\n\n下面我们就针对app应用中风格统一的标题栏来开始我们的学习。\n\n首先，既然是一组组合的控件，那就必须有一个可以来包含这些控件的容器，我们所接触的可以存放控件的容器很多，比如LinearLayout、RelativeLayout等等多种Layout，今天我们就选择RelativeLayout来做我们的容器。和以前一样，我们先定义一个CompositeViews类来继承RelativeLayout类，并重写它的构造方法，代码如下：\n\n接下来，我们再定义三个TextView控件，分别是mLefeText，mRightText，textTitle用来显示“返回”，“搜索”以及“标题”并且使用LayoutParams规定它们在容器里面的对齐方式。请看代码：\n\ninitView(context)方法中是用来初始化三个组合控件的，请看：\n\nok，以上的代码已经实现了组合控件的显示和对齐方式，我们把定义的View添加到布局文件中并在Activity加载吧\n\nok，已显示出来了，但是相信大家也看出来了，这上面的代码中，各个控件中的属性是都是我们固定写死的，既然我们是创建可服用的控件，固定写死的东西肯定是不可取的，那么我们怎么可以灵活地获取控件的属性，以至于能达到复用呢？\n\n这就必须要接触另外一种技术了，就是自定义属性。用我们自定义的属于可以在每次使用我们定义的控件时为其分配属性即可。下面我们来学习下自定义属性。\n\n自定义属性其实也是相当的简单，首先，我们现在资源文件res下values目录下新建一个attrs.xml文件（eclipse自带，as自建），新建的attrs.xml是一个包含如下代码的文件：\n\n在resources中有各种属性供我们使用，同学们可以自己看下。根据我们现在的需求，我们选择使用declare-styleable来声明我们的属性集，然后为其定义特有的name属性，这个name是供我们在使用自定义属性时，通过它可以查找到里面的所有属性。请看如下代码：\n\n单独拿一行属性来解析下它所代表的含义：如 ：attr代表的是一个属性，它里面所包含name字段是这条属性名，通过该属性名可以获取以format的约束为真的属性值；formate是该属性的格式，分别包含string，dimension，color，reference等等，分别代表字符串，大小，颜色，引用。其他的大家可以自行学习resources所包含的属性。\n\n好了，自定义属性我们已学习完毕，那么该怎么使用我们自己定义的属性呢？其实也很简单，在我们的activity_main.xml文件中直接使用我们定义的属性就可以了，但是在使用是之前必须在指定引用第三方控件的命名空间，在跟布局文件中添加如下一行代码：\n\ncustom是我们第三方命名空间的名字，可以任意命名，我们在使用自定义属性时必须以它开头。请看代码：\n\n我们是使用custom加上我们自定义属性里面< attr name=”titleText” format=”string”/>里的name值来动态设置属性值的，如：custom:titleText=”@string/titleText”。\n\nok，在我们xml文件中已设定好属性值，那么该怎么显示出来呢？这个是需要通过一个类型组TypedArray来获取的，它里面包含各种从AttributeSet属性集中获取属性的方法，所以我们修改上面的构造方法和initView(context)方法，如下所示：\n\n代码解释：首先通过上下文context获取到属性存放到TypedArray 中，然后通过TypedArray 里封装好的各种方法获取对应的属性值，然后再分别为我们的控件设置属性。这样就完成了，自定义属性的使用，并且复用度高，每当需要使用标题栏是都只需要在xml中添加我们定义的View控件，为其配置属性即可使用，节约了开发时间，提高了效率，并且还保持的app风格的一致。\n\n好，到这里感觉已经讲完了整个过程吧，其实还有一个重要的实现还没有讲。我们的控件已经可以呈现出来了，但是怎么完成里面控件的作用呢？\n\n这里比较常见的做法是利用回调机制来实现功能的开发，首先我们先定义一个接口，创建两个方法，用于左右控件的点击事件。\n\n然后在构造方法中为左右控件添加点击事件，但不实现功能，等待调用者自己实现：\n\n再者，把定义好的接口暴露给调用者：\n\n最后，谁调用，谁实现。这就完成了不同界面复用控件实现不同的功能的便利。在这里我们只在MainActivity中打印Toast就可以了。\n\n好，已经可以实现我们的需求了，是不是学会很多呢。\n\n今天主要讲了android自定义View中另一种的实现，并且还学习了自定义属性，同学们下去好好消化下，并自己动手现实一两个例子吧，好了，今天就讲到这里，谢谢大家。", "link": "http://blog.csdn.net/guiman/article/details/51191739", "publishDate": "2016-04-19 18:17", "title": "\r\n        自定义控件之创建可以复用的组合控件（三）            \r\n        "}
{"readCount": "409", "article": "写博客就像讲故事，得有起因，经过，结果，人物，地点和时间。今天就容我给大家讲一个故事。人物呢，肯定是我了。故事则发生在最近的这两天,地点在coder君上班的公司。那天无意中我发现了一个奇怪的现象，随着我点开我们App的页面，Memory Monitor中显示占用的内存越来越多（前面的页面已经finish掉了）。咦？什么鬼？\n\n有了问题就解决嘛，俗话说的好，有bug要上，没有bug写个bug也要上。那到底是是什么问题会引起这个现象呢？\n\n阿西吧，仔细想想怎么这么像内存泄漏呢。那到底是不是呢？那我们就一点一点分析一下呗。\n\n每一个Android设备都会有不同的RAM总大小与可用空间，因此不同设备为app提供了不同大小的heap限制。你可以通过调用getMemoryClass())来获取你的app的可用heap大小。如果你的app尝试申请更多的内存，会出现OutOfMemory的错误。 在一些特殊的情景下，你可以通过在manifest的application标签下添加largeHeap=true的属性来声明一个更大的heap空间。如果你这样做，你可以通过getLargeMemoryClass())来获取到一个更大的heap size。 然而，能够获取更大heap的设计本意是为了一小部分会消耗大量RAM的应用(例如一个大图片的编辑应用)。不要轻易的因为你需要使用大量的内存而去请求一个大的heap size。只有当你清楚的知道哪里会使用大量的内存并且为什么这些内存必须被保留时才去使用large heap. 因此请尽量少使用large heap。使用额外的内存会影响系统整体的用户体验，并且会使得GC的每次运行时间更长。在任务切换时，系统的性能会变得大打折扣。 另外, large heap并不一定能够获取到更大的heap。在某些有严格限制的机器上，large heap的大小和通常的heap size是一样的。因此即使你申请了large heap，你还是应该通过执行getMemoryClass()来检查实际获取到的heap大小。 private String getAllocationMemory() { // 获取系统分配的内存大小 ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE); //开启了android:largeHeap=\"true\",米4系统能分配的内存为512M，不开启为128M //return am.getLargeMemoryClass()+\"\"; //return am.getMemoryClass()+\"\"; }\n\n开始分析之前，有必要先了解下Java的内存分配与回收。\n\n基本数据类型的值存储在栈内存中，而引用数据类型需要开辟两块存储空间，一块在堆内存中，用于存储该类型的对象;另一块在栈内存中，用于存储堆内存中该对象的引用。\n\nAndroid系统会在适当的时机触发GC操作，一旦进行GC操作，就会将一些不再使用的对象进行回收。\n\n通常来说，单个的GC并不会占用太多时间，但是大量不停的GC操作则会显著占用帧间隔时间(16ms)。如果在帧间隔时间里面做了过多的GC操作，那么自然其他类似计算，渲染等操作的可用时间就变得少了\n\n内存泄漏表示的是不再用到的对象因为被错误引用而无法进行回收。发生内存泄漏会导致Memory Generation中的剩余可用Heap Size越来越小，这样会导致频繁触发GC，更进一步引起性能问题。\n\n想要更加清楚地实时知晓当前应用程序的内存使用情况，我们需要通过一些工具来实现。比较好用的工具有两种：\n\nMemory Analysis Tools（点我下载）是一个专门分析Java堆数据内存引用的工具，我们可以使用它方便的定位内存泄露原因，核心任务就是找到GC ROOT位置。接下来说下使用步骤。\n\nAndriodStudio中抓取内存信息还是很方便的，有两种方法：\n\n这里我写了个简单的demo来测试，这个demo一共有两个页面，在跳转到第二个页面之后，新开一个现成去打印activity信息。\n\n在MAT中打开抓取到的文件后如图\n\nMAT中提供了非常多的功能，这里我们只要学习几个最常用的就可以了。上图最中央的那个饼状图展示了最大的几个对象所占内存的比例，这张图中提供的内容并不多，我们可以忽略它。红色框中有两个非常有用的工具是我们常用的。\n\n我们应该如何去分析内存泄漏呢?即分析大内存的对象。但是假如我们有目标对象的话，左上角值支持正则表达式的，我们输入SecondActivity。这里我们看到，我们有5个SecondActivity的实例，因为我们引用SecondActivity的现成没有销毁，导致会有很多实例。\n\n此外，我们可以选择以我们项目的包结构的形式来查看\n\n现在我们可以对着我们想查看的内容点击右键 -> Path to GC Roots -> exclude weak references，为什么选择exclude weak references呢？因为弱引用是不会阻止对象被垃圾回收器回收的，所以我们这里直接把它排除掉，然后一步一步分析。\n\nleakcanary是一个开源项目，一个内存泄露自动检测工具，是著名的GitHub开源组织Square贡献的，它的主要优势就在于自动化过早的发觉内存泄露、配置简单、抓取贴心，缺点在于还存在一些bug，不过正常使用百分之九十情况是OK的，其核心原理与MAT工具类似。\n\n真相只有一个，那就是确实是由于内存泄漏才出现我遇到的情况。程序员嘛，谁还不踩个坑，跳出来，拍拍身上的灰尘，总结一下，过两天又是一条帮帮的coder。源码", "link": "http://blog.csdn.net/sdkfjksf/article/details/51192852", "publishDate": "2016-04-19 18:16", "title": "\r\n        Android性能优化之被忽视的Memory Leaks            \r\n        "}
{"readCount": "194", "article": "", "link": "http://blog.csdn.net/lpjishu/article/details/51192837", "publishDate": "2016-04-19 18:13", "title": "\r\n        leetCode(66)-Excel Sheet Column Title            \r\n        "}
{"readCount": "33181", "article": "为了呈现给用户更优质的内容，博客首页最新文章规则变更，现已取消发布博客时@博乐。博客系统将对文章进行打分和相应的判断，然后推至首页。\n\n首页文章都是对用户有帮助的原创和翻译文章，博客运营人员也会对首页文章进行监控，同时也欢迎大家的监督及举报。\n\n各位用户如对CSDN博客频道有任何意见、建议，欢迎发送邮件至webmaster(at)csdn.net反馈，或加入CSDN博客群（QQ群：374041348）进行反馈。感谢大家对CSDN博客的支持！", "link": "http://blog.csdn.net/csdnproduct/article/details/50999580", "publishDate": "2016-03-28 17:25", "title": "\r\n        博客首页规则改版公告            \r\n        "}
{"readCount": "58213", "article": "有很多朋友在遇到一些好博客文章的时候，都想把它们下载到电脑上，转换成某些格式的文档，以方便存储、阅读。", "link": "http://blog.csdn.net/blogdevteam/article/details/27084771", "publishDate": "2014-05-26 15:26", "title": "\r\n        博客导出工具            \r\n        "}
{"readCount": "8210", "article": "我们在下图中可以看到main函数中将changestack()的返回值给num赋值的具体过程，也就是将eax的值返回给num的所在的内存地址。 ——————————图五 函数返回值的“弹栈”细则——————————-\n\n我们分析上边代码的运行过程，首先在main函数中调用Add_Recursion(1,1),本意就是计算1+1的值，并且将函数返回值传递给printf打印出来。 在递归调用Add_Recursion函数(简称add)计算1+1时，前两次递归调用由于不满足递归出口条件（进位加数carry_num为0），会跳入else分支进行递归调用。直到第三次递归调用时由于carry_num为0，这时返回了累加结果。\n\n我们在递归函数Add_Recursion的后边加了一条汇编代码，让函数结束时改变eax的值。可以看到，主函数中，将函数返回值误认为了我们在汇编语言中设定的3.打印出了1+1=3这种谬论。\n\n实际上，我们在编译例题中的程序在编译时C编译器会提出警告 \n\n warning C4715: “Add_Recursion”: 不是所有的控件路径都返回值 \n\n 有返回值的函数，不是所有的支路都会进行返回值，如果大家把博客中的程序在更加严格的C++编译器上编译会报错。\n\n这只是一个很简单的案例，也许我们会运气好实现函数的功能，但是在进行复杂情况的树状甚至图状递归中，如果不确定自己是否一定能得到最终结果，请务必将每一种情况都return返回值，这样来避免程序意外出错。C语言的灵活性应该给我们造福，而不应该给我们的程序提供不稳定的因素。", "link": "http://blog.csdn.net/u013926582/article/details/51175645", "publishDate": "2016-04-17 21:34", "title": "\r\n        C语言中递归什么时候可以省略return引发的思考：通过内联汇编解读C语言函数return的本质            \r\n        "}
{"readCount": "4714", "article": "在Chromium中，Render进程在绘制网页之前，要为网页创建一个绘图表面。绘图表面描述的是网页经过渲染之后得到的输出。这个输出需要交给Browser进程处理，才能显示在屏幕上。在硬件加速渲染条件下，这个输出有可能是一个OpenGL纹理，也有可能是一系列需要进一步进行绘制的OpenGL纹理，取决于Render进程使用直接渲染器还是委托渲染器。本文接下来就对网页的绘图表面的创建过程进行详细分析。\n\n关于网页绘图表面的更详细描述，可以参考Chromium硬件加速渲染的OpenGL上下文绘图表面创建过程分析一文。本文的重点是分析Chromium的CC模块是如何触发网页绘图表面的创建的，以作为Chromium硬件加速渲染的OpenGL上下文绘图表面创建过程分析一文的补充。\n\n网页绘图表面是由CC模块的调度器触发创建的，如图1所示：\n\nCC模块内部的状态机一旦检测到网页的Layer Tree创建和初始化完毕，就会通知调度器触发一个创建绘图表面的操作。CC模块在为网页创建绘图表面的过程中，也有伴随着网页分块管理器、资源池和光栅化工作者线程池等基础设施的创建。一旦这些基础设施准备完毕，网页才能开始进行绘制，也就是在图1中，第1步完成后，第2到第6步才可以周而复始地执行。\n\n从前面Chromium网页Layer Tree创建过程分析一文可以知道，当网页的Graphics Layer Tree的根节点创建出来之后，WebKit就会通知Chromium的Content层初始化一个CC Layer Tree，如下所示：\n\n初始化CC Layer Tree的工作是通过调用RenderWidgetCompositor类的静态成员函数Create实现的。在前面Chromium网页Layer Tree创建过程分析一文中，我们分析了此时RenderWidget类的成员变量init_complete_的值等于true，因此接下来RenderWidget类的成员函数initializeLayerTreeView会调用另外一个成员函数StartCompositor为网页创建绘图表面。\n\nRenderWidget类的成员变量compositor_指向的是一个RenderWidgetCompositor对象，RenderWidget类的成员函数StartCompositor调用这个RenderWidgetCompositor对象的成员函数setSurfaceReady，用来通知它可以为网页创建绘图表面了。\n\nRenderWidgetCompositor类的成员变量layer_tree_host_指向的是一个LayerTreeHost对象。这个LayerTreeHost对象就是用来管理CC Layer Tree的。RenderWidgetCompositor类的成员函数setSurfaceReady调用这个LayerTreeHost对象的成员函数SetLayerTreeHostClientReady，用来通知调度器为网页创建绘图表面。\n\nLayerTreeHost类的成员变量proxy_指向的是一个ThreadedProxy对象，LayerTreeHost类的成员函数SetLayerTreeHostClientReady调用这个ThreadProxy对象的成员函数SetLayerTreeHostClientReady，用来调度器为网页创建绘图表面。\n\nThreadProxy类的成员函数SetLayerTreeHostClientReady向Compositor线程的消息队列发送一个Task。这个Task绑定了ThreadProxy类的成员函数SetLayerTreeHostClientReadyOnImplThread。因此接下来ThreadProxy类的成员函数SetLayerTreeHostClientReadyOnImplThread就会在Compositor线程中执行。\n\nThreadProxy类的成员函数SetLayerTreeHostClientReadyOnImplThread将调度器设置为启动状态，这是通过调用Scheduler类的成员函数SetCanStart实现的，如下所示：\n\nScheduler类的成员函数SetCanStart首先将内部的状态机设置为启动状态，这是通过调用SchedulerStateMachine类的成员函数SetCanStart实现的，如下所示：\n\nSchedulerStateMachine类的成员函数SetCanStart将成员变量can_start_的值设置为true，这样就会触发调度器为网页创建绘图表面。\n\n回到Scheduler类的成员函数SetCanStart中，它将内部的状态机设置为启动状态之后，接着调用另外一个成员函数ProcessScheduledActions检查下一个要执行的操作，这个操作即为创建绘图表面。\n\nScheduler类的成员函数ProcessScheduledAction的详细实现可以参考前面Chromium网页渲染调度器（Scheduler）实现分析一文，这里我们只关注它是如何触发网页绘图表面的创建的。\n\nScheduler类的成员函数ProcessScheduledAction首先调用SchedulerStateMachine类的成员函数NextAction询问状态机下一个应该执行的操作，后者的实现如下所示：\n\n在我们这个情景中，SchedulerStateMachine类的成员函数NextAction在调用到另外一个成员函数ShouldBeginOutputSurfaceCreation时得到的返回值为true，后者的实现如下所示：\n\n1. 网页的CC Layer Tree已经创建和初始化完成。这时候SchedulerStateMachine类的成员变量can_start_的值等于true。\n\n2. 状态机的CommitState状态等于COMMIT_STATE_IDLE。这意味着当前Main线程不是正在提交变化给Compositor线程渲染。\n\n3. 状态机的BeginImplFrameState状态等于BEGIN_IMPL_FRAME_STATE_IDLE。这意味着调度器已经向Compositor线程发出了一个渲染请求。\n\n4. Compositor线程的CC Pending Layer Tree已经激活为CC Active Layer Tree。这时候SchedulerStateMachine类的成员变量has_pending_tree_的值等于false。\n\n5. Compositor线程的CC Active Layer Tree被激活后，已经被执行过至少一次渲染操作了。这时候SchedulerStateMachine类的成员变量active_tree_needs_first_draw_的值等于false。\n\n从前面的分析可以知道，第1个条件是满足的。由于这时候状态机也是刚刚初始化完成，因此后面五个条件也得到满足的。因此SchedulerStateMachine类的成员函数ShouldBeginOutputSurfaceCreation会返回true值给调用者。\n\n同时，从SchedulerStateMachine类的成员函数ShouldBeginOutputSurfaceCreation的实现也可以看出，如果网页绘图表面在创建之后，由于其它原因失效了，那么要等到网页的渲染管线达到一个稳定状态之后，才可以重新创建。失效的原因可以参考Chromium网页渲染调度器（Scheduler）实现分析一文。稳定状态指的是Main线程已经将当前的网页变化提交给了Compositor线程，而Compositor线程也已经处理这些变化引起的渲染工作。总的来说，就是图1所示的第2到第6个操作均已经连贯执行完成。\n\n回到SchedulerStateMachine类的成员函数NextAction中，当调用另外一个成员函数ShouldBeginOutputSurfaceCreation得到的返回值等于true的时候，它会返回一个ACTION_BEGIN_OUTPUT_SURFACE_CREATION值给调用者，也就是调度器，表示现在需要为网页创建绘图表面。\n\n回到Scheduler类的成员函数ProcessScheduledActions中，它知道了下一个要执行的操作是ACTION_BEGIN_OUTPUT_SURFACE_CREATION之后，接下来会先调用SchedulerStateMachine类的成员函数UpdateState更新状态机的状态，如下所示：\n\n当调度器接下要执行的操作是ACTION_BEGIN_OUTPUT_SURFACE_CREATION时，SchedulerStateMachine类的成员函数UpdateState主要就是修改状态机的OutputSurfaceState状态，也就是将它的状态从OUTPUT_SURFACE_LOST迁移至OUTPUT_SURFACE_CREATING，表示正在为网页创建绘图表面。\n\n回到Scheduler类的成员函数ProcessScheduledActions中，它更新了状态机的OutputSurfaceState状态之后，接下来就会调用成员变量client_指向的一个ThreadProxy对象的成员函数ScheduledActionBeginOutputSurfaceCreation为网页创建绘图表面。\n\nThreadProxy类的成员函数ScheduledActionBeginOutputSurfaceCreation向Main线程的消息队列发送了一个Task，这个Task绑定了ThreadProxy类的成员函数CreateAndInitializeOutputSurface。因此，接下来ThreadProxy类的成员函数CreateAndInitializeOutputSurface就会在Main线程中执行。\n\nThreadProxy类的成员函数CreateAndInitializeOutputSurface首先调用另外一个成员函数layer_tree_host获得一个LayerTreeHost对象。然后再调用这个LayerTreeHost对象的成员函数CreateOutputSurface为网页创建绘图表面。\n\nThreadProxy类的成员函数CreateAndInitializeOutputSurface接下来又向Compositor线程的消息队列发送一个Task。这个Task绑定的函数是ThreadProxy类的成员函数InitializeOutputSurfaceOnImplThread，用来在Compositor线程中初始化前面创建好的绘图表面。\n\n接下来我们先分析LayerTreeHost类的成员函数CreateOutputSurface的实现，接着再分析ThreadProxy类的成员函数InitializeOutputSurfaceOnImplThread的实现。\n\n从前面Chromium网页Layer Tree创建过程分析一文可以知道，LayerTreeHost类的成员变量client_指向的是一个RenderWidgetCompositor对象。LayerTreeHost类的成员函数CreateOutputSurface调用这个RenderWidgetCompositor对象的成员函数CreateOutputSurface为网页创建绘图表面。\n\n从前面Chromium网页Layer Tree创建过程分析一文可以知道，RenderWidgetCompositor类的成员变量widget_指向的是一个RenderViewImpl对象。RenderWidgetCompositor类的成员函数CreateOutputSurface调用这个RenderViewImpl对象的成员函数CreateOutputSurface为网页创建绘图表面。\n\nRenderViewImpl类的成员函数CreateOutputSurface是从父类RenderWidget继承下来的。RenderWidget类的成员函数CreateOutputSurface为网页创建绘图表面的过程可以参考前面Chromium的GPU进程启动过程分析一文。这个过程实际上就是Render进程请求与GPU进程建立GPU通道的过程。GPU通道建立起来之后，Render进程就可以发送GPU命令给GPU进程执行了。注意，在Render进程中加载的每一个网页都会与GPU进程建立一个GPU通道，并且每一个GPU通道在GPU进程又对应有一个OpenGL上下文。我们也可以认为Render进程的一个绘图表面对应于GPU进程中的一个OpenGL上下文。\n\n假设网页A与GPU进程建立的GPU通道为G1，并且GPU通道为G1在GPU进程中对应的OpenGL上下文C1。当Render进程要渲染网页A的UI时，它就会通过GPU通道G1向GPU进程发送相应的GPU命令。GPU进程接收到这些GPU命令之后，就会激活OpenGL上下文C1，然后执行接收到的GPU命令。通过这种方式，GPU进程就可以同时接收不同网页的渲染命令，并且它们不会互相干扰，因为不同网页的渲染命令都是在各自的OpenGL上下文中执行的。这些都是Chromium硬件加速渲染机制相关的知识，可以参考前面Chromium硬件加速渲染机制基础知识简要介绍和学习计划这个系列的文章。\n\n回到ThreadProxy类的成员函数CreateAndInitializeOutputSurface中，它调用LayerTreeHost类的成员函数CreateOutputSurface为网页创建了一个绘图表面之后，接下来会请求Compositor线程初始化这个绘图表面。这是通过在Compositor线程中调用ThreadProxy类的成员函数InitializeOutputSurfaceOnImplThread实现的。\n\nThreadProxy类的成员函数InitializeOutputSurfaceOnImplThread首先获得一个LayerTreeHostImpl对象，接着调用这个LayerTreeHostImpl对象的成员函数InitializeRenderer初始化参数output_surface描述的绘图表面。从前面Chromium的GPU进程启动过程分析一文可以知道，参数output_surface指向的实际上是一个CompositorOutputSurface对象。也就是说，网页的绘图表面是通过一个CompositorOutputSurface对象来描述的。\n\n初始化完成后，ThreadProxy类的成员函数InitializeOutputSurfaceOnImplThread会调用Scheduler类的成员函数DidCreateAndInitializeOutputSurface通知调度器，它之前调度执行的ACTION_BEGIN_OUTPUT_SURFACE_CREATION操作已经执行完成。这时候调度器就会修改状态机的OutputSurfaceState状态。\n\n接下来我们先分析LayerTreeHostImpl类的成员函数InitializeRenderer的实现，接下来再分析Scheduler类的成员函数DidCreateAndInitializeOutputSurface的实现。\n\nLayerTreeHostImpl类的成员函数InitializeRenderer首先调用参数output_surface指向的一个CompositorOutputSurface对象的成员函数BindToClient，让这个CompositorOutputSurface对象为它所描述的绘图表面在GPU进程中创建一个OpenGL上下文，如下所示：\n\nCompositorOutputSurface类的成员函数BindToClient调用父类OutputSurface的成员函数BindToClient来为当前正在处理的绘图表面在GPU进程中创建一个OpenGL上下文，如下所示：\n\n从前面的调用过程可以知道，参数client指向的是一个LayerTreeHostImpl对象。OutputSurface类的成员函数BindToClient将这个LayerTreeHostImpl对象保存在成员变量client_中。\n\nOutputSurface类的成员函数BindToClient接下来调用成员变量context_provider_指向的一个ContextProviderCommandBuffer对象的成员函数BindToCurrentThread为当前正在处理的绘图表面在GPU进程中创建一个OpenGL上下文。这个ContextProviderCommandBuffer对象的创建过程可以参考前面Chromium的GPU进程启动过程分析一文。\n\nContextProviderCommandBuffer类的成员变量context3d_指向的是一个WebGraphicsContext3DCommandBufferImpl对象。这个WebGraphicsContext3DCommandBufferImpl对象的创建过程可以参考前面Chromium的GPU进程启动过程分析一文。\n\nContextProviderCommandBuffer类的成员函数BindToCurrentThread调用成员变量context3d_指向的WebGraphicsContext3DCommandBufferImpl对象的成员函数makeContextCurrent在GPU进程中创建一个OpenGL上下文。这个OpenGL上下文与前面创建的绘图表面相对应。\n\nWebGraphicsContext3DCommandBufferImpl类的成员函数makeContextCurrent请求GPU进程创建OpenGL上下文的过程可以参考前面Chromium硬件加速渲染的OpenGL上下文创建过程分析一文。\n\n回到OutputSurface类的成员函数BindToClient中，它为当前正在处理的绘图表面在GPU进程中创建了一个OpenGL上下文之后，接下来会调用另外一个成员函数SetUpContext3d设置一些GPU进程回调通知，如下所示：\n\nOutputSurface类的成员函数SetUpContext3d设置了三个GPU进程回调通知：Lost Context Callback、Swap Buffers Complete Callback、Memory Policy Changed Callback，分别是GPU通道失效通知、网页UI渲染完成通知和内存策略变化通知。当这三个回调通知发生时，OutputSurface类的成员函数DidLoseOutputSurface、OnSwapBuffersComplete和SetMemoryPolicy就会被调用。其中，OutputSurface类的成员函数DidLoseOutputSurface会通知调度器将状态机的OutputSurfaceState状态修改为OUTPUT_SURFACE_LOST，这样调度器以后就重新为网页创建一个绘图表面；OutputSurface类的成员函数OnSwapBuffersComplete会通知调度器前面向GPU进程发出的一个SwapBuffers操作已经完成，也就是网页的UI已经被Browser进程合成完毕。\n\n回到LayerTreeHostImpl类的成员函数InitializeRenderer中，它为参数output_surface描述的绘图表面在GPU进程中创建了一个OpenGL上下文之后，接下来会将这个参数指向的CompositorOutputSurface对象保存在成员变量output_surface_中，并且还会调用ResourceProvider类的静态成员函数Create创建一个ResourceProvider对象，保存在另外一个成员变量resource_provider_中。这个ResourceProvider对象在后面的网页渲染过程中，用来创建各种GPU资源。我们在后面的文章中就会看到这一点。\n\nLayerTreeHostImpl类的成员函数InitializeRenderer接下来调用另外一个成员函数CreateAndSetRenderer为网页创建渲染器。创建出来的渲染器决定了网页的UI以什么样的方式合成到浏览器窗口中。\n\n从前面Chromium硬件加速渲染的UI合成过程分析一文可以知道，当Render进程的启动参数设置了“enable-delegated-renderer”选项时，Render进程使用委托渲染器。这个委托渲染器可以通过调用DelegatingRenderer类的静态成员函数Create创建。所谓委托渲染器，就是它委托Browser进程渲染和合成网页的UI。具体来说，就是Compositor线程在渲染网页时，它并没有真的执行渲染操作，而是计算出一系列的Render Pass，然后传递给Browser进程的的渲染器直接合成在浏览器窗口中。Render Pass描述的是网页当前可见的一个分块，它本质上是一个纹理，并且指定了纹理坐标，以及纹理的其它渲染参数，Browser进程根据这些信息就可以将网页的UI渲染出来。与非委托渲染器相比，委托渲染器可以减少一次渲染操作。非委托渲染器的Compositor线程在渲染网页时，会将网页当前可见的分块全部渲染一个纹理上，然后再将这个纹理传递给Browser进程。Browser进程拿到这个纹理后，还要再执行一次渲染操作，也就是合成在浏览窗口上，网页的UI才能显示出来。这过程包含了两次渲染操作，一次发生Render进程，另一次发生在Browser进程。因此非委托渲染器比委托渲染器多执行了一次渲染操作。\n\n如果Render进程的启动参数没有设置“enable-delegated-renderer”选项，但是设置了使用硬件方式渲染网页的UI，那么Render进程就会使用非委托渲染器。这个非委托渲染器可以通过调用GLRenderer类的静态成员函数Create创建。注意，Browser进程也是通过CC模块来渲染浏览器窗口的，也就是它也像Render进程一样，将浏览器窗口抽象成CC Layer Tree、CC Pending Layer Tree和CC Active Layer Tree，这时候网页的UI就是其中的一个Layer。由于Browser进程不能再委托别人渲染自己的UI，因此在采用硬件方式渲染浏览器窗口的情况下，它就只能使用非委托渲染器来渲染浏览器窗口UI。\n\n如果Render进程使用软件方式渲染网页的UI，那么它使用的渲染器通过调用SoftwareRenderer类的静态成员函数Create创建。一般来说，在获取网页的截图时，才会使用软件方式渲染网页的UI。\n\n更多关于委托渲染器和非委托渲染器的知识，可以参考Chromium硬件加速渲染的UI合成过程分析一文。\n\n再回到LayerTreeHostImpl类的成员函数InitializeRenderer中，它为网页创建了渲染器之后，接下来判断网页是否使用线程化渲染方式。如果是的话，LayerTreeHostImpl类的成员变量setting_描述的一个LayerTreeSettings对象的成员变量impl_side_painting的值就会等于ture。这时候LayerTreeHostImpl类的成员函数InitializeRenderer就会调用另外一个成员函数CreateAndSetTileManager创建一个分块管理器（Tile Manager）。这是由于线程化渲染方式中，Main线程只是记录了每一个网页分块的绘制命令。在这种情况下，Compositor线程在渲染网页的UI之前，要先通过分块管理器执行每一个分块的绘制命令，以便得到一个图像。这个过程也就是光栅化过程。在非线程化渲染方式中，Main线程直接就将分块光栅化在一个图像中了，也就是它已经做了光栅化的操作了。\n\n我们假设网页使用的是线程化渲染方式，因此接下来我们继续分析LayerTreeHostImpl类的成员函数CreateAndSetTileManager的实现，如下所示：\n\n创建分块管理器一个Resource Pool和Raster Worker Pool。分块管理器的职责是光栅化分块，不同的光栅化方式需要不同类型的Resource Pool和Raster Worker Pool。\n\nCC模块提供了四种光栅化方式。第一种是使用GPU执行光栅化操作，后面三种使用CPU执行光栅化操作。注意，在硬件方式渲染网页UI的情况下，经过CPU光栅化后的分块仍然是通过GPU进行渲染的。\n\n当Render进程设置了\"force-gpu-rasterization\"和\"enable-impl-side-painting\"启动选项时，LayerTreeHostImpl类的成员变量use_gpu_rasterization_的值就会等于true，表示要使用GPU光栅化网页分块。但是只有在网页使用硬件方式渲染时，才会真的使用GPU光栅化网页分块。这是因为使用GPU光栅化分块时，分块就直接光栅化在一个纹理中。这个纹理可以被GPU继续渲染出来形成网页的UI。因此，只有在使用硬件方式渲染网页的情况下，使用GPU光栅化分块才有意义。否则的话，光栅化后的分块内容还需要从GPU读取出来再交CPU渲染。这样效率将会极其低下。\n\nLayerTreeHostImpl类的成员变量output_surface_描述的是网页的绘图表面。从前面的分析可以知道，这个绘图表面是通过一个CompositorOutputSurface对象描述的，也就是LayerTreeHostImpl类的成员变量output_surface_指向的是一个CompositorOutputSurface对象。当调用这个CompositorOutputSurface对象的成员函数context_provider获得一个不为NULL的ContextProvider对象时，就说明网页使用硬件方式渲染UI。\n\nGPU将分块光栅化在一个类型为GL_TEXTURE_2D的纹理上，因此这时候分块管理器需要一个类型为GL_TEXTURE_2D的Resource Pool，也就是一个能够创建类型为GL_TEXTURE_2D的纹理的Resource Pool。与此同时，分块管理器通过一个名称为”Direct“的Raster Worker Pool执行GPU光栅化操作。这个Raster Worker Pool可以通过调用DirectRasterWorkerPool类的静态成员函数Create创建。“Direct”的意思就是直接将分块光栅化在GPU里面，以后可以继续通过GPU进行渲染。\n\n当Render进程设置了“enable-zero-copy”启动选项，并且平台支持GPU和CPU共享内存时，调用LayerTreeHostImpl类的成员函数UseZeroCopyTextureUpload得到的返回值就等于true，这时候将会使用CPU光栅化网页分块。在这种情况下，CPU将分块光栅化一块GPU和CPU都能访问的内存上，这样就可以避免在光栅化操作完成后，将分块内容从CPU拷贝到GPU的过程。因此，这种光栅化方式称为\"Zero Copy\"光栅化。GPU和CPU都能访问的内存是一种特殊的内存。在Android平台上，这种内存称为Graphics Buffer。CPU光栅化完成后，GPU可以将这个Graphics Buffer当作一个类型为GL_TEXTURE_EXTERNAL_OES的纹理访问。因此，这时候分块管理器需要一个类型为GL_TEXTURE_EXTERNAL_OES的Resource Pool，也就是一个能够创建类型为GL_TEXTURE_EXTERNAL_OES的纹理的Resource Pool。与此同时，分块管理器通过一个名称为”Image“的Raster Worker Pool执行CPU光栅化操作。这个Raster Worker Pool可以通过调用ImageRasterWorkerPool类的静态成员函数Create创建。\n\n当Render进程设置了“enable-one-copy”启动选项，并且平台支持GPU和CPU共享内存时，调用LayerTreeHostImpl类的成员函数UseZeroCopyTextureUpload得到的返回值就等于true，这时候也会使用CPU光栅化网页分块。不过在这种情况下，CPU只是将分块光栅化一块临时的GPU和CPU都能访问的内存上，然后再将这个内存拷贝在一个类型为GL_TEXTURE_2D的纹理上。由于需要执行一次拷贝操作，因此这种光栅化方式称为”One Copy“光栅化。不过，这个拷贝是直接在GPU内完成的，并没有涉及到从CPU读取数据到GPU或者从GPU读取数据到CPU的操作，因此效率不是问题。这时候分块管理器需要两个Resource Pool，一个类型为GL_TEXTURE_EXTERNAL_OES，另一个类型为GL_TEXTURE_2D。其中，前者用来创建临时的GPU和CPU都能访问的内存，后者用来创建类型为GL_TEXTURE_2D的纹理。与此同时，分块管理器通过一个名称为”Image Copy“的Raster Worker Pool执行CPU光栅化操作。这个Raster Worker Pool可以通过调用ImageCopyRasterWorkerPool类的静态成员函数Create创建。\n\n在其余情况下，分块管理器将使用CPU光栅化网页分块，并且是将分块光栅化在一个Pixel Buffer Object（PBO）中。这些PBO最后需要从CPU上传到GPU中，才能被GPU当作纹理访问。在这种情况下，分块管理器需要一个类型为GL_TEXTURE_2D的Resource Pool，用来创建类型为GL_TEXTURE_2D的纹理保存分块光栅化后得到的内容。与此同时，分块管理器通过一个名称为”Pixel Buffer“的Raster Worker Pool执行CPU光栅化操作。这个Raster Worker Pool可以通过调用PixelBufferRasterWorkerPool类的静态成员函数Create创建。\n\n我们注意到，LayerTreeHostImpl类的有一个成员变量on_demand_task_graph_runner_，它指向的是一个TaskGraphRunner对象。这个TaskGraphRunner对象也是用来执行光栅化任务的，不过它只用在非委托渲染器中。在非委托渲染方式中，有时候会因为内存限制，使得不能够为所有的网页分块都分配一块独立的内存执行光栅化操作。这时候非委托渲染器会使用一块共用的内存来光栅化那些没有独立内存的分块。这些分块光栅化完成后就会马上渲染，以便将共用的内存释放出来给其它分块使用。因此，对于这些没有独立内存的分块，它们的光栅化过程是比较特殊的，需要通过LayerTreeHostImpl类的成员变量on_demand_task_graph_runner_描述的TaskGraphRunner对象进行。\n\n关于网页分块的光栅化过程，我们在后面的文章中再进行详细分析。\n\n这一步执行完成之后，网页的绘图表面就初始化完成了。回到ThreadProxy类的成员函数InitializeOutputSurfaceOnImplThread中，它接下来就会调用Scheduler类的成员函数DidCreateAndInitializeOutputSurface通知调度器修改状态机的OutputSurfaceState状态，如下所示：\n\nScheduler类的成员函数DidCreateAndInitializeOutputSurface调用SchedulerStateMachine类的成员函数DidCreateAndInitializeOutputSurface将状态机的OutputSurfaceState状态修改为OUTPUT_SURFACE_WAITING_FOR_FIRST_COMMIT，如下所示：\n\n当状态机的OutputSurfaceState状态为OUTPUT_SURFACE_WAITING_FOR_FIRST_COMMIT时，将会触发调度器尽快执行一个ACTION_SEND_BEGIN_MAIN_FRAME，也就是图1所示的第2个操作。这个操作将会请求Main线程绘制CC Layer Tree的内容。CC Layer Tree的内容绘制好之后，将会被同步到CC Pending Layer Tree中去执行光栅化操作，然后激活为CC Active Layer Tree。这个CC Active Layer Tree经过Compositor渲染后就得到网页的UI。\n\n至此，我们就分析完成网页的绘图表面创建和初始化过程了。有了绘图表面之后，接下来就可以绘制和渲染网页的内容了。在接下来的一篇文章中，我们就继续分析网页的绘制过程，也就是Main线程绘制CC Layer Tree的过程，敬请关注！更多的信息也可以关注老罗的新浪微博：http://weibo.com/shengyangluo。\n\n\n\n", "link": "http://blog.csdn.net/luoshengyang/article/details/50995124", "publishDate": "2016-04-18 01:00", "title": "\r\n        Chromium网页绘图表面（Output Surface）创建过程分析            \r\n        "}
{"readCount": "4523", "article": "在互联网行业中，采用的技术、概念也较传统形行业来说要新，技术人员也容易在此找到自己的一方净土。\n\n因为互联网这个行当讲究的快速变更、快速适应，如果你什么都不更新你就会落后，而且互联网行当最重要的一点是你的客户相对来说比较客观。\n\n没有传统形乙方公司那种“人为的因素存在”。同时互联网行当本身的管理也是扁平化管理。\n\n马化腾曾说过扁平化管理，对于100个人的团队，他会亲自去一一沟通而不是以“金字塔”式的结构压下去。因为，如果人人都坐在那里想当官，试问谁来干事啊？\n\n而且2014年，软件定义一切被提出，软件定义一切囊括了在基础设施可编程性标准提升下不断增长的市场势头、由云计算内在自动化驱动的数据中心互通性、DevOps和快速的基础设施提供等。软件定义一切还包括举措，如OpenStck、OpenFlow、the Open Compute Project和Open Rack，共享相同的愿景。开放性将成为供应商的目标，SDN(网络)、SDDC(数据中心)、SDS(存储)和SDI(基础架构)，甚至SDW（软件定义世界）。\n\n软件定义一切对一个IT人员来说，其实不是什么新鲜的事情，在最早读程序员（有这门考试，90年代中后期），听着施伯乐在那边淘淘不绝的说着在银行一个IT人员一直成长，成长，直到可以作为副总，当时在座的同学们那是个个双眼放光哈。因为IT人员掌握了核心的数据、核心的信息，因此他知道的最多。\n\n在互联网公司，一个开发人员，不仅仅只是一个开发，如果你只是一个开发，那么你的前途堪忧。在互联网世界中作为一名IT人员，你应该俱有这样的品质：\n\nDocker、VM、PAAS、SAAS被普遍应用和提出，Redis，RabbitMQ，WS，JSON，RMI，HTTP，以及大数据等互相参杂，互联网的世界已经没有单一的“技能”可言，如果你还是死抱SSH， SSM。。。。。。那你的水平可能在互联网行当只等于“0”，相当于“白痴”，即IDIOT,不错，缩写也是IT。：）\n\n你有没有见过一个用单一语言写出的成功的网站？没有？如果有，那么这个网站也死了快了。\n\n如果列举公司名字，那要列很长一串，而且各家看法各不相同，我们只说几个点，对于我们的IT从业人员的择业来说有帮助的点。\n\n在互联网行当，到处充满了“创业”这个词，那么很多人也问过我，创业形公司可以去吗？\n\n去啊，为什么不能去，但是去前你要了解清楚它是一个什么样的公司？\n\n这里我们就要谈到一个IDEA，即创业时的点子或者我们也可以称之为“盈利模式”。\n\n拿创业公司来说它一般会经历这样几轮：天使投资（一般在300万美元左右）->A轮（千万级）->B轮（亿级）->C轮-D轮，上市。\n\n有人说，位于天使投资阶段的公司最容易死。。。不然，在上市后都还能崩盘呢？还是要看盈利模式。\n\n一般创业公司能够拿到天使，那说明它的点子它的盈利模式是被人看好的，所以它可以拿到投资，因该可以做起来试试。\n\nA轮拿到了，说明它的盈利模式至少已经被实现了，并且已经开始有客户登录了业务开始转起来了。\n\n前文说到了，看一公司好坏，要看它为你提供的“职业发展空间”到底有多大”，职业发展空间越大这家公司存活率也越高。\n\n面试时一定要记得问这家公司的盈利模式，但是也不要只是听听人家和你说什么，而是要确实的去了解，这边要了解哪些呢？\n\n盈利模式是很要紧的，一个公司至所于存在一切是围绕着它的盈利模式来运转的，但是盈利模式也不能乱来的。要知道老总也是人，他的智商不比你高到哪去，而是在于他的经验，他不断的探索，以及他身边的那支团队给他出谋划策。\n\n它的盈利模式不行，虽然它搞得很早，它是做O2O的，即线上到线下，这个词很火，但是它忽略了一点，就是O2O一旦起来后，你需要有强大的供应链，物流，相应的客户配套。。。这些没有，没有一个完整的良好的平台去支持它的运行，结果导致整个机构极度膨胀臃肿，没有平台没有系统，无法维护这支以万人级别扩展的团队，最终“ ， ”是导致凡客倒下的主要原因。\n\n在互联网世界，软件定义一切，流程规章由软件、由平台去定义去管理，没有平台到了最后一切免谈，保险银行业更是如此，没有核心系统为什么保险银行不能运转？因为。。。做过核心系统的人就知道了，保险和银行业的一切流程甚至包括代表销售操作人员的流程，是为了让它那套核心可以更好的记录、输入和处理数据用的流程，是“人机互动的”哈。\n\n前面说了没有平台一定倒，现在有了平台怎么也要倒啊？这互联网还能玩不？\n\n为什么有了平台还要死，而且我告诉你，这个平台还真的很强大，不亚于一些BAT的平台，好完善，全自动，把软件定义一切发挥到了淋漓尽致啊。\n\n前面说了，创业公司的生存路线是怎么样的？ 。\n\n\n\n\n\n在上市前拿到这些投资用于干什么？不要认为拿到投资的人都一定富了哦，这钱可不是让你去吃、喝、嫖、赌、毒的，是让你“烧”的。\n\n很简单，你想，开个洗车摊位的在你家小区门口，让你用补贴让他们加入你的“平台”互联网起来，然后小区的人都知道这个摊位，人家直接就把车开过去或者经过时直接洗一洗。。。还要什么O2O，什么APP啊。\n\n然后流量没有、获客也没有（获得客源），钱已经烧了几千万了，你一边运行一边还入不付出。。。结果呢，投资人直接断掉你的粮源，因此1年内死，很正常。\n\n上述2种创业性互联网公司不能不说不大吧？也都是上亿的，相比国内一些大型项目形公司也不算差啦是吧？长的活不过8年，短的1年死，IT从业人员如果进去了。。。你的职业生涯也就这么几年吧。。。\n\n还是看它的盈利模式，看到这儿有网友要捶我了，到底什么盈利模式算是好的互联网企业呢？\n\n因此择业人员在面试时一定要多和公司的领导多交流关于他们的盈利模式，盈利模式也是我“下篇”中要主要讲解的内容。\n\n什么是互联网+，它是软件定义一切的延伸。\n\n举个例子来说，奶瓶上有一个码，用手机APP扫一下这个码可以追踪到这瓶奶是哪个国家哪个地区哪头牛几号第几个桶装的那点牛奶。。。这是一种互联网+技术。能做到这样的放心奶。。。是不是买你家奶粉或者牛奶的一定是最多的哈？\n\n再举个例子，RFID它是一种扫码枪，OK，我把它配到超市、各大商店，告诉客户，如果你用我家的产品，你可以用这个RFID扫一下，它除了告诉你我家的产品价格还会告诉你同类型的其它家的产品价格是多少，然后你来比较一下看看，我家的产品肯定比别家的要好，甚至你可以用别家产品的BAR CODE拿到这个RFID下来扫一下，他能告诉你别家同类卖多少价格。这个就叫“物联网”。\n\n某个心脏病人，带着一个智能手环，行走在路上，结果发病了，智能手环可以告诉你附近有哪些药店可以买到药，甚至告诉你最短的行走路径，你也可以选择马上呼叫120，这叫近场技术+物联网\n\n跑到机场，买票你不要排队了，拿着手机给身份证拍个照然后拿照片来到机场内一台设施，打开付款软件把刚才拍的照片调出来对着设备的一个叫“咻咻咻”的付款口，点一下“咻 Me The Money（不是STARCRAFT里的show me your money哈）”，然后机票出来，这叫声波支付。。。也是一种物联网技术。\n\n你戴着你的小6行走在上海人民广场步行街，此时你的手机收到一条微信，说就近25米的ADIDAS或者是NIKE或者是CAT或者是任何你忠意的名牌在打4折，你干紧去买吧！这叫什么？这叫ibecon也是一种近场技术。\n\n点子和平台是相辅相成的，它们2个要互相照顾，任何一个不能超越对方。做到这点很难。\n\n从择业者的角度来看其实就是这家企业的创业者，老总，管理团队，是否清晰的认识到自己的前进道路。\n\n多少钱做多少事，少用钱做更多的事、务实的事是很重要的。\n\n想着天天把平台做好，很激进的一直开会，一直鼓励，一直烧钱，砸钱的那是一种”乌托邦“式的企业，在这样的企业里你会学到很多，可是”寿命“不长。\n\n想着天天扩张，到处宣扬点子，平台一直不做，甚至租用其它人的或者没有意识到进一步的扩张反而会对企业进一步的发展造成伤害的，那也不是一种实干家。\n\n当然，要掌握上述2条，太”活“了，我们就来拿BAT中的A和T即阿里、淘宝还有一个很成功的案例即微信的成功来做例子吧。\n\n第三步：第三步其实是和第二步同步在进行的，即获客（获得客户）\n\n第四步：从技术形公司（互联网是典形的技术形公司）转为运营形公司，如马化腾就从首席架构师转形去做了运营官\n\n第六步：有了这么多客户，怎么办？收集他们的数据\n\n第七步：数据有了，好家伙，就能知道你平时的购买、消费习惯以及你的”信用“如何了（此时公司的性质将会又从运营形转变成了技术形）\n\n第八步：数据变现，什么叫变现，直接把你的数据变成更精准的营销手段，大家可能经常会看到下面这样的东西吧？\n\n它是怎么知道你还对这些个有兴趣。。。 你的日常行为购买数据的积累然后通过大数据分析得知 。\n\n第九步：那就是精准营销了，然后此时你的数据，由其是用户个人消费数据、使用数据可以说是超过了你的公司目前价值的一笔财富将为你带来巨大的成功。\n\n因为有了这些数据，你可以建立”个人征信报告“数据库，可以为一切银行提供这些数据。\n\n不要以为银行的个人消费数据是最全的，你错了。\n\n拿阿里的支付宝、淘宝来说，它们也在搞小额贷款，但是为什么坏帐率只有1%，而运行这一整套贷款系统的只有100个左右的IT人员，而银行是几十倍于这个数的业务人员都做不到如此好的坏帐率？\n\n那么来看看微信呢，呵呵，微信的马化腾老挂在嘴边的一句话是什么？\n\n51JBO呢，它是一个找工作，为企业搜人材的网站，你要享受一些更快捷更精准的服务就要付费对不对？\n\n可是就算用户付费了，这点钱，对于51JOB来说，可谓是杯水车薪，人家根本看不上这点钱，人家有上亿用户的真实简历资料，我的妈呀，这是一笔什么样的财富呢？\n\n数据这么值钱，以至于基于数据，在世界上出现了一个新的颠覆“摩尔定律”的一个新的定律，叫\n\nA公司的资产是B公司的5倍，那么我们说A公司是B公司的5倍实力。\n\n可是，如果B公司的用户数是A公司的5倍，那么B公司在很短的时间内，可能只有2，3年或者只有1-2年内它的市值将是B公司的5的平方倍，即25倍。\n\n这就是梅尔卡夫定律在互联网现实世界中的应用。\n\n回过头来我们来看微信。。。它有6亿用户，它的市值是要达到百亿了！\n\n淘宝？京东？51JOB？较早的携程，无一例不是梅尔卡夫定律一次又一次实现的典型案例。\n\n这几个公司在创业初级如果IT从业人员进去，是不是会很爽啊，都是百亿公司，都会成为“百年老店”，它们对于择业人员的发展空间，足够大了吧？\n\n再来看另一个互联网加，互联网金融领域，这也是近2年来最炽手可热的领域。\n\n其实，刚才我说过了，淘宝，支付宝，京东，微信它们其实都是按照我上面总结的九步走即：\n\n第三步：第三步其实是和第二步同步在进行的，即获客（获得客户） 第四步：从技术形公司（互联网是典形的技术形公司）转为运营形公司，如马化腾就从首席架构师转形去做了运营官 第七步：数据有了，好家伙，就能知道你平时的购买、消费习惯以及你的”信用“如何了 这样一步步走过来的，尤其是阿里淘宝、微信，它们已经处于第7步至第8步之间了，离百年老店只有一步之遥。 那么淘宝、微信、支付宝和金融有个毛线关系啊？人家是做电商的？ 它们其实真正涉足的是金融数据这块，这是它们的最终的终极目标，前面其实都只是一个铺垫啦。 来看支付宝这2年开始做了些什么事情？蚂蚁金服，个人微贷、小贷。 而且从近几年的数据来看，支付宝小贷微贷的风控做的极其好，为什么？还是前面我们说了，它已经有了大量的用户消费数据，行为数据，可以得出远比银行强百倍的“个人诚信报告”。 有了这个报告，一个用户进来贷款，好家伙，输入资料后直接有一个DASHBOARD（仪表盘），指针指向一个区间，在这个区间，他的贷款额度什么的就自动产生了，而且相当的精准。 其实，这也不是它的目标，我们刚才说了，它的终极目标是数据变现。 好，支付宝这个小贷微贷做了这么好。。。那它以后的信誉就会极高，它的坏帐会极底，银行甚至要把它当作“数据库”来拉个人房贷的征信报告，国内的银行，国外的银行都要靠它。。。这下好了，淘宝最终成了我们一直说的“最强的一种甲方公司-虚拟银行”，而实体银行成了它的“INPUT用的客户端 ” 以花呗做为吸引用户购买的一种手段，但花呗不是真正的目的，是一个铺势，是基于淘宝这个平台的辅助工具。 依靠花呗吸数据，最终数据变现后它将成为一个终极虚拟大银行，这是阿里马云的真正目的，因为做电商，你做不了百年老店，谁会成为百年老店啊？ 用马云的话说：“传统银行再不变革，它们将成为一群在21世纪内倒下的恐龙”。 有人说了，15年随着易租宝的问题 ，后来又出了一个中晋，现在的网贷，P2P谁敢信啊！ 15年，P2P总额度超过10万亿，已经和国内银行的贷款额度持平，并且银行的坏帐率以及准入门槛越来越高，这造成了大量的有”融资需求“的人和投资理财意识的这部分人无门而入。 这部分人已经开始被各种互联网+而产生的P2P、众筹所吸引，解决一个吊丝的个人贷款、个人投资这就叫”普惠金融“。 国际货币基金（简称“IMF”）和世界银行（简称“世行”）年会于当地时间4月11日（本周一）在美国首都华盛顿正式拉开帷幕\n\n\n\nIMF和世行的“超级周”的开幕论坛选择了“普惠金融”（Financial Inclusion）主题。无独有偶，一个月前在海南举办的亚洲博鳌论坛，由央行前副行长吴晓灵主持的开幕论坛的主题也是“普惠金融”。\n\n\n\n会上，世界著名的智库学者Veron斩钉截铁的说：“ 如果说有一个国家在普惠金融、互联网金融中的探索超过其他所有国家的总和，这个国家只能是中国。 ”\n\n这个表态在现场引起一片掌声。\n\n\n\n\n\n他最后回答了记者的问题：“ 说实话，我对中国监管机构没有什么建议。风险与机遇共存。中国在网络金融上前进太快，远远超过其他国家，我已经无建议可提。 ”\n\n\n\n前面说了，马云设了一个巨大的局，从：\n\n互联网领域是一片蓝海中的深蓝区域，埋藏着极大的发掘潜力，在这片深蓝中也有许多陷井需要注意。\n\n点子和平台是一个“共生体”，舍谁都不可以，有许多所谓的做互联网金融的，其实平台没有，钱也没有（说明点子也没有）但是急于做平台，因为有了平台就可以骗到投次人的钱。这样的公司表现一般如下：\n\nIT只有不多于20个人，人员结构资深的不会超过7年工作经验，这样的公司，会和来面试的人说的头头是道，最后和你说：我们还上过电视新闻呢，我们的客户都有哪些。。。\n\n一定一定不要信。。。20个人，就算50个人，能做什么？呵呵了！这样的一个平台，至少是要有百人规模的。这样的人，拿到了风投，不知道会做些什么事，卷铺盖跑路的都是这样的一票公司。\n\n那即使有了百人规模。。。它们的业务量如何呢？你去网上查一查它们的资料就知了，如果什么都查不到，HOHO。。。有多远离这种公司多远。\n\n如前段时间的e租宝和近期的中晋。。。资金流向根本就不明确的，这个钱人家投进来后你都贷给谁了？这个流向是谁在监管？4大行里哪个行帮你监管资金的？\n\n另外还有一种，叫打擦边球的互联网金融公司，它们做些什么啊？\n\n专门提供一种众筹，线下把一些合作商户的债权、债务拿过来，做成一个个的众筹产品，然后让人来投资，高风险当然高收益喽，以这样的手法把债务折包了后卖掉，缓解有债务一方的危机，以此来收取高昂的手续费和利息。\n\n最后怎么样？本来这个债只有1万，加上利息、手续费成了1万5，最后越滚越大，做成2万，但是实际这个真正的钱只有1万，还有1万就是做空。。。最后雪球大到一定的程度。。。崩盘，老总楼。\n\n除了上述的支付宝、蚂蚁金服、微信等，我们可以总结出好的互联网或者是互联网金融公司的一个共性\n\n愿意把钱更多的花在技术领域上\n\n坚持走自己的路，而且这条路一定是“独角兽”，什么叫“独角兽”，这也是互联网行当的一个新名词，即一枝独秀，没人做了比你好。\n\n即无论你的平台是怎么样的，它最终一定是走这条以数据变现道路的。\n\n这点是很重要的，即不要想着先平台化、PORTAL，现在已经不是2000年，随便搞个门户，就可以拉到上亿的风投，一定要有“业务”，业务一定比技术走的快，平台跟上，相辅相成。\n\n业务冲的太快，是死，因为平台跟不上，想想凡客的例子。\n\n平台做的完善，没有业务相配套死得更惨，想想那几个洗车网。\n\n有一家公司笔者接触后也是觉得极其优秀的。\n\n上海极优秀的一家做小微贷的“夸客金融”就是在P2P，T2P这块深蓝中做的极其好的一家，完全可以和阿里支付宝相媲美的。\n\n夸客金融本着“以人为本，客户为先”的宗旨，坚持以客户为中心，根据客户的收益、风险偏好，提供全面的财务规划。通过向客户提供现金、信用、保险、投资组合等一系列的金融服务，将客户的资产、负债、流动性进行管理，以满足不同客户、不同阶段的财务需求，帮助客户达到降低风险、实现财富增值的目的。\n\n夸客金融以P2P，T2P为业务模式，客户资金、逾期风险补偿金分别由第中金支付、招商银行进行托管，资金流向包括帐户都直接托管给了国企银行，来确保资金安全；\n\n夸客平台自2014年5月份上线以来，仅仅2年仅旗下一个才米公社成交量就达到10亿数额，其强大的个人信贷工厂更是将传统的金融与先进的互联网技术相结合，\n\n夸客的风控平台、数据平台在业内处于极其领先的地位，IT人数庞大，线下团队专业化程度极高，也是IT从业者的首选好去处，该公司一直致力于以最大的努力去满足客户每一个最小的需求。\n\n公司创始人也表示，夸客术有专精，它要做的就是做最大的小公司，而且夸客良好的声誉，使其也积累了相当大的客户数据，借助于其最擅长的风控并将其转化为模型，可以说这家公司也是走到了即将数据变现的地步了。这是符合梅尔卡夫定律的一家百年老店。\n\n中国人把诚信持久的企业叫做百年老店，阿里支付宝，夸客金融这些真正实现了互联网加的精髓，也可以供择业人员作样板去参考。", "link": "http://blog.csdn.net/lifetragedy/article/details/51175465", "publishDate": "2016-04-18 00:12", "title": "\r\n        "}
{"readCount": "5856", "article": "本文资源翻译@酒酒Angie：伊利诺伊大学香槟分校统计学同学，大四在读，即将开始计算机的研究生学习。希望认识更多喜欢大数据和机器学习的朋友，互相交流学习。\n\n当计算从大型计算机转移至个人电脑再转移到云的今天，我们可能正处于人类历史上最关键的时期。之所以关键，并不是因为已经取得的成就，而是未来几年里我们即将要获得的进步和成就。\n\n对我来说，如今最令我激动的就是计算技术和工具的普及，从而带来了计算的春天。作为一名数据科学家，我可以建造一个数据处理系统来进行复杂的算法运算，这样每小时能赚几美金。可是学习这些算法却花了我无数个日日夜夜。\n\n这篇文章有可能是我写的所有文章里最有价值的一篇。\n\n写这篇文章的目的，就是希望它可以让有志于从事数据科学和机器学习的诸位在学习算法的路上少走些路。我会在文章中举例一些机器学习的问题，你们也可以在思考解决这些问题的过程中得到启发。我也会写下对于各种机器学习算法的一些个人理解，并且提供R和Python的执行代码。读完这篇文章，读者们至少可以行动起来亲手试试写一个机器学习的程序。\n\n不过，这篇文章并没有阐述这些算法背后的统计学原理，有时候从实践入手也是很好的学习路径。如果你希望了解的是这些统计学原理，那么这篇文章的内容可能并不适合你。\n\n监督式学习算法包括一个目标变量（因变量）和用来预测目标变量的预测变量（自变量）。通过这些变量我们可以搭建一个模型，从而对于一个已知的预测变量值，我们可以得到对应的目标变量值。重复训练这个模型，直到它能在训练数据集上达到预定的准确度。\n\n与监督式学习不同的是，无监督学习中我们没有需要预测或估计的目标变量。无监督式学习是用来对总体对象进行分类的。它在根据某一指标将客户分类上有广泛应用。\n\n属于无监督式学习的算法有：关联规则，K-means聚类算法等。\n\n这个算法可以训练程序做出某一决定。程序在某一情况下尝试所有的可能行动，记录不同行动的结果并试着找出最好的一次尝试来做决定。\n\n属于这一类算法的有马尔可夫决策过程。\n\n线性回归是利用连续性变量来估计实际数值（例如房价，呼叫次数和总销售额等）。我们通过线性回归算法找出自变量和因变量间的最佳线性关系，图形上可以确定一条最佳直线。这条最佳直线就是回归线。这个回归关系可以用Y=aX+b 表示。\n\n我们可以假想一个场景来理解线性回归。比如你让一个五年级的孩子在不问同学具体体重多少的情况下，把班上的同学按照体重从轻到重排队。这个孩子会怎么做呢？他有可能会通过观察大家的身高和体格来排队。这就是线性回归！这个孩子其实是认为身高和体格与人的体重有某种相关。而这个关系就像是前一段的Y和X的关系。\n\n下图中我们得到的线性回归方程是 y=0.2811X+13.9。通过这个方程，我们可以根据一个人的身高得到他的体重信息。\n\n线性回归主要有两种：一元线性回归和多元线性回归。一元线性回归只有一个自变量，而多元线性回归有多个自变量。拟合多元线性回归的时候，可以利用多项式回归（Polynomial Regression）或曲线回归 (Curvilinear Regression)。\n\n别被它的名字迷惑了，逻辑回归其实是一个分类算法而不是回归算法。通常是利用已知的自变量来预测一个离散型因变量的值（像二进制值0/1，是/否，真/假）。简单来说，它就是通过拟合一个逻辑函数（logit fuction）来预测一个事件发生的概率。所以它预测的是一个概率值，自然，它的输出值应该在0到1之间。\n\n假设你的一个朋友让你回答一道题。可能的结果只有两种：你答对了或没有答对。为了研究你最擅长的题目领域，你做了各种领域的题目。那么这个研究的结果可能是这样的：如果是一道十年级的三角函数题，你有70%的可能性能解出它。但如果是一道五年级的历史题，你会的概率可能只有30%。逻辑回归就是给你这样的概率结果。\n\n回到数学上，事件结果的胜算对数（log odds）可以用预测变量的线性组合来描述：\n\n在这里，p 是我们感兴趣的事件出现的概率。它通过筛选出特定参数值使得观察到的样本值出现的概率最大化，来估计参数，而不是像普通回归那样最小化误差的平方和。\n\n你可能会问为什么需要做对数呢？简单来说这是重复阶梯函数的最佳方法。因本篇文章旨不在此，这方面就不做详细介绍了。\n\n以下是一些可以尝试的优化模型的方法：\n\n这是我最喜欢也是能经常使用到的算法。它属于监督式学习，常用来解决分类问题。令人惊讶的是，它既可以运用于类别变量（categorical variables）也可以作用于连续变量。这个算法可以让我们把一个总体分为两个或多个群组。分组根据能够区分总体的最重要的特征变量/自变量进行。更详细的内容可以阅读这篇文章Decision Tree Simplified。\n\n从上图中我们可以看出，总体人群最终在玩与否的事件上被分成了四个群组。而分组是依据一些特征变量实现的。用来分组的具体指标有很多，比如Gini，information Gain, Chi-square,entropy。\n\n理解决策树原理的最好的办法就是玩Jezzball游戏。这是微软的一款经典游戏（见下图）。这个游戏的最终任务是在一个有移动墙壁的房间里，通过建造墙壁来尽可能地将房间分成尽量大的，没有小球的空间。\n\n每一次你用建墙来分割房间，其实就是在将一个总体分成两部分。决策树也是用类似方法将总体分成尽量多的不同组别。\n\n这是一个分类算法。在这个算法中我们将每一个数据作为一个点在一个n维空间上作图（n是特征数），每一个特征值就代表对应坐标值的大小。比如说我们有两个特征：一个人的身高和发长。我们可以将这两个变量在一个二维空间上作图，图上的每个点都有两个坐标值（这些坐标轴也叫做支持向量）。\n\n现在我们要在图中找到一条直线能最大程度将不同组的点分开。两组数据中距离这条线最近的点到这条线的距离都应该是最远的。\n\n在上图中，黑色的线就是最佳分割线。因为这条线到两组中距它最近的点，点A和B的距离都是最远的。任何其他线必然会使得到其中一个点的距离比这个距离近。这样根据数据点分布在这条线的哪一边，我们就可以将数据归类。\n\n这个算法是建立在贝叶斯理论上的分类方法。它的假设条件是自变量之间相互独立。简言之，朴素贝叶斯假定某一特征的出现与其它特征无关。比如说，如果一个水果它是红色的，圆状的，直径大概7cm左右，我们可能猜测它为苹果。即使这些特征之间存在一定关系，在朴素贝叶斯算法中我们都认为红色，圆状和直径在判断一个水果是苹果的可能性上是相互独立的。\n\n朴素贝叶斯的模型易于建造，并且在分析大量数据问题时效率很高。虽然模型简单，但很多情况下工作得比非常复杂的分类方法还要好。\n\n例子： 以下这组训练集包括了天气变量和目标变量“是否出去玩”。我们现在需要根据天气情况将人们分为两组：玩或不玩。整个过程按照如下步骤进行：\n\n步骤2：计算各个情况的概率制作概率表。比如阴天（Overcast）的概率为0.29，此时玩的概率为0.64.\n\n步骤3：用朴素贝叶斯计算每种天气情况下玩和不玩的后验概率。概率大的结果为预测值。\n\n提问: 天气晴朗的情况下(sunny)，人们会玩。这句陈述是否正确？\n\n当有多种类别和多种特征时，预测的方法相似。朴素贝叶斯通常用于文本分类和多类别分类问题。\n\n这个算法既可以解决分类问题，也可以用于回归问题，但工业上用于分类的情况更多。 KNN先记录所有已知数据，再利用一个距离函数，找出已知数据中距离未知事件最近的K组数据，最后按照这K组数据里最常见的类别预测该事件。\n\n距离函数可以是欧式距离，曼哈顿距离，闵氏距离 (Minkowski Distance), 和汉明距离（Hamming Distance）。前三种用于连续变量，汉明距离用于分类变量。如果K=1，那问题就简化为根据最近的数据分类。K值的选取时常是KNN建模里的关键。\n\nKNN在生活中的运用很多。比如，如果你想了解一个不认识的人，你可能就会从这个人的好朋友和圈子中了解他的信息。\n\n在用KNN前你需要考虑到：\n\n这是一种解决聚类问题的非监督式学习算法。这个方法简单地利用了一定数量的集群（假设K个集群）对给定数据进行分类。同一集群内的数据点是同类的，不同集群的数据点不同类。\n\n还记得你是怎样从墨水渍中辨认形状的么？K均值算法的过程类似，你也要通过观察集群形状和分布来判断集群数量！\n\n如果我们在每个集群中计算集群中所有点到质心的距离平方和，再将不同集群的距离平方和相加，我们就得到了这个集群方案的总平方和。\n\n我们知道，随着集群数量的增加，总平方和会减少。但是如果用总平方和对K作图，你会发现在某个K值之前总平方和急速减少，但在这个K值之后减少的幅度大大降低，这个值就是最佳的集群数。\n\n随机森林是对决策树集合的特有名称。随机森林里我们有多个决策树（所以叫“森林”）。为了给一个新的观察值分类，根据它的特征，每一个决策树都会给出一个分类。随机森林算法选出投票最多的分类作为分类结果。\n\n比较决策树和调节模型参数可以获取更多该算法细节。我建议读者阅读这些文章：\n\n在过去的4-5年里，可获取的数据几乎以指数形式增长。公司/政府机构/研究组织不仅有了更多的数据来源，也获得了更多维度的数据信息。\n\n例如：电子商务公司有了顾客更多的细节信息，像个人信息，网络浏览历史，个人喜恶，购买记录，反馈信息等，他们关注你的私人特征，比你天天去的超市里的店员更了解你。\n\n作为一名数据科学家，我们手上的数据有非常多的特征。虽然这听起来有利于建立更强大精准的模型，但它们有时候反倒也是建模中的一大难题。怎样才能从1000或2000个变量里找到最重要的变量呢？这种情况下降维算法及其他算法，如决策树，随机森林，PCA，因子分析，相关矩阵，和缺省值比例等，就能帮我们解决难题。\n\nGBM和AdaBoost都是在有大量数据时提高预测准确度的boosting算法。Boosting是一种集成学习方法。它通过有序结合多个较弱的分类器/估测器的估计结果来提高预测准确度。这些boosting算法在Kaggle，AV Hackthon, CrowdAnalytix等数据科学竞赛中有出色发挥。\n\nGradientBoostingClassifier 和随机森林是两种不同的boosting分类树。人们经常提问 这两个算法有什么不同。\n\n至此我相信读者对于常用的机器学习算法已经有了一定了解。写这篇文章并且提供R和Python的代码就是为了让你可以立马着手学习。动起手来去练一练吧，加深对这些算法过程的认识，运用他们，你会喜欢上机器学习的！", "link": "http://blog.csdn.net/han_xiaoyang/article/details/51191386", "publishDate": "2016-04-19 16:04", "title": "\r\n        机器学习系列(9)_机器学习算法一览（附Python和R代码）            \r\n        "}
{"readCount": "3805", "article": "大神可能看标题都不屑一看，我确实没有学历，也经受了没有学历的痛，但我不是来发牢骚牢骚的，只是阐述这样一种事实的存在；以及原因、影响、解决与对待。\n\n\n\n有学历的程序员永远不懂没学历的痛，就像白天不懂夜的黑。\n\n\n\n有学历的还没等毕业，校园招聘已经开始了，还没有走出校园，可能已经和某个知名的大公司签下了协议，拿到实习试用的机会；而没有学历的呢，校招对他们来说永远是个梦。\n\n我记得是我在上初中的时候，电视上就播放过这样的新闻“有多少多少大学生毕业后找不到工作”，NM我当时就想了，大学生都找不到工作，我还上大学干嘛。\n\n有人会骂了，你自己不行还怪上**TV了！\n\n不过像一句话说的那样“天赋决定了你能达到的上限，努力程度决定了你能达到的下限。以绝大多数人的努力程度之低，远远没有达到要去拼天赋的地步。”，只能怪自己不努力，怪自己眼光太短浅，怪不得任何人。\n\n你怪过命运吗？你相信命运吗？看下面的问答：\n\n要怎样努力，才能成为很厉害的人？\n\n答：如果你注定要成为厉害的人，那问题的答案就深藏在你的血脉里;如果你注定不是厉害的人，那你便只需要做好你自己。\n\n2016年高新技术企业认定的新政策有所改变：在人员比例方面，放宽对科技人员和研发人员比例的要求。新办法由现行“科技人员占企业当年职工总数的30%以上”调整为“科技人员占企业当年职工总数的比例不低于10%”，同时取消了“大学专科以上学历”的限制；取消“研发人员占企业当年职工总数的10%以上”的规定。对于部分传统行业的大型企业而言，是一大利好。\n\n\n\n这个问题得从公司管理者角度解释，招聘时，学历只是一个公司在招人时的最低门槛，然后面试时，通过你的言行举止，还有你的表情，还有你细节的动作，来揣测你平时的一些习惯，作为，看看你是否能快速融入团队，大多数的公司会更喜欢性格开朗的员工。但是为什么一定要看学历？其中一个方面是因为读过书的人对待的事情有一定的逻辑性，有人说读书没有用，但大家都没注意到，读书会潜移默化影响我们的思想，一些处理事情的方法。另一方面，没有学历的人中会含有这么几类人，第一种那就是千里马，也就是无文凭人才。第二种人就是不思进取，安于现状的人。第三种人没学识，没文化的人，等着天上掉馅饼的人。第四种人就是社会败类了，等等......像无文凭这种人才在社会非常少，而且混在人群中，如果你是管理者，你要怎么分辨哪些是人才，哪些是蠢才。作为公司，目的就是赚钱，没有时间，也不会花太经历来分辨社会中哪些人会对自己有用。而且有时候判断错误，将人渣招到公司来，谁都不想看到。相对于有文凭的人来说，总体质量会优于无文凭之人，虽然有文凭之人也有败类，但可以通过进一步面试和观察来进行筛选。\n\n\n\n有人说能力最重要，但那是干活的时候；有几个能力真的是特别强的，如果真有那么强的能力，还需要给人打工吗？\n\n没有学历你想进大公司直接就不合格，还没面试就已经被pass掉了；当然了，有的人比较聪明，简历上虚报学历，或者搞个假学历。你能力确实强，比别人强，但同时段进入公司的相同的岗位，活干的比别人好比别人多，人家有学历的拿一千，你顶多能拿8百，你心理什么滋味？当然了，你可以在面试的时候多要点嘛，但也得有公司要你算；不过目前来看，你敢要还有人敢给。正像有句话说的“只要你敢骗就会有人上当！”，天朝人多，概率再小也有机会。\n\n另外，别被别人口口声声的能力给蒙蔽了，老板用人，不看能力，先看这几点！\n\n能力就像武器，它重要吗？重要是用武器的人的本质，在好人手里干好事，坏人手里……\n\n木桶效应相信小伙伴们都知道，木桶定律是讲一只水桶能装多少水取决于它最短的那块木板。任何一个组织，可能面临的一个共同问题，即构成组织的各个部分往往是优劣不齐的，而劣势部分往往决定整个组织的水平。\n\n\n\n你也可以选择扬长避短，使你的技术足够强，足够让别人忽略你的短板。\n\n1. 学硕专硕之分的由来\n\n1.1 就业形势决定硕士必须扩招\n\n    由于本科扩招严重，课程设置不合理，导致每年产生数以万计的毫无实践经历和工作技能的待业毕业生。\n\n    对政府而言，待业人数的逐年增大，社会不安定系数逐年递增，怎样把莘莘学子入岗就业成为亟待解决的难题。对企业而言，找到优秀人才也相当不易，而中国人有高学历情节，高学历是人才的重要指标。所以，硕士在就业大军中优势明显。\n\n    于是政府明白了，解决就业问题最直接的方法是把学生送入学校攻读硕士，既减少待业青年，又能培养企业认可的人才，何乐而不为呢？\n\n    所以，硕士扩招势不可挡。\n\n1.2 科研形势决定硕士必须缩招\n\n    何谓硕士？硕士是有独立思考能力和一定科研创新能力之人，甘于放弃功利而坐冷板凳苦心钻研之人。\n\n    但是，随着硕士的扩招，研究生成为就业的跳板，功利主义四处开花，风气败坏，没有人愿意攀登科学高峰了。同时，导师也不把研究生看成高等人才、中国科学的未来，而是敛财工具。这导致硕士质量严重下降，逐渐连硕士就业也成困难。\n\n    为继先人之绝技，维持科学和就业的可持续发展，硕士缩招势在必行。\n\n1.3 政府解决方案——学硕专硕之分\n\n    就业形势决定硕士必须扩招，科研形势决定硕士必须缩招，貌似出现了不可调和的矛盾。政府作为老练的和稀泥者，果断使出杀手锏——分硕士为学硕和专硕！政府希望，从一开始，考研者就主动举手示意，究竟是为就业考研还是为科研考研。前者是为专硕，后者是为学硕。\n\n    传统的硕士都是按照培养科学家的方案来培养学生。事实上，社会不需要这么多科学家，大批量培养科学家也是天方夜谭。按照原有方案培养学生无疑是耗费科研经费，浪费学生青春。所以学硕专硕之分是政府一箭双雕的高招。而且学硕比例必然越来越低，专硕比例必然越来越高。\n\n2.专硕之地位\n\n    专业硕士早已有之。专业硕士是以培养应用型和工程研究型人才为目的。根据国务院学位委员会的定位，专业学位为具有职业背景的学位，培养特定职业高层次专门人才。之前规定的是应届毕业生不能考，只有工作两年之后的人才可以考。这是由于有两年以上工作经验的人专业基础较扎实，知道自己哪些知识薄弱，哪些知识工作中常用，无论学习规划还是学习目标都更有针对性。导师对专硕的培养自由性较强，只需在关键时候给予必要指导即可。不过09年的时候应届毕业生可以从学术硕士调剂到专业硕士。\n\n    应届生可以直升专硕是形势所迫的产物，名为硕士，却已经失去硕士培养的初衷。这些专硕应届生既不像学硕那样接受循序渐进的科研能力和思维的培养，也不能像有工作经验者那样自主性针对性较强的汲取知识。导师究竟怎么培养他们呢？既要区分于学硕，又要区分于之前的专硕，不伦不类。何况导师真的有时间仔细推敲培养方案吗，更可能是放养式的给几个项目做做，最后写篇论文毕业罢了。\n\n    专硕目前处于非常尴尬的局面。\n\n3.学硕专硕之前途\n\n    学硕专硕本身并无高低贵贱之分，两者是平行的，前者向着学术，后者向着应用，前者是小部分人，后者是大部分人。\n\n    但是改革后的专硕毕竟是新生事物，就总体而言，在一段时间内其认可度要低于学硕。这段时间是多久呢？我想短则三五年，长则十年二十年。时间长短完全在于培养方案。如果方案得体，即确实能培养出极具应用能力的人才，很快专硕的认可度就会超过学硕。专硕有一个王牌优势——进公司实习。很多企业会留下表现优秀的实习生，毕竟企业需要的是应用型人才。可是从目前浮躁的气氛来看，应用型人才更像是一种口号，笔者很难搜索到关于专硕的系统的培养方案。两年时间再除去写论文和上课，究竟能否培养出高素质的应用型人才是个问题。还有一种说法，两者的教学一样，差别仅在于毕业论文和直博。专硕毕业论文对理论要求低一些，容易过；专硕不能直博。不过从政府的态度看，政府绝对不会偏向学硕，反倒是会偏向专硕。近几年学硕的培养的确差强人意，而解决就业问题是当务之急。所以政策上绝对会大张旗鼓的宣传专硕，并且专硕的待遇也不会比学硕差。只要有政府支持，从长远看，专硕总有一天会超过学硕。\n\n    而学硕呢？当然保持原来的教学风格，培养着理论和实践有点脱节但认可度较高的所谓学术型人才。值得庆幸的是，由于专硕的存在，学硕的比例会越来越小。或许不久的将来，学硕又会变成精英教育，学硕会越来越成为科学发展的中坚力量。\n\n    究竟报考学硕还是专硕呢？仁者见仁智者见智。我的观点是，如果你的考研目标是搞科研、考博士，那么学硕几乎是你的唯一出路，你要义无反顾的报考学硕；如果你的目标是就业，同时对自己的实力较有把握，安全起见最好报考学硕，实在不行也能调成专硕，万一将来想混个博士学位，直博是条捷径，既省时又省力；如果你就是想混个文凭就业，同时对自己的实力没有把握，直接报专硕，专硕也是双证，完全满足企业对学历的虚荣心，不要怕有歧视，即使有也是短暂的。学硕也好，专硕也罢，只是学历的一种形式。人的前途终究不是靠学历来决定的，还要靠自己的能力在社会上混！\n\n\n\n人生是美好的，前途是光明的，需要用积极的心态来面对将来。\n\n学历的短板已经是事实的存在，感受到，认识到，发现了问题，就要想办法去解决，在文章“After 500：写500篇博客其实和写一篇是一样的”中我说到一句话“从现在开始，一切都还不晚”。没错，从现在开始，一切都还不晚！前半生与后半生的分界线是在哪里？答：此时此刻。\n\n写到这里我突然想到了一些学历很重要的反证，那就是：史上最狂妄的演讲，甲骨文公司总裁Larry Ellison在耶鲁大学的演讲：我是个退学生， 但我是这个行星上第二富有的人\n\n当然，同样的鞋子，穿在别人脚上能翻山越岭，但穿在你脚上，可能几步你都走不下去。\n\n而又像【读评】为什么你有10年经验，但成不了专家？中讲的，为了达到某个高度，你需要一个恒定的目标，还要加上持续的刻意练习。\n\n我的回复：感性到理性的回归；\n\n就像下面的问答说的很好：", "link": "http://blog.csdn.net/testcs_dn/article/details/51170327", "publishDate": "2016-04-17 21:06", "title": "\r\n        "}
{"readCount": "3797", "article": "3.   由于我们的表单涉及到9个页面，所以我们先把八个页面都添加完成：\n\n5.   接下来我们开始相关内容的设计了，我们可以在这里稍微设计下面试者的相关信息，这里我填写了一些常用信息：\n\n6.   有些信息是填写的，我们只需要在图中选中我们的信息：\n\n7.   在性别这边由于是固定的男女，所以我们选择下拉列表来进行选择：\n\n8.   这里面值得一提的就是电子邮件，由于需要包含@，所以我们可以定义必须有这么个属性，通过规则来定义必须包含@:\n\n10.  接下来我们从自定义列表中获取相应的招聘数据，因为应聘数据属于从列表中获取相关的内容的，所以我们自定义列表获取数据是需要建立自定义连接的：\n\n11.  点击添加后，我们就可以建立到列表库的连接：\n\n21.  然后我们选择招聘工种，到此我们的招聘界面已经完成：\n\n22.  接下来我们就要提供给一些信息，给面试者了提供面试官的一些信息，这部分是面试的具体信息：\n\n23.  因为这部分信息我们引入的是公司的招聘员工，所以我们的数据要从公司的人员列表中获取，因此我们这里建立一个面向自定义列表的数据连接：\n\n26.  主要获取我们提到的部门人的信息后点击下一步：\n\n32.  接下来是面试人员分机，因为需要和我们的面试官对应好，因此需要进行列表筛选，我们依然选择下拉列表：\n\n34.  接下去我们就要进行数据筛选了，因为我们的数据是根据我们前面的名字来筛选的，因此非常重要：\n\n35.  这里设置的筛选目标中，我们的姓名必须和我们的这边选中的名称一样：\n\n36.  在选中的名称中，选中域及组，这边姓名和我们的面试官要对应起来：\n\n37.  接下来我们选择确定后即可结束筛选，我们将值和显示名称选中为电话：\n\n39.  初试面试官的Email 地址也是类似的设置，我们就不过多叙述：\n\n43.  接下来我们来设置一个按钮，按钮的作用是用来提交数据，切换视图，我们这里只是设置提交数据，切换视图我们等到设置隐含参数的时候回头再来说，这个按钮功能是需要我们自己定义出功能的：\n\n45.  接下来我们给按钮设置规则，这里我们给他起一个提交数据名称：\n\n51.  勾选允许覆盖，同时为了避免我们的文件名重名，我们需要做一件事情，就是为文件名设置为不会重复的名称，我们选择Now,基本永远不会重名：\n\n55.  点击确定完成设置，到此为止，我们的第一个页面已经设置完成了，接下来我们来设置面试印象评分了：", "link": "http://blog.csdn.net/fogyisland2000/article/details/51176124", "publishDate": "2016-04-17 22:46", "title": "\r\n        SharePoint 轻量化应用之招聘表单初试通知表单设计            \r\n        "}
{"readCount": "3302", "article": "在我之前的博客中讲到了感知器（感知器），它是用于线性可分模式分类的最简单的神经网络模型，单个感知器只能表示线性的决策面，而反向传播算法所学习的多层网络能够表示种类繁多的非线性曲面。\n\n对于多层网络，如果使用线性单元的话，多个线性单元的连接仍然是线性函数，所以还不能表征非线性函数。使用感知器单元，但是它不连续所以也就不可微，不适合梯度下降算法。我们需要这么一种单元，它的输出是输入的非线性函数，而且输出是输入的可微函数。那么可以使用sigmoid单元，它非常类似于感知器单元，而且基于一个平滑的可微阈值函数，It looked like this: \n\n\n\n它的输出范围为[0,1]，随输入单调递增，这个函数把非常大的输入值映射到一个小范围的输出，它经常被称为sigmoid单元的挤压函数（squashing function）。sigmoid函数的导数很容易以它的输出表示，即有时候可以使用其他容易计算导数的可微函数代替，比如sigmoid函数中的有时候被替换为其中是个正常数，用来决定函数的陡峭性。双曲正切函数也可用来代替sigmoid函数 。\n\n对于由一系列确定的单元相互连接形成的多层网络，反向传播算法可以用来学习这个网络的权值，它使用梯度下降方法来最小化网络输出值和目标值之间的误差平方。\n\n在这里我们要考虑网络中多个输出单元，而不是一个单元，所以可以看到下面的误差公式中要计算两次和：\n\n其中是网络输出单元的集合，是与训练样例和第个输出单元相关的输出值。\n\n反向传播算法需要解决的问题是搜索一个巨大的假设空间，这个空间由网络中所有单元的所有可能权值定义，此时可以用一个误差曲面来形象表示。在和训练单个单元的情况一样，梯度下降可以用来寻找使 最小化的一个假设。\n\n多层网络的一个主要不同是它的误差曲面可能有多个局部最小值，那么这就会带来一个问题，使用梯度下降的时候不能保证一定能收敛到全局最小值。不过在实践中反向传播都产生了出色的结果。\n\n反向传播首先把输入 沿网络前向传播，然后计算每个单元 的输出 ，然后是误差沿网络反向传播（反向传播算法名字应该就是这么得来的吧），对于网络的每个输出单元 ，计算它的误差项 ：\n\n对于网络的每个隐藏单元计算它的误差项更新每个网络的权值其中反向传播已经开发除了许多变种，最常见的是修改权值更新法则，使第次迭代的权值更新部分依赖于第次迭代时的更新，即其中，一个冲量常数，上式右边第二项叫做冲量项。", "link": "http://blog.csdn.net/lxytsos/article/details/51175557", "publishDate": "2016-04-17 21:25", "title": "\r\n        多层网络和反向传播笔记            \r\n        "}
{"readCount": "3158", "article": "曾经在一个非常有激情的团队中一起干一番事业，每个人各自发挥各自的特长，将每一期项目在不加班的情况下准时上线。\n\n后来公司在年后财务原因倒闭。团队解散后每个人到了不同的公司，工作后都发现原来很多公司，包括某些大公司，没有使用敏捷开发导致公司存在很多问题，加不必要的班，效率低，代码质量不高。团队之间协调能力差，团队内部没有热情，甚至沮丧、悲观。\n\n年后重新在一家算比较成熟的、知名的某视频互联网公司入职后，发现公司内部问题也很大，甚至一个迭代完成后没有总结会议。代码混乱，不规范，Bug很多，甚至更改Bug效率很低。于是探索敏捷团队转型之路，想重新找回当初那个团队的气势、状态。\n\n1、制定详细的工作计划， 并做出详细的工作安排\n\n5、基于简单原则的原理，原则简单但必须被遵循\n\n\n\n然后就闲着没事干，迭代速度太快导致也不考虑下优化代码等等的)\n\n在加入工作后，发现他们更改bug效率极低，一些与测试沟通交流就能很快解决的，他们缺少沟通意识。像一些闪退，组员给测试打包的时候经常关闭日志功能，或打上混淆包，致使一些崩溃的bug很难重现、以至于解决不了，禅道上Bug居高不下。原本在他们下个星期迭代会议上提出总结的几大问题，结果那个迭代会议就是产品一来屁颠的讲了一通问我们明白没，好散会。于是我私下向组长请示，我们上个迭代开发问题挺多的，大家开个会总结总结，讨论下如何提高工作效率，组长兴致的让我讲了下，然后没有开会下文，本来是一个团队共同提高的一个会议，组长也没有这个意识去推进。\n\n同样的以前的老同事在新的公司遇到了同样的问题，他觉得组长也没有这个意识要引入敏捷开发模式，虽然工作很闲，但年轻人都不会安于安逸，于是他找到老大提出要离职，老大问原因，朋友跟他讲了现在公司面临的问题，以及我们之前公司的团队状况及工作热情生气，他们老大也觉得很震撼，于是要求挽留整改工作实施敏捷开发。\n\n故事对比及实践总结一:敏捷开发的推进需要高层管理者引起高度的重视、认识到问题才能使开展进行\n\n万事开头难，如果你成功说服你们高层意识到公司问题，并决心要改变，那么你就可以实施敏捷开发了\n\n1、没有投入足够能力的人，关键瓶颈没有识别出来。 实际开展的敏捷的时候，严重阻碍项目运作\n\n4、围绕重构、 测试驱动和持续集成所 需要的更高设计和编写能力，\n\n进行系列化的培训和研讨，强调实战演练， 并在工作中不断锤炼，可以采用一对一帮扶，\n\n2、所有成员具备熟练重构，测试驱动 和持续集成等活动的关键设计和编码能力\n\n2、只注重敏捷实践的流程和实践的形式， 而忽略技术能力的跟上，有形而无实\n\n\n\n2、结合环境、工具、人员的准备度和 敏捷实践之间的支撑关系，\n\n1、试图将敏捷开发及其套在瀑布开发过程上，导致不得其利，反受其害\n\n4、过于理论化和完美主义， 导致定制的过程和实践不具现实可操作性\n\n\n\n2、发扬好的思路和方法，让团队保持信心和热情\n\n团队成员带着疑虑和不满进入下轮迭代\n\n2、培养出敏捷教练(很高层次了，团队起码磨合4次迭代才是合适机会开始培养)\n\n故事三:每一次迭代问题就越少，框架越成熟，基本上没有bug，所以自然而然的不用加班，一天 8小时，然后一起去看看电影、吃吃饭、谈谈互联网", "link": "http://blog.csdn.net/lilin9105/article/details/51175007", "publishDate": "2016-04-17 21:29", "title": "\r\n        敏捷团队转型            \r\n        "}
{"readCount": "3160", "article": "前段时间有个同事接手了一个名为DevOps的任务，今天无意中又听见了一个成为ChatOps的东西。\n\nDevOps（英文Development和Operations的组合）是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。它的出现是由于软件行业日益清晰地认识到：为了按时交付软件产品和服务，开发和运营工作必须紧密合作。\n\n\n\n我们可以把DevOps看作开发（软件工程）、技术运营和质量保障（QA）三者的交集。\n\n 传统的软件组织将开发、IT运营和质量保障设为各自分离的部门。在这种环境下如何采用新的开发方法（例如敏捷软件开发），这是一个重要的课题：按照从前的工作方式，开发和部署不需要IT支持或者QA深入的、跨部门的支持，而却需要极其紧密的多部门协作。然而DevOps考虑的还不止是软件部署。它是一套针对这几个部门间沟通与协作问题的流程和方法。\n\n\n\n在很多企业中，应用程序发布是一项涉及多个团队、压力很大、风险很高的活动。然而在具备DevOps能力的组织中，应用程序发布的风险很低，原因如下：\n\n 与传统开发方法那种大规模的、不频繁的发布（通常以“季度”或“年”为单位）相比，敏捷方法大大提升了发布频率（通常以“天”或“周”为单位）\n\n 减少变更范围与传统的瀑布式开发模型相比，采用敏捷或迭代式开发意味着更频繁的发布、每次发布包含的变化更少。由于部署经常进行，因此每次部署不会对生产系统造成巨大影响，应用程序会以平滑的速率逐渐生长。加强发布协调靠强有力的发布协调人来弥合开发与运营之间的技能鸿沟和沟通鸿沟；采用电子数据表、电话会议、即时消息、企业门户（wiki、sharepoint）等协作工具来确保所有相关人员理解变更的内容并全力合作。自动化强大的部署自动化手段确保部署任务的可重复性、减少部署出错的可能性。\n\n\n\n投资在那些关注技术的使用，以及如何采用持续开发、测试、集成、部署和操作的培训计划上。对云应用开发的管理必须是系统性的，构建在DevOps流程中的每一步，包括对使用的服务或API，以及服务发现和服务的依赖上所做的限制的政策。DevOps需要改变和发展以跟上新兴的理念和技术。在设计你的DevOps流程时始终要将变化考虑在内。\n\ndevops填补了之前的空白部分，devops通过建立一个完整的生命活动周期，devops关注如何更好地获取IT运维团队的反馈。devops将敏捷原则应用于管理领域，devops使得开发人员和管理员可以进行毫无障碍的沟通。\n\n devops还有很多不足，devops导致代码交接容易出现延迟。devops同样的情况也会出现在重大bug的修复过程中。\n\n devops可以在两个方面提升知识水平和程序质量。首先，devops对于许多较新的、面向对象的操作系统，比如Linux，devops很有可能不关机而一直保持运行状态。因此，devops容易出现问题，比如错误的垃圾回收机制以及不能正确重新组织关系型数据存储。\n\n devops借鉴了大型机管理员积累的经验来重新认识软件平台类型，以及可能引起这些类型问题的开发和/或测试流程。devops开发团队可以使用嵌入式模式保护代码来部署代码库和测试环境。\n\n devops的目标是在测试环境中，或者devops以代码的形式嵌入到应用程序自身当中以获取大型机复杂性的现有知识，devops不希望大型机管理员发现问题所在。devops并不仅可以使得开发人员和测试人员的工作更加轻松，同样可以简化管理员的工作。\n\n devops可以改善这种大型机管理模式，devops提高大型机管理员的工作效率。首先，devops通过实现标准配置和Linux相关任务的自动化，devops可以保证管理员拥有更多时间来“救火”。devops通过确保解决方案是长期有效和高质量的来减少对于处理紧急情况的处理需求。此外，devops让管理员也参与敏捷开发流程，和开发团队进行沟通，当开发团队拥有了一个能够快速定位问题并且修复运行时问题的测试工具或者代码库之后，devops就可以减少管理员修复bug以及与开发部门协调所花费的时间。[13] \n\n\n\n自动化在DevOps中很重要因为它提供了准确性和速度。应用交付需要高效，而手动安全测试就是不够快。更重要的是，第三方在外部手动测试中往往会漏掉测试错误。尽管组织不需要完全抛弃手动测试，他们应该将自动化过程提上日程。安全团队应该确定如何自动实施他们的手动过程。当嵌入坚固DevOps到你现有的云环境中时，对安全测试工具进行审核以确保可以将其加入到持续集成和应用交付过程中。然后，删除或替换不适合DevOps的工具或者不能与你的云业务集成的工具。尽管IT行业采用敏捷和DevOps过程的比例很大，安全测试周期仍然还是基于传统繁琐的瀑布模型。这意味着许多组织忘记做安全资格测试，如PCI检查和风险评估，直到几乎为时已晚。为了更有效地同步安全和DevOps周期，从开发过程一开始就进行安全测试。实施坚固DevOps，安全团队需要开发和运营团队紧密合作。当这么做时，安全专家应该保持开放的心态去了解他们同事的文化和语言。这样，这种关系就成了一种真正的伙伴关系而不是一种机械的形式。在一个坚固DevOps模型中，安全团队应该让组织的其他部门也了解安全工具。通过分享技术知识，企业将有更广阔的劳动力，可以解决在第一线的安全问题。为了帮助小的安全团队在更大的DevOps组织内扩展其业务影响力，可以把安全工具包括在通用的操作工具包里。紧密监控和记录集成和交付流程，以确保高质量的软件。这也有助于识别安全问题。使用粒度变化日志为审计人员准备信息，以及可扩展的云安全监测工具。这些工具应能够自动跟踪和测量新添加的资源。此外，它们应汇总监测数据和快速检测实际的问题，同时消除误报。[14]\n\nHubot 是嵌入到 Github 聊天系统里的软件，或者说，它是个聊天机器人。5 年前，一个名为 Ryan Tomayko 的员工构建了 Hubub，目的是让工程师们更方便地管理 Github 的硬件和软件。\n\n\n\n通过向 Hubot 发送信息，工程师们可以升级服务器上的系统，删除数据库中的数据，甚至让全部的服务器下线。不过，Hubot 的能力在不断增强。如今，它向公司里所有人提供服务，处理各种纷繁复杂的任务。\n\n\n\n在公司外部，Hubot 被称作是“ChatOps”工具。就是说，它能够处理“运营”任务，比如设置新服务器和数据库，或者升级 GitHub 网站背后的代码。ChatOps 是 Github 自造的单词，不过，这种想法来源于软件界的 DevOps 运动。通过一些新型的软件，工程师们可以让公司内部的大量硬件和软件实现自动化设置和升级。ChatOps 添加了对话元素。\n\nHubot 的能力不仅仅就局限于系统任务。如果你想要与地球另一端的员工对话，Hubot 能告诉你对方的时区；如果你是公司的程序员，Hubot 能告诉你，GitHub 软件的特定部分何时有过改动；如果你是财务部门的员工，Hubot 能向你展示公司最近的收入数据。\n\n", "link": "http://blog.csdn.net/jeremysong88/article/details/51176546", "publishDate": "2016-04-18 00:09", "title": "\r\n        简述DevOps和ChatOps            \r\n        "}
{"readCount": "3076", "article": "在hadoop2.0中通常由两个NameNode组成，一个处于active状态，另一个处于standby状态。Active NameNode对外提供服务，而Standby NameNode则不对外提供服务，仅同步activenamenode的状态，以便能够在它失败时快速进行切换。\n\nhadoop2.0官方提供了两种HDFS HA的解决方案，一种是NFS，另一种是QJM。这里我们使用简单的QJM。在该方案中，主备NameNode之间通过一组JournalNode同步元数据信息，一条数据只要成功写入多数JournalNode即认为写入成功。通常配置奇数个JournalNode\n\n这里还配置了一个zookeeper集群，用于ZKFC（DFSZKFailoverController）故障转移，当ActiveNameNode挂掉了，会自动切换Standby NameNode为standby状态。\n\n在Hadoop3上生产一对钥匙，配置Hadoop3到Hadoop4、Hadoop5、Hadoop6的免密码登陆，执行命令：\n\n用上述同样的方法在Hadoop2、Hadoop3、Hadoop4、Hadoop5、Hadoop6中如法炮制即可。\n\n解压完后成后，分别在Hadoop1、Hadoop4删除/usr/local/software/package目录：\n\n创建文件myid并填写内容为4：vi myid (内容为服务器标识：4)。\n\n把Hadoop5、Hadoop6中的myid文件里的值修改为5和6路径(vi %ZOOKEEPER_HOME%/data/myid)。\n\n按照相同的步骤，为其它机器都配置上zoo.cfg和myid文件。\n\n在Hadoop1上启动所有journalnode，注意：是调用的hadoop-daemon.sh这个脚本:\n\nHadoop的运行时文件存放路径为：tmp目录，Hadoop2需要和Hadoop1一致，进行拷贝：\n\n1、只需要在Hadoop1上启动HDFS，\n\nNameNode:它是Hadoop中的主服务器，管理文件系统名称空间和对集群中存储的文件的访问。\n\nDFSZKFailoverController会定期通过该rpc调用proxy.monitorHealth()来监测NN的健康状况。\n\n1、只需要在Hadoop3上启动YARN，\n\nResourceManager:接收客户端任务请求，接收和监控NodeManager(NM)的资源情况汇报，负责资源的分配与调度，启动和监控ApplicationMaster(AM)。\n\n--以上为《Hadoop教程(五)Hadoop分布式集群部署安装》，如有不当之处请指出，我后续逐步完善更正，大家共同提高。谢谢大家对我的关注。", "link": "http://blog.csdn.net/yuan_xw/article/details/51175171", "publishDate": "2016-04-17 21:32", "title": "\r\n        Hadoop教程(五)Hadoop分布式集群部署安装            \r\n        "}
{"readCount": "3023", "article": "在试验之前先贴张图上来，大致说下具体的需求及环境（注：实验所用到的脚本在文章末尾，如果在过程中遇到可以先看脚本）\n\n两只 nginx web 服务器分别提供相同的访问，当一只主机无法提供服务（keepalived 、nginx 或者说主机宕机）后，另一只马上转换为MASTER状态，并且继承VIP，继续向用户提供服务。\n\n1、如果 keepalived 状态转换为 MASTER，则发送邮件进行通知运维人员（由下面 keepalived_check.sh 脚本实现） \n\n 2、需要nginx两台服务器提供的服务是完全一致的，并且当一台 nginx 的配置改变，则另一台立刻变为相同的配置，并且 reload 。（由 rsync+inotify 实时同步脚本 nginx_rsync.sh 脚本实现） \n\n 3、如果keepalived 挂掉，则检测并且重启keepalived；如果nginx 挂掉，则关闭keepalived，且让VIP转移到 keepalived-slave上面（由 nginx_check.sh脚本实现）\n\n4、准备 keepalived 和 nginx 包（keepalived 包可以去 keepalived.org 下载，nginx 包则去 tengine 官方下载）\n\n1、前1-8步骤 nginx-1 和 nginx-2 是一样的，照着以前做就行，这里主要帖下 nginx-2 的 keepalived.conf 配置\n\n4、启动nginx、启动 nginx_check.sh（nginx_rsync.sh 不必启动，因为只需配置一个nginx，则另一个也会自动同步并且 reload）\n\n在下图中可以看到，我第一次 status 之后 keepalived 的状态是 running的，当我执行 stop 之后 keepalived 马上变为 stopped 状态，可过会之后 keepalived 状态又变为 running\n\n2、当 nginx 挂掉后，那么理论上说 keepalived 服务也会关闭（通过nginx_check.sh 脚本实现）\n\n在下图中可以看到，第一次我 status 的时候 keepalived 的状态是 running… 的，nginx 进程也在，当我 killall 掉 nginx 之后，前三秒 keepalived 的状态还是 running… 接着马上停止该服务（脚本检测时间为10秒一次）\n\n在第一个问题中，我停止 keepalived 服务，那么这时候 slave 就会将状态转换为 master，则相应的，我也会收到报警邮件或者短信\n\n4、当 nginx-1 配置改动之后，nginx-2 的配置也会相应的更改，并且 reload （通过 nginx_rsync.sh 脚本实现）\n\n我在nginx-1上面执行下列命令，接着我们查看nginx-1和nginx-2的 /usr/local/nginx/html/index.html的配置信息和改动时间\n\n由下图可以发现 nginx-1 的 index.html 和 nginx-2 的 index.html 改动时间完全相同，并且配置也完全相同。", "link": "http://blog.csdn.net/wanglei_storage/article/details/51175418", "publishDate": "2016-04-17 22:06", "title": "\r\n        keepalived nginx 双机热备图文讲解            \r\n        "}
{"readCount": "2987", "article": "", "link": "http://blog.csdn.net/ljp812184246/article/details/51176227", "publishDate": "2016-04-17 22:52", "title": "\r\n        李文哲博士-贝叶斯思想以及与最大似然估计、最大后验估计的区别            \r\n        "}
{"readCount": "2984", "article": "相关文章 \n\n Android网络编程（一）HTTP协议原理 \n\n Android网络编程（二）HttpClient与HttpURLConnection \n\n Android网络编程（三）Volley用法全解析 \n\n Android网络编程（四）从源码解析volley\n\n讲完了Volley，我们接下来看看目前比较火的网络框架OkHttp， 它处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP，此外OkHttp还处理了代理服务器问题和SSL握手失败问题。\n\n运行程序log打印出来的是百度首页的html文件，基本的步骤很简单，就是创建OkHttpClient、Request和Call，最后调用Call的enqueue()方法。但是每次这么写肯定是很麻烦，肯定是要进行封装的。需要注意的是onResponse回调并不是在UI线程。\n\npost与get不同的就是要要创建RequestBody并传进Request中，同样onResponse回调不是在UI线程。\n\n首先我们设置缓存路径和大小并设置给OkHttpClient：\n\n当然也有种情况是有的请求每次都需要最新的数据，则在创建Request，来设置cacheControl为“CacheControl.FORCE_NETWORK”，用来表示请求会一直请求网络得到数据：\n\n另外我们也需要设置超时的时间用来处理各种网络超时的情况，超时的原因可能是网络问题也可能是服务器响应慢等问题，OkHttp当然不会忽略这一点，它支持连接、读取和写入超时的时间设置：\n\n使用call.cancel()可以立即停止掉一个正在执行的call。如果一个线程正在写请求或者读响应，将会引发IOException。当用户离开一个应用时或者跳到其他界面时，使用Call.cancel()可以节约网络资源，另外不管同步还是异步的call都可以取消。 \n\n 也可以通过tags来同时取消多个请求。当你构建一请求时，使用RequestBuilder.tag(tag)来分配一个标签。之后你就可以用OkHttpClient.cancel(tag)来取消所有带有这个tag的call。\n\n100毫秒后调用call.cancel()，为了能让请求耗时，我们设置每次请求都要请求网络，运行程序并且不断的快速点击发送请求按钮： \n\n\n\n很明显每次cancel()都失败了，仍旧成功的访问了网络，在cancel()时已经有读写操作了所以会报IOException。每隔100毫秒来调用call.cancel()显然时间间隔太长，我们设置为1毫秒并不断的快速的点击发送请求按钮： \n\n\n\n如果每次请求网络都需要写重复的代码绝对是令人头疼的，网上也有很多对OkHttp封装的优秀开源项目，功能也非常强大，封装的意义就在于更加方便的使用，具有拓展性，但是对OkHttp封装最需要解决的是以下的两点：\n\n根据以上两点，我们也简单封装一下，在此只是举个例子，如果想要使用OkHttp封装的开源库，推荐使用OkHttpFinal。 \n\n 首先呢我们写一个抽象类用于请求回调：\n\n原理很简单就是，写一个双重检查模式的单例，不了解双重检查模式的请查看设计模式之单例模式的七种写法这篇文章。在开始创建的时候配置好OkHttpClient，在请求网络的时候用Handler将请求的结果回调给UI线程。\n\n使用起来简单多了，而且请求结果回调是在UI线程的。下一篇我们会讲到OkHttp3，来看看它们之间的使用方式上有什么区别。", "link": "http://blog.csdn.net/itachi85/article/details/51142486", "publishDate": "2016-04-18 12:10", "title": "\r\n        Android网络编程（五）OkHttp2.x用法全解析            \r\n        "}
{"readCount": "2816", "article": "**这个整合，只是最基本的整合，并且是xml配置文件的方式之一，即其中的mybatis是采用非mapper接口的方式。（第二遍采用mapper接口方式；第三遍采用注解的方式；第四篇采用注解基于maven的方式），记录在这里，以免下次忘记时留作备用。 \n\n ===================================================================================================** \n\n 一，整体结构 \n\n \n\n \n\n 二，所需jar包： \n\n 实质上并不需要全部导入，这里为了方便就全部导入啦。 \n\n （1）spring4全部jar包 \n\n （2）mybatis全部jar包 \n\n （3）mybatis-spring.jar整合需要这个包，现在spring官方已经不提供整合的jar，所以需要另外下载mybatis官方提供的整合jar。 \n\n （4）这里使用数据源dbcp.jar,依赖pool.jar,因此也需要导进来。以及数据库连接驱动jar也需要。\n\n菜鸟首次整合，虽然很简单，在第一次整合的时候还是出现各种难以预料的错误的。为了更加清晰这里面的情况，整合了第二次，还是实践能够验证整理。多实践，多思考，谨记！", "link": "http://blog.csdn.net/duchao123duchao/article/details/51176673", "publishDate": "2016-04-18 00:20", "title": "\r\n        spring,springmvc,mybatis基本整合（一）--xml文件配置方式(1)            \r\n        "}
{"readCount": "3722", "article": "本文资源翻译@酒酒Angie：伊利诺伊大学香槟分校统计学同学，大四在读，即将开始计算机的研究生学习。希望认识更多喜欢大数据和机器学习的朋友，互相交流学习。\n\n当计算从大型计算机转移至个人电脑再转移到云的今天，我们可能正处于人类历史上最关键的时期。之所以关键，并不是因为已经取得的成就，而是未来几年里我们即将要获得的进步和成就。\n\n对我来说，如今最令我激动的就是计算技术和工具的普及，从而带来了计算的春天。作为一名数据科学家，我可以建造一个数据处理系统来进行复杂的算法运算，这样每小时能赚几美金。可是学习这些算法却花了我无数个日日夜夜。\n\n这篇文章有可能是我写的所有文章里最有价值的一篇。\n\n写这篇文章的目的，就是希望它可以让有志于从事数据科学和机器学习的诸位在学习算法的路上少走些路。我会在文章中举例一些机器学习的问题，你们也可以在思考解决这些问题的过程中得到启发。我也会写下对于各种机器学习算法的一些个人理解，并且提供R和Python的执行代码。读完这篇文章，读者们至少可以行动起来亲手试试写一个机器学习的程序。\n\n不过，这篇文章并没有阐述这些算法背后的统计学原理，有时候从实践入手也是很好的学习路径。如果你希望了解的是这些统计学原理，那么这篇文章的内容可能并不适合你。\n\n监督式学习算法包括一个目标变量（因变量）和用来预测目标变量的预测变量（自变量）。通过这些变量我们可以搭建一个模型，从而对于一个已知的预测变量值，我们可以得到对应的目标变量值。重复训练这个模型，直到它能在训练数据集上达到预定的准确度。\n\n与监督式学习不同的是，无监督学习中我们没有需要预测或估计的目标变量。无监督式学习是用来对总体对象进行分类的。它在根据某一指标将客户分类上有广泛应用。\n\n属于无监督式学习的算法有：关联规则，K-means聚类算法等。\n\n这个算法可以训练程序做出某一决定。程序在某一情况下尝试所有的可能行动，记录不同行动的结果并试着找出最好的一次尝试来做决定。\n\n属于这一类算法的有马尔可夫决策过程。\n\n线性回归是利用连续性变量来估计实际数值（例如房价，呼叫次数和总销售额等）。我们通过线性回归算法找出自变量和因变量间的最佳线性关系，图形上可以确定一条最佳直线。这条最佳直线就是回归线。这个回归关系可以用Y=aX+b 表示。\n\n我们可以假想一个场景来理解线性回归。比如你让一个五年级的孩子在不问同学具体体重多少的情况下，把班上的同学按照体重从轻到重排队。这个孩子会怎么做呢？他有可能会通过观察大家的身高和体格来排队。这就是线性回归！这个孩子其实是认为身高和体格与人的体重有某种相关。而这个关系就像是前一段的Y和X的关系。\n\n下图中我们得到的线性回归方程是 y=0.2811X+13.9。通过这个方程，我们可以根据一个人的身高得到他的体重信息。\n\n线性回归主要有两种：一元线性回归和多元线性回归。一元线性回归只有一个自变量，而多元线性回归有多个自变量。拟合多元线性回归的时候，可以利用多项式回归（Polynomial Regression）或曲线回归 (Curvilinear Regression)。\n\n别被它的名字迷惑了，逻辑回归其实是一个分类算法而不是回归算法。通常是利用已知的自变量来预测一个离散型因变量的值（像二进制值0/1，是/否，真/假）。简单来说，它就是通过拟合一个逻辑函数（logit fuction）来预测一个事件发生的概率。所以它预测的是一个概率值，自然，它的输出值应该在0到1之间。\n\n假设你的一个朋友让你回答一道题。可能的结果只有两种：你答对了或没有答对。为了研究你最擅长的题目领域，你做了各种领域的题目。那么这个研究的结果可能是这样的：如果是一道十年级的三角函数题，你有70%的可能性能解出它。但如果是一道五年级的历史题，你会的概率可能只有30%。逻辑回归就是给你这样的概率结果。\n\n回到数学上，事件结果的胜算对数（log odds）可以用预测变量的线性组合来描述：\n\n在这里，p 是我们感兴趣的事件出现的概率。它通过筛选出特定参数值使得观察到的样本值出现的概率最大化，来估计参数，而不是像普通回归那样最小化误差的平方和。\n\n你可能会问为什么需要做对数呢？简单来说这是重复阶梯函数的最佳方法。因本篇文章旨不在此，这方面就不做详细介绍了。\n\n以下是一些可以尝试的优化模型的方法：\n\n这是我最喜欢也是能经常使用到的算法。它属于监督式学习，常用来解决分类问题。令人惊讶的是，它既可以运用于类别变量（categorical variables）也可以作用于连续变量。这个算法可以让我们把一个总体分为两个或多个群组。分组根据能够区分总体的最重要的特征变量/自变量进行。更详细的内容可以阅读这篇文章Decision Tree Simplified。\n\n从上图中我们可以看出，总体人群最终在玩与否的事件上被分成了四个群组。而分组是依据一些特征变量实现的。用来分组的具体指标有很多，比如Gini，information Gain, Chi-square,entropy。\n\n理解决策树原理的最好的办法就是玩Jezzball游戏。这是微软的一款经典游戏（见下图）。这个游戏的最终任务是在一个有移动墙壁的房间里，通过建造墙壁来尽可能地将房间分成尽量大的，没有小球的空间。\n\n每一次你用建墙来分割房间，其实就是在将一个总体分成两部分。决策树也是用类似方法将总体分成尽量多的不同组别。\n\n这是一个分类算法。在这个算法中我们将每一个数据作为一个点在一个n维空间上作图（n是特征数），每一个特征值就代表对应坐标值的大小。比如说我们有两个特征：一个人的身高和发长。我们可以将这两个变量在一个二维空间上作图，图上的每个点都有两个坐标值（这些坐标轴也叫做支持向量）。\n\n现在我们要在图中找到一条直线能最大程度将不同组的点分开。两组数据中距离这条线最近的点到这条线的距离都应该是最远的。\n\n在上图中，黑色的线就是最佳分割线。因为这条线到两组中距它最近的点，点A和B的距离都是最远的。任何其他线必然会使得到其中一个点的距离比这个距离近。这样根据数据点分布在这条线的哪一边，我们就可以将数据归类。\n\n这个算法是建立在贝叶斯理论上的分类方法。它的假设条件是自变量之间相互独立。简言之，朴素贝叶斯假定某一特征的出现与其它特征无关。比如说，如果一个水果它是红色的，圆状的，直径大概7cm左右，我们可能猜测它为苹果。即使这些特征之间存在一定关系，在朴素贝叶斯算法中我们都认为红色，圆状和直径在判断一个水果是苹果的可能性上是相互独立的。\n\n朴素贝叶斯的模型易于建造，并且在分析大量数据问题时效率很高。虽然模型简单，但很多情况下工作得比非常复杂的分类方法还要好。\n\n例子： 以下这组训练集包括了天气变量和目标变量“是否出去玩”。我们现在需要根据天气情况将人们分为两组：玩或不玩。整个过程按照如下步骤进行：\n\n步骤2：计算各个情况的概率制作概率表。比如阴天（Overcast）的概率为0.29，此时玩的概率为0.64.\n\n步骤3：用朴素贝叶斯计算每种天气情况下玩和不玩的后验概率。概率大的结果为预测值。\n\n提问: 天气晴朗的情况下(sunny)，人们会玩。这句陈述是否正确？\n\n当有多种类别和多种特征时，预测的方法相似。朴素贝叶斯通常用于文本分类和多类别分类问题。\n\n这个算法既可以解决分类问题，也可以用于回归问题，但工业上用于分类的情况更多。 KNN先记录所有已知数据，再利用一个距离函数，找出已知数据中距离未知事件最近的K组数据，最后按照这K组数据里最常见的类别预测该事件。\n\n距离函数可以是欧式距离，曼哈顿距离，闵氏距离 (Minkowski Distance), 和汉明距离（Hamming Distance）。前三种用于连续变量，汉明距离用于分类变量。如果K=1，那问题就简化为根据最近的数据分类。K值的选取时常是KNN建模里的关键。\n\nKNN在生活中的运用很多。比如，如果你想了解一个不认识的人，你可能就会从这个人的好朋友和圈子中了解他的信息。\n\n在用KNN前你需要考虑到：\n\n这是一种解决聚类问题的非监督式学习算法。这个方法简单地利用了一定数量的集群（假设K个集群）对给定数据进行分类。同一集群内的数据点是同类的，不同集群的数据点不同类。\n\n还记得你是怎样从墨水渍中辨认形状的么？K均值算法的过程类似，你也要通过观察集群形状和分布来判断集群数量！\n\n如果我们在每个集群中计算集群中所有点到质心的距离平方和，再将不同集群的距离平方和相加，我们就得到了这个集群方案的总平方和。\n\n我们知道，随着集群数量的增加，总平方和会减少。但是如果用总平方和对K作图，你会发现在某个K值之前总平方和急速减少，但在这个K值之后减少的幅度大大降低，这个值就是最佳的集群数。\n\n随机森林是对决策树集合的特有名称。随机森林里我们有多个决策树（所以叫“森林”）。为了给一个新的观察值分类，根据它的特征，每一个决策树都会给出一个分类。随机森林算法选出投票最多的分类作为分类结果。\n\n比较决策树和调节模型参数可以获取更多该算法细节。我建议读者阅读这些文章：\n\n在过去的4-5年里，可获取的数据几乎以指数形式增长。公司/政府机构/研究组织不仅有了更多的数据来源，也获得了更多维度的数据信息。\n\n例如：电子商务公司有了顾客更多的细节信息，像个人信息，网络浏览历史，个人喜恶，购买记录，反馈信息等，他们关注你的私人特征，比你天天去的超市里的店员更了解你。\n\n作为一名数据科学家，我们手上的数据有非常多的特征。虽然这听起来有利于建立更强大精准的模型，但它们有时候反倒也是建模中的一大难题。怎样才能从1000或2000个变量里找到最重要的变量呢？这种情况下降维算法及其他算法，如决策树，随机森林，PCA，因子分析，相关矩阵，和缺省值比例等，就能帮我们解决难题。\n\nGBM和AdaBoost都是在有大量数据时提高预测准确度的boosting算法。Boosting是一种集成学习方法。它通过有序结合多个较弱的分类器/估测器的估计结果来提高预测准确度。这些boosting算法在Kaggle，AV Hackthon, CrowdAnalytix等数据科学竞赛中有出色发挥。\n\nGradientBoostingClassifier 和随机森林是两种不同的boosting分类树。人们经常提问 这两个算法有什么不同。\n\n至此我相信读者对于常用的机器学习算法已经有了一定了解。写这篇文章并且提供R和Python的代码就是为了让你可以立马着手学习。动起手来去练一练吧，加深对这些算法过程的认识，运用他们，你会喜欢上机器学习的！", "link": "http://blog.csdn.net/longxinchen_ml/article/details/51192086", "publishDate": "2016-04-19 16:58", "title": "\r\n        机器学习系列(9)_机器学习算法一览（附Python和R代码）            \r\n        "}
{"readCount": "2727", "article": "二进制包的优点： \n\n 包管理系统简单，通过命令就可以实现包的安装、升级、查询和卸载 \n\n 安装速度比源码包安装更快\n\n所谓的脚本安装包，就是把复杂的软件包安装过程写成程序脚本，初学者可以执行程序脚本实现一键安装。实际安装的还是源码包和二进制包。\n\nhttpd-2.2.15-15.el6.centos.1.i686.rpm \n\n -httpd软件包名 \n\n -2.2.15软件包版本 \n\n -15软件发布的次数 \n\n -3l6.centos适合Linux平台 \n\n -i686适合的硬件平台，若为x64则为64位硬件平台 \n\n -rpm 扩展名\n\n模块依赖解决： \n\n 1. 在线查询，网站：www.rpmfind.net \n\n 2. 本地查找，通过依赖模块名，猜测可能优先安装的rpm包中可能包含需要的库文件 \n\n 3. yum在线解决，RedHat通过yum在线搭载服务器，服务器已经帮助用户整理好软件安装的依赖库，方便用户下载 \n\n 4. 使用光盘做本地yum\n\n注：RedHat的yum是付费的，需要购买key\n\n包全名：操作的包是没有安装的软件包是，使用包全名，但要注意路径。 \n\n 包名：操作已经安装的软件包时，使用包名，是搜索/var/lib/rpm/中的数据库\n\n所有安装过的包，都可以在后台数据库/var/lib/rpm/目录中找到包的相关信息。 \n\n 包卸载时，仍有依赖性，必须按照安装顺序的相反顺序卸载依赖包。\n\nrpm -V 已安装的包名 \n\n options： \n\n -V （verify）校验指定RPM包中的文件\n\n验证内容中的8个信息的具体内容\n\nrpm2cpio将rpm包转换为cpio格式的命令 \n\n cpio是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件\n\n4安装位置不同带来的影响 \n\n RPM包安装的服务可以使用系统服务管理命令（service）来管理\n\n源代码保存位置： /usr/local/src/ \n\n 软件安装位置：/usr/local/ \n\n 如何确定安装过程报错：安装过程停止并出现error、warning或no的提示\n\n定义需要的功能选项 \n\n 检测系统环境是否符合安装要求 \n\n 把定义好的功能选项和检测系统环境的信息都写入Makefile文件，用于后续的编辑\n\n注1：./configure –help 查看需要的功能选项 \n\n make编译 \n\n 编译失败后，可以使用make clean清除缓存和临时文件和编译成功的文件\n\n关闭RPM包安装的httpd和MySQL \n\n 保证yum源正常使用 \n\n 关闭SELinux和防火墙\n\ncentos.sh脚本分析 \n\n 所谓的一键安装包，实际上还是安装的源码包与RPM包，只是把安装过程写成了脚本，便于初学者安装。 \n\n 优点：简单、快速、方便 \n\n 缺点：", "link": "http://blog.csdn.net/renwotao2009/article/details/51168919", "publishDate": "2016-04-17 22:40", "title": "\r\n        Linux软件安装            \r\n        "}
{"readCount": "2726", "article": "如今android N都已经出来了，作为一个android开发者如果还不知道如何使用android5.X的RecyclerView未免有点说不过去了。\n\nRecyclerView比ListView更灵活，更强大。因此也会引入一些复杂性，而这些复杂性，恰恰是在新手前进道路上的很大阻碍，而笔者此文也便是希望可以给予读者一些帮助。\n\n\n\n笔者个人看法，RecyclerView只是一个对ListView的升级版，这个升级的主要目的是为了让这个view的效率更高，并且使用更加方便。\n\n我们知道，ListView通过使用ViewHolder来提升性能。ViewHolder通过保存item中使用到的控件的引用来减少findViewById的调用，以此使ListView滑动得更加顺畅。但这种模式在listview中即使不使用也无妨。\n\n换言之，在ListView中你不考虑复用的问题也可以，只是你牺牲了内存来方便了代码。但是RecyclerView就不允许你这么做了，你使用RecyclerView就意味着你一定要复用，而效果上其实和ListView+ViewHolder差不多。\n\n\n\n4、实现点击事件，点击后能够使item中的字体变成红色\n\nRecyclerView是support-v7包中的新组件(此处意味着首先要导入v7包)，是一个强加的滑动组件，与经典的Listview相比，它同样拥有item回收服用的功能，但是RecyclerView已经封装好了ViewHolder，用户只需要实现自己的ViewHolder就可以了，该组件会自动帮你复用每一个item。\n\n由于RecyclerView与listview的使用比较类似，此处还是用大家比较熟悉的listview来解释。\n\nRecyclerView与listview的使用，主要不同在两个地方：\n\n\n\n2、listview定义的Adapter主要是针对view来进行操作的，而RecyclerView主要是针对ViewHolder来进行操作的。\n\n3、listview本身实现了点击事件，而RecyclerView如果需要点击事件，需要自己写一个接口。（新手不要害怕，并不难）\n\n下面就分点介绍一下在listview中不会碰到的几个点，也可能是新手认为的RecyclerView的难点：\n\n在任何ViewHolder被实例化的时候，OnCreateViewHolder将会被触发。\n\n\n\n此处实现的内容与fragment中的onCreateView差不多，只是onCreateView最后返回的是view而此处返回的是一个ViewHolder。（注意：使用的时候此处的ViewHolder应该是自己定义的，而不是RecyclerView.ViewHolder）\n\n此处建立起ViewHolder中视图与数据的关联。由于ViewHolder是自己实现的，此处使用ViewHolder会显得特别自由方便。\n\n这个就不多说了，和listview中的差不多，返回数据的size。\n\n除了这三个方法外，最重要的是需要自己实现一个ViewHolder，这个ViewHolder也需要继承RecyclerView.ViewHolder，（如果需要实现点击事件，也需要应用OnClickListener）\n\n在这个ViewHolder中，可以设置属性，并且与ViewHolder视图内的各个控件绑定，使用起来就十分方便了。\n\n这个如果花点时间了解概念，其实并不难，主要有以下步骤：（不懂可以看笔者demo）\n\n1、创建一个接口，并在里面写上你需要实现的方法\n\n2、创建一个该接口的对象来存储监听事件\n\n3、在需要使用到该方法的地方进行调用", "link": "http://blog.csdn.net/double2hao/article/details/51177594", "publishDate": "2016-04-18 11:51", "title": "\r\n        android RecyclerView布局真的只是那么简单！            \r\n        "}
{"readCount": "2670", "article": "远程安装oracle10g,通过网上资料，不断摸索成功安装。先在本地虚拟机Centos7上做实验，快照恢复快照恢复，安装了几十次成功之后，再在服务器Centos6上安装，(6和7还是有区别的，比如默认防火墙)中间遇到各种问题特记录下来分享。\n\n在/etc目录下创建一个名为 oraInst.loc 的文件,文件中的内容(两行代码)如下：\n\n输入下面的命令在oraInst.loc文件上设置合适的拥有者，组和权限：\n\n从网上搜集的，可能有重复包，不影响，yum安装时，已安装会自动略过\n\n加入以下11行代码(并将原来的# kernel.shmmax和kernel.shmall这两行参数屏蔽)（kernel.shmmax和kernel.shmall好像要单独考虑，我略过了）\n\n禁用SELINUX，安装完后可再还原成原值) 将SELINUX设置为\n\n注释掉原来的，添加下面的，因为oracle支持的操作系统包含rh4\n\n可根据你的需要作适当更改\n\n注销root用户，并登录oracle用户,在/home/oracle目录下建立一个名为enterprise01.rsp的文件，里面的具体内容如下(参考/oracle/database/response目录下面的enterprise.rsp文件，该目录下有三个文件enterprise.rsp(企业版静默安装文件),standard.rsp(标准版静默安装文件）和custom.rsp(客户版静默安装文件)，另外还有其他三个静默安装文件)。\n\n有三四个值在enterprise.rsp中没有，可以直接使用下面的配置\n\n以root用户运行安装后环境所需脚本(千万主意：要以root用户去执行这两个脚本,执行后一个脚本时，回车一下就可以了)\n\n至此Oracle的产品已经安装完成，可是目前为止我们还没有建立数据库。 由于没有X界面无法启动dbca ，所以不能用dbca来帮我们建立数据库。这时候你可能会想到用create database 语句来建立数据库，可是语法实在是繁琐，并且还要运行许多的oracle脚本 。 此时，我们可以利用oracle提供的种子数据库还原一个数据库出来(详细见以下操作) 假设我们要建立的数据库的名称为TSH1(这个名称跟你安装前设置的环境变量中的ORACLE_SID相一致)。\n\n建议同时建立三个远程连接，一个root,一个oracle下一般操作，一个oracle下rman操作，避免来回切换引起的不便和带来意想不到的问题（注意在重启数据库时要退出rman）。\n\n找到oracle为种子数据库提供的控制文件并copy至/u01/app/oracle/oradata/TSH1目录下(在Oracle用户下操作)\n\n注：因为Seed_Database.ctl控制文件中记录的db_name为SEEDDATA，所以第一行的设置如此\n\n启动数据库到mount状态,并使用默认的参数建立spfile文件;然后重新启动数据库并更改sga_max_size，sga_target参数的值;然后再次重新启动数据库(具体操作如下)\n\n问题： \n\n \n\n 该文件权限问题，可能当时copy的时候使用的是root,修改一下就行\n\n和sqlplus一样的命令，在oracle安装目录bin下\n\n这个备份集来还原数据库 \n\n 上面的地址是其他人的，我的是下面的，注意一下就行，灵活变通\n\n有两种方法解决此问题，一个是建立一个软链接\n\n并将Seed_Database.dfb copy至其下 。 \n\n 这里，我们使用第二种方法(具体操作如下):\n\n所以要先创建相应的目录并再次刷新其权限,体操作如下\n\n启动数据库到mount状态，并更改日志和临时文件的路径(具体操作如下)\n\n然后启动数据库到mount状态，并更改日志和临时文件的路径\n\n到此数据库已经建立，并且数据文件也放到了我们期待的地方。但是还有一个问题，就是数据库名称不是我们事先期待的。\n\n下面我们将数据库名称SEEDDATA改成我们需要的TSH1 。注意此时仅仅更改参数文件的值是不行的，因为控制文件中同样也记录着数据库的名称。", "link": "http://blog.csdn.net/u013938484/article/details/51175501", "publishDate": "2016-04-17 21:21", "title": "\r\n        Centos6/7下静默安装oracle10g            \r\n        "}
{"readCount": "17884", "article": "题外话，今天帮别人把Google earth上的截图给拼接下，此前并没有做过此项工作，考虑到Google earth上的影像图片是有坐标信息的，如果有专门针对GE影像下载的工具，那大范围的N张图片是完全可以实现自动拼接的。基于这个想法，对于ArcGIS中的栅格图像拼接功能mosaic和PhotoShop等软件直接不予考虑，再者本人机器上也没有安装ArcGIS。在网上先找到GetScreen，看功能介绍感觉挺棒的，下载来之后，因为不支持GE5和GE６，先从版本6换到版本5再到版本4，害得我着实忙活一阵，但是结果非常不理想，又找到SGGS.，对SGGS拼接结果非常满意，故在此做个对比。\n\n如何操作请参看《用GEtScreen（自动截屏拼图工具）配合Google Earth制作家乡卫星图吧》http://hi.baidu.com/jiuaidiy/blog/item/4b39cd1bf5df95dfad6e7539.html，博主写得很仔细。 对于操作需要提醒用户的是，在截图时，请不要进行任何操作，比如切换到其它软件工作界面，或让其它软件界面压盖本界面，都会影响截图，一些失败例子如下，对其成因分析会在后面的两款软件对比中提及。 GetScreen只对google earth 4.2 4.3有很好支持，个人先从版本6换到版本5再到版本4都一一测试过，对5版以上都不能支持，“两点定位”后，不能“图片计算”！每次都跳出出错对话框，重试无效。请参考《google earth 截图工具——关于GEtScreen使用方法及部分错误解释》。不过网上说打过5.0版的补丁后就可以用了，这个本人没有验证过。\n\n图1.1 北京某一地区距地面高度1公里的13*9的拼接图-整体效果图\n\n图1.2 北京某一地区距地面高度1公里的13*9的拼接图- 局部图1\n\n图1.3 京某一地区距地面高度1公里的13*9的拼接图- 局部图2\n\n有照片图标，这是因为没有对google earth图层列表中控制照片图层不显示的结果。其它距地面高度和不同行列数的截图拼接结果都不甚理想。\n\n图1.4 切换到其它软件工作界面，或让其它软件界面压盖本界面后的拼接效果\n\n功能 谷歌影像下载拼图工具，能按地图的缓存切片级数下载，这是我最喜欢的下载 方式。 操作 打开软件，在目标区域拉框选择下载区范围，双击后出现“新建任务”对话框，会发现拉框内的左上角和右下角的地理坐标自动显示在相应文本框内。设定存储路径和下载切片级数后点确定即可将影像下载到本地磁盘。在任务列表中选择该任务，在“导出/拼接”选项卡下的“导出/拼接图片”按钮，在新弹出的对话框中可以设置“导出单张大图”、“导出多张大图”、“标准行列式瓦片”、“金字塔式瓦片”等。其它操作不做介绍。 SGGS拼图效果 真正无缝拼图，只下载影像数据图层，对其它图层，如风景点，照片、地名图层均不做显示，使要拼接的底图更纯净。", "link": "http://blog.csdn.net/duguduchong/article/details/7256008", "publishDate": "2012-02-13 22:19", "title": "\r\n        比较具有从google earth下载影像并拼接功能的两个软件getscreen VS sggs            \r\n        "}
{"readCount": "11", "article": "本Markdown编辑器使用StackEdit修改而来，用它写博客，将会带来全新的体验哦：\n\nMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— [ 维基百科 ]\n\n本编辑器支持 Markdown Extra , 　扩展了很多好用的功能。具体请参考Github.\n\n即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入write.blog.csdn.net/mdeditor即可。Markdown编辑器使用浏览器离线存储将内容保存在本地。\n\n用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。\n\n用户可以选择 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。\n\n注意：虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，请务必及时发表或者保存到服务器草稿箱。", "link": "http://blog.csdn.net/qq_34207738/article/details/51193728", "publishDate": "2016-04-19 20:31", "title": "\r\n        欢迎使用CSDN-markdown编辑器            \r\n        "}
{"readCount": "128", "article": "刚刚需要用到这个功能的时候，完全是去百度的，并且是直接百度功能，对于是用的什么函数啊，什么方法啊，根本就不知道，完全都是照着誊下来的。\n\n所谓，欠下的早晚要还的，现在终于到了偿还的时候了。\n\n在第一次机房重构时导出Excel完全就是抄的，这次依旧，所以一直感觉很是神秘的一个功能。\n\n在这里我有一个疑问。\n\n在添加引用时其中有程序集和COM，程序集中又分了框架和扩展，我不懂的是：\n\n框架、扩展、COM中的类型库，三者中分别包含的内容有什么区别？每次添加引用时总不知道该去哪找。\n\n１.利用嵌套循环向Excel中填充数据时，i表示行，就表示列，Excel中从行开始循环，DataGridView中从列开始循环。\n\n２．Excel中单元格的坐标从（1,1）为起始单元格，DataGridView中以（0,0）为起始单元格。\n\n如果对于代码还有哪些不理解或者想进一步了解相关类和方法的话，可以参考相关文章或者与我交流\n\n所谓好借好还，再接不难", "link": "http://blog.csdn.net/wangjinlong_/article/details/50992353", "publishDate": "2016-04-06 18:39", "title": "\r\n        【机房重构】——DataGridView导出Excel            \r\n        "}
{"readCount": "22", "article": "JDBCAPI为访问不同的数据库提供了一种统一的途径，就像ODBC一样，JDBC对开发者屏蔽了一些细节问题，同时，JDBC对数据库的访问也具有平台无关性。\n\nJNDI API被用于执行名字和目录服务。它提供了一致的模型用来存取和操作企业级的资源如DNS和LDAP，本地文件系统，或应用服务器中的对象。\n\nJ2ee技术之所以赢得全体广泛重视的原因之一就是EJB，他们提供了一个框架开发和实施分布式商务逻辑，由此很显著简化了具有可伸缩性和高度复杂的企业级应用开发。EJB规范定义了EJB组件何时如何与他们的容器继续拧交互作用。容器负责提供公用的服务，例如目录服务、事务管理、安全性、资源缓冲池以及容错性。但是注意的是，EJB并不是J2EE的唯一途径。正是由于EJB的开放性，使得有的厂商能够以一种和EJB平行的方式来达到同样的目的。\n\n正如其名字所表示的那样，RMI协议调用远程对象上方法。它使用了序列化方式在客户端和服务器端传递数据。RMI是一种被EJB使用的更底层的协议。\n\n在javaIDL的支持下，开发人员可以将Java和CORBA集成在一起。他们可以创建Java对象并使之可以在CORBAORB中展开，或者他们还可以创建Java类并做为和其他ORB一起展开的CORBA对象客户。后一种方法提供了另外一种途径，通过它可以被用于你的新的应用和旧系统相集成。\n\nJsp页面由html代码和嵌入其中的Java新代码所组成。服务器在页面被客户端所请求以后对这些java代码进行处理，然后将生成的html页面返回给客户端的浏览器。\n\nservlet是一种小型的java程序，它扩展了web服务器的功能。作为一种服务器端的应用，当被请求时开始执行，这和CGIPerl脚本很相似。Servlet提供的功能大多和jsp类似，不过实现方式不同。JSP通过大多数的html代码中嵌入少量的java代码，而servlet全部由java写成并生成相应的html。\n\nXML是一种可以用来定义其他标记语言的语言。它被用来在不同的商务过程中共享数据。XML的发展和Java是互相独立的，但是，它和java具有相同目标正是平台独立。通过java和xml的组合，我们可以得到一个完美的具有平台独立性的解决方案。\n\nMs是用于和面向消息的中间件相互通信的应用程序接口（API）。它既支持点对点的域，有支持发布/订阅类型的域，并且提供对下列类型的支持：经认可的消息传递，事务性消息传递，一致性消息和具有持久性的订阅者的支持。JMS还提供了另一种方式对您的应用与旧的后台系统相集成。\n\nJTS是CORBAOTS事务监控的基本实现。JTS规定了事务管理器的实现方式。该事务管理器是在高层支持Java TransactionAPI（JTA）规范，并且在较底层实现OMG OTS specification的java映像。JTS事务管理器为应用服务器、资源管理器、独立的应用以及通信资源管理器提供了事务服务。\n\nJavaMail是用于存取邮件服务的API，它提供了一套邮件服务器的抽象类。不仅支持SMTP服务器，也支持IMAP服务器。\n\nJavaMail利用JAF来处理MIME编码的邮件附件。MIME的字节流可以被转换成java对象，或者转换自Java对象。大多数应用都可以不需要直接使用JAF。", "link": "http://blog.csdn.net/onlybymyself/article/details/51175882", "publishDate": "2016-04-17 21:59", "title": "\r\n        J2EE            \r\n        "}
{"readCount": "29", "article": "", "link": "http://blog.csdn.net/zhanghan18333611647/article/details/51175697", "publishDate": "2016-04-17 22:53", "title": "\r\n        自考那些事儿：计算机网络原理（原理篇）            \r\n        "}
{"readCount": "35", "article": "资源管理是介绍公司信息资源如何管理提供理论的依据，计算机网络主要讲的是计算机内部数据传输，学习这两\n\n门知识感受很深刻。 昨天和今天，考完了这两门，答题效果不太好，能不能及格都不重要了，重要的是学习这两门\n\n信息资源管理学，了解了信息资源管理的基础，信息规划和组织，信息系统资源和内容管理，信息资源管理的标\n\n准与法规，信息资源安全管理。这门学科涵盖的知识点还是比较广，综合了多门学科的知识，主要有数据库原理，计\n\n息化，就是在国家统一规划和组织下，在农业，工业，科学技术，国防及社会生活各个方面应用现代化的信息技术，\n\n深入开发，广泛应用信息资源，加速国家实现现代化的进程，到2016年，将近20年的时间，国家和人民的生活发生了\n\n巨大的变化。20年前我在上小学，当时的农村面貌和现在比起来，发生了彻底的改变，人们的衣食住行都发生了颠覆\n\n性的变化。从这一点深刻感受到信息化给人们带来的巨大好处。\n\n公司的要快速发展离不开信息化的组织。小米的雷军，京东的刘强东，阿里巴巴的马云分享过他们创业的故事和\n\n历程，他们都无一不谈到他们信息化的过程，他们身上将信息视为企业生命之本。 其实，我也梦想着能和他们一样\n\n优秀，我也很好奇一个公司怎么能抓住良好的时机，脱颖而出，如果我有这样的机会，我该如何做？这本书给了我很\n\n机网络是计算机技术和通信技术相互渗透，密切结合而形成的一个新兴的交叉科学，是当今计算机科学与技术学\n\n科中发展最为迅速的领域之一，也是计算机应用领域中最为热门的技术之一，在当今信息时代，以Internet为代表的\n\n网络应用技术更加快速发展和网络经济空前繁荣的形式下，基于网络技术的电子商务，电子政务，远程教育，远程医\n\n疗等都在以前所未有的快速发展。学习本学科，了解了OSI参考模型以及他们各层的各种协议，数据传输原理，网络\n\n拥堵等相关知识，很有成绩感，为以后写代码，分析系统运行情况提供了很好的理论指导。\n\n考试让我学习了很多知识，成长了很多，多学习一些知识，就拓宽了一下视野，多了一个分析问题的角度，只有\n\n多学才能加快学习的脚步。 人生观，价值观都将因为视野的宽阔而改变。", "link": "http://blog.csdn.net/wangju2013/article/details/51174749", "publishDate": "2016-04-17 20:57", "title": "\r\n        学习信息资源管理和计算机网络有感            \r\n        "}
{"readCount": "15", "article": "T1的题目来源是去年十月份做NOIP模拟题和lcyz（聊城一中）胡策（其实也不算胡策，从他们那里要的题）的T3，T2是去年五月份学长带着我们在tyvj举办的有奖赛（http://www.tyvj.cn/Contest/187 and http://www.tyvj.cn/Contest/192）的某题。T3是上周六（2016.4.16）半夜躺在床上YY出来的原创题（出题一时爽系列）。\n\n赛前我觉得标算是NOIP算法可能被喷。然而这个题加个修改强行写树剖？并没有加大思维难度，而是多写了份模板…没意思啊\n\n然而看见大部分人都没写标算也A掉了，好像我想多了的样子…\n\n卧槽我出的辣么良心的部分分都被你们一眼标算给秒了…不开心TAT\n\n题意：给一棵树，每条边上有边权，每次询问一个点到一条路径上的某点的最大边权最小是多少。\n\n首先，若一条路径上多一条边，则最大值只会变大不会变小。所以题目变成询问c点到ab的简单路径的唯一路径上边权的最大值。现在问题在于如何求出目标路径的另一个端点。\n\n可以LCT。每次操作让c点为根，则另一个端点是a和b的lca，然后就可以提取路径了。\n\n作为出题人，表示并不喜欢这个做法…毫无思考难度，强行数据结构，很无聊。\n\nLCA。 \n\n 观察LCT的算法，可以发现是强行改变树结构然后找到另一个端点。静态的情况分类讨论一下就可以了。 \n\n 就这三种情况：\n\n就三种情况，有些路径会退化。我们发现只要区分出来这三种情况就可以了，路径另一个端点只和三个点两两的lca有关。\n\n然后第一张图是lca(a,c)=lca(b,c)，答案是c到lca(a,b)的最大值…其他同理\n\n题意：给一个trie树，它的子串定义为从任意一个节点向下走任意步走到某个节点所形成的字符串。要求支持：添加一个子树，询问一个串在树中出现几次，询问当前树有多少个本质不同的子串。\n\n发现每次长出子树的大小不会超过当前树的大小，这样可以暴力插入，和启发式合并的复杂度分析差不多，一个log。\n\nLCT维护一下par树，这样就可以log^2n的时间内维护添加子树。记录变量ans维护p -> val – p -> par -> val的和，trie上建立SAM，和普通的串上一样，dfs一下就行了。操作三把串在SAM上跑一遍就行了。", "link": "http://blog.csdn.net/loi_dqs/article/details/51193666", "publishDate": "2016-04-19 20:24", "title": "\r\n        【弱校胡策】2016.4.19 LCA+LCT+莫比乌斯反演+SAM+启发式合并            \r\n        "}
{"readCount": "33", "article": "2.if与else的配对关系，else总是与它上面最近的且配对的if配对。如果省略某一个else，可用{}括起该层的if语句来确定层次关系。\n\n通过这次c++上机实验，我学会了if-else if（多分支）语句的正确使用，改掉了每句语句结束不打分号的习惯，在if语句中，有重复的语句，可以放在最后else中，看着简便，方便理解。", "link": "http://blog.csdn.net/wly15629/article/details/51084064", "publishDate": "2016-04-07 11:03", "title": "\r\n        c++实验3-项目1--个人所得税计算器            \r\n        "}
{"readCount": "28", "article": "", "link": "http://blog.csdn.net/liyasong666888/article/details/51176399", "publishDate": "2016-04-17 23:11", "title": "\r\n        自考结束了            \r\n        "}
{"readCount": "3902", "article": "最近公司工作比较轻松，就把以前的项目 拿来整理下。以前在公司做视频社交这一块，类似于ＹＹ直播。\n\n首页第一个界面，这里可以看美女，看直播 \n\n \n\n 这是任务列界面，可以领取每日任务，任务分成长 和推荐 \n\n \n\n 好友列表 \n\n \n\n 用户的个人中心页 \n\n \n\n 直播间 \n\n \n\n 用户的个人中心页 \n\n \n\n 充值方式页 \n\n \n\n 银联支付页 \n\n\n\n这个项目主要的重点就两个地方，看视频，和 与主播互动。 \n\n 整个视频流是用ＲＴＭＰ协议的，文字聊天走的是openfire+asmack . \n\n PS：整个项目，我们产品设计的很不错的，只是我水平有限，有些功能 实现不了! \n\n 再介绍下，整个项目都用到了什么？ \n\n 程序框架：SlidingMenu+Viewpager+fragment \n\n 请求服务器： asynchttpclient \n\n 解析数据：Gson \n\n 消息推送： Jpush \n\n 页面数据分析： Umeng \n\n 充值方式： alipay +银联+yeepay+短信充值 \n\n 图片缓存： afinal \n\n 自定义view： Pulltoresfresh+拼音排序联系人+horizontallistview+verticalviewpager… \n\n\n\n另，我把公司的项目写出来，是因为公司的服务器停掉了，所以，一些数据，是我自己抓出其他应用里面的（抓取数据的方法，在上面一篇文章里）…. \n\n 首先就是整个项目最下面是mainactivity，这个大家是都有共识的，在mainactivity 上面 我们就要 引入slidingmenu， \n\n 关于slidingmenu的下载，就不介绍了，这里直接拿来用 \n\n 包结构比较清晰 \n\n ， \n\n 整个项目首先，由splashactivity 欢迎界面 ，进行检查，然后跳转到mainactivity，mainactivity 中包含slidingmenu，slidingmenu的中间界面 添加了viewpager，viewpager 里面添加了四个fragment。\n\n由于默认v4包里的viewpager 会默认混存数据，即使你设置了setOffscreenPageLimit（0），所以这里替换掉原生的v4包，并且通过fragment 的 setuservisibilityhint 方法来，控制 fragment 界面的动态刷新。\n\n主界面的第一个fragment ，也就是约美女的界面，通过fragmenttabhost,来实现约美女，和看直播的切换。 \n\n 在约美女中，就是一个简单地pulltorefreshlistview，适配了一个item.点击item 进入用户的个人中心， 个人中心 顶部 是个人的宣传适配，下面，是用户自己上传的 公开专辑，或者私密专辑。可以点赞，关注他。\n\n做任务界面是有两种任务，一种是 每日任务，就是 登陆，签到，另一种是下载app 得积分任务。 下载app 可以控制 下载 暂停。\n\n在我的关注界面。是你关注的好友，这个跟微信的联系人控件是一样的。首字母排序，用到了比较器。 \n\n 首先 把汉字，对应首字母提取出来，然后与A-Z 排序。以及特殊字符~。\n\n主要就是 oncreate 中 初始化 刚启动应用后中间显示的fragment 是 MainHallFragment.\n\n视频时RTMP 协议，解码用的ffmpeg. 代码就不贴了，在工程的jni 目录下，都有注释。\n\n这是 一初始化MultiUserChat 聊天室对象的代码，具体代码 ，在这个类里面。", "link": "http://blog.csdn.net/u011733020/article/details/46786471", "publishDate": "2015-07-07 11:27", "title": "\r\n        公司（视频 社交）项目分享            \r\n        "}
{"readCount": "31", "article": "自考之路已经接近尾声啦。一路走来，确实收获了很多。小编这周考的是信息资源管理和计算机网络原理这两门。要想功夫深，铁杵磨成针。可以说这两门考试好多东西都是书上面的概念之类的东西。这就需要我们在平常学习的时候编制自己的知识网。一点点的积累。经验之谈就不说了，希望这两门都能合格。\n\n还有就是三月下旬的保定之旅。在三月二十号左右去了趟河北大学，完成了自己的毕业答辩。自己也是一个河北大学的准应届毕业生了。如果这次的这两门考试都通过了的话，最后就剩下一门C++程序设计的理论课考试了。\n\n回顾自己的自考之路，非常精彩、非常充实、非常难忘。我们一起奋斗过的日子，充实又快乐。", "link": "http://blog.csdn.net/fengkungui/article/details/51176248", "publishDate": "2016-04-17 22:57", "title": "\r\n        【第四次自考】实战总结            \r\n        "}
{"readCount": "30428", "article": "", "link": "http://blog.csdn.net/harvic880925/article/details/38660861", "publishDate": "2014-08-18 15:03", "title": "\r\n        ViewPager 详解（五）-----使用Fragment实现ViewPager滑动            \r\n        "}
{"readCount": "60", "article": "指缝很宽，时间太瘦，悄悄从指缝间溜走。不知不觉今天已经完成了第四次自考。\n\n加上免考的科目自己已经过了11科了，先给自己鼓掌！看着这些挺开心的，想着如果没有意外的话今年10月份就可以完成全部的自考 科目，哈哈！就可以在家等着河北大学的毕业证啦！\n\n然而，今天就出现了意外！这两天考的科目——信息资源管理和计算机网络原理，oh my god!真的是从头蒙到尾啊！明天再来，等着我吧！", "link": "http://blog.csdn.net/wangnayu/article/details/51175146", "publishDate": "2016-04-17 20:45", "title": "\r\n        记第四次自考            \r\n        "}
{"readCount": "21", "article": "归并排序适用于外部排序，是一种稳定的排序。算法很很好的体现了分治法的思想。 \n\n 时间复杂度O(nlogn)(最好最坏平均都是它) \n\n 空间复杂度O(n) （如果使用的是链表，空间复杂度为O(1)）", "link": "http://blog.csdn.net/codetz/article/details/51184373", "publishDate": "2016-04-18 22:34", "title": "\r\n        归并排序的3种实现            \r\n        "}
{"readCount": "474", "article": "感谢所有人对“漫谈程序员”专栏的关注，是你们的支持让我有动力和热情持续叨叨下去，没成想这个专栏已经走过了将近两年的漫长旅程，感谢ing。\n\n去年的时候，应出版社邀请，将专栏内的部分文章结集出版，书名是《你好哇，程序员》。我还邀请了一位萌妹子为配了插画，她的微博是http://www.weibo.com/udspj，可以到那里一探会画漫画的二次元女程序员。\n\n《你好哇，程序员》，最了解程序猿的程序猿写的关于程序猿的书。我翻看了一下，看时有点儿恍惚，甚至怀疑这是我写的文章吗——风格和我现在的文章有明显差异，以前的文章，满满的开发生活味道，一本正经的不正经，现在的有点太正经了。\n\n需要说明的是，《你好哇，程序员》里的大部分文章都在我的博客及订阅号“程序视界”(programmer_sight)发布过，想看电子版的无须购买，部分未在博客和订阅号“程序视界”发布的文章，稍后也都会发布出来。\n\n另外4月9号，我在我的订阅号搞了一个活动，从出版社买了一些书，做了签名版，现在还有6本，感兴趣的可以加我微信（关注订阅号“程序视界”，回复foruok可获知联系方式）获取，或者看这里http://mp.weixin.qq.com/s?__biz=MzAxMzUzNzYyNA==&mid=403091500&idx=1&sn=48171b9eddcbabf020ded57252c621aa#rd，有说明。原价49，包邮带签名。\n\n书中文章，关注订阅号“程序视界”(programmer_sight)或专栏“漫谈程序员”可以查看，回头我会在订阅号里建一个“你好哇，程序员”专题，把所有书中出现的文章都放进去，敬请关注。", "link": "http://blog.csdn.net/foruok/article/details/51189466", "publishDate": "2016-04-19 13:07", "title": "\r\n        《你好哇，程序员》新鲜出炉            \r\n        "}
{"readCount": "15093", "article": "在做一个view背景特效的时候被坐标的各个获取方法搞晕了，几篇抄来抄去的博客也没弄很清楚。\n\n其实只要把下面这张图看明白就没问题了。\n\n获取自身的宽高的这两个方法很清楚，不用多说，获取坐标的这几个就有点混乱了。\n\n根据上面的图应该会比较容易明白，图中屏幕上放了一个ViewGroup布局，里面有个View控件\n\ngetTop：获取到的，是view自身的顶边到其父布局顶边的距离\n\ngetLeft：获取到的，是view自身的左边到其父布局左边的距离\n\ngetRight：获取到的，是view自身的右边到其父布局左边的距离\n\ngetBottom：获取到的，是view自身的底边到其父布局顶边的距离\n\n这些方法获取到的数据可以用在什么地方呢？\n\n比如要实现一个自定义的特殊布局，像http://blog.csdn.net/singwhatiwanna/article/details/42614953\n\n这里要实现的是一个水波纹特效布局，该布局内的任何控件点击后都会出现波纹效果\n\n\n\n那么在点击了布局内的一个控件之后，就要通过不断刷新布局，去更新这个控件上面的波纹半径，为了节省资源，每次刷新布局都时候不会整个布局都刷新，而只是通过\n\n在布局的画布上每次只去更新点击事件所点击的对应的控件的位置，那么这里就可以用view的那四个方法，分别获取自身的四条边对应的坐标\n\n当然博客中是使用绝对坐标去计算的，因为这里实现的是一个布局，可能里面还会嵌套另外的布局，经过多次嵌套之后所获取到的值，是相对于控件直接对应的父布局（这个布局有可能已经是我们重写的布局的子布局了）的距离，这样去刷新的区域肯定是不准确的，所以博客里面使用相对屏幕的绝对坐标计算需要刷新的控件区域。\n\n如果这里自定义的不是布局，而只是一个控件的话，就可以通过以上方法获取到坐标，然后要求自己所在的布局去重绘这一区域就可以了。当然这只是一种思路，其实没必要去要求布局重绘，完全可以直接view自身重绘就可以了。\n\ngetX()：获取点击事件相对控件左边的x轴坐标，即点击事件距离控件左边的距离\n\ngetY()：获取点击事件相对控件顶边的y轴坐标，即点击事件距离控件顶边的距离\n\ngetRawX()：获取点击事件相对整个屏幕左边的x轴坐标，即点击事件距离整个屏幕左边的距离\n\ngetRawY()：获取点击事件相对整个屏幕顶边的y轴坐标，即点击事件距离整个屏幕顶边的距离\n\ngetRawX和getRawY在之前那篇博客里广泛使用了，可以去那里看用法，getX()和getY()这两个方法在对view进行自定义的时候可能用的会比较多。", "link": "http://blog.csdn.net/jason0539/article/details/42743531", "publishDate": "2015-01-15 16:59", "title": "\r\n        android之View坐标系（view获取自身坐标的方法和点击事件中坐标的获取）            \r\n        "}
{"readCount": "622", "article": "当我们在onCreate()回调方法中去调用View的getWidth()、getHeight()、getTop()、getLeft()等方法的时候，是无法获取到正确值的，此时只会返回0。\n\n因为View的显示必须经历Measure（测量）、Layout（布局）和Draw（绘制）过程。而在Measure与Layout过程完成之后，View的width、height、top、left等属性才被正确赋值，此时我们才能获取到正确的值，这几个过程都晚于onCreate执行。\n\n解决方法一：用View.post()一个runnable就可以了：\n\n（UI线程消息队列会按顺序处理事件，在setContentView()被调用后，消息队列中会包含一个要求重新Layout的msg，所以任何你post到UI线程队列中的东西都会在Layout后执行。 \n\n\n\n（说明：在Activity得到或者失去焦点的时候，就会被调用。Activity初始化完毕准备显示的时候就会回调该方法。所以说，只要想做一些Activity加载完毕就马上触发的事情，都可以在这里执行。）\n\n（说明：视图树的可视性或全局布局状态发生变化时执行的回调函数，此时已经完成Layout过程，可能会被多次调用，所以获取完后就可以移除监听器）", "link": "http://blog.csdn.net/codezjx/article/details/45341309", "publishDate": "2015-04-28 20:08", "title": "\r\n        onCreate中View的width,height为0的问题            \r\n        "}
{"readCount": "1987", "article": "相信用过path app的人都会被其精美的效果给吸引到，作为一名用户，我首先被其吸引都的就是其时间轴下拉刷新后类似于ios的果冻效果。同时作为一名coder，我们更应该好奇它是怎么实现的。于是乎，在百度的指引下，并没有什么斩获，既然如此，那就由我们自己撸出来吧！\n\n下面看看我们自己撸出来的效果和path原装效果的区别吧。（注意重点在小球的果冻效果哦O(∩_∩)O）\n\n效果还是挺不错的。下面就开始撸代码之旅了~\n\n现在接着往下走（我当你已经学会画圆的技巧了`(∩_∩)′） \n\n OK,假设我们已经有个一个圆 \n\n ↓↓↓ \n\n\n\n→按照这个思路。说说我们的解决办法吧。 \n\n 下拉时我们的p1、p1.left、p1.right相关坐标改变 —->造成小球被拉伸效果 \n\n p2、p2.left、p2.right、p4.left、p4.right相关坐标改变 —->造成小球宽度变小，利用简谐振动函数造成小球回弹效果。 \n\n 要保持小球与竖线同时向下移动且之间距离不变则利用layout来改变即可\n\n其实有了之前下拉的分析，复位也几乎类似，唯一需要注意的是，小球移动到位置A后若继续下拉，则复位的位置不是0而是 （-移动到A位置后继续下拉的距离），这点需要好好注意下。\n\n这里我用的下拉回弹是在网上找到的一个pullscrollview，我做了些小修改（不过不可否认的是这个pullscrollview是有小bug的，这里为了演示就将就了，大家可以换成自己喜欢的下拉刷新库）\n\n正是这三个接口传递出的 y 让jellyball能根据滑动的距离做出相应的操作，实现jellyball与任一下拉刷新库的解耦。\n\n下面再来看看setType中的startRebounceAnim方法 \n\n 之所以这里用了动画，主要了想利用applyTransformation方法，该方法会自动计算setDuration中设定的时间此刻的时间流逝比，这样就省去了我们自己去计算的麻烦（当然，你如果不喜欢这种方法，你也可以自己写个定时器，自己计算时间流逝比）\n\n得到rebounceInterpolatedTime后，我们的回弹方法在ondraw方法中的rebounceAction方法中用到。 \n\n \n\n 该方法又会调用一系列这些方法 \n\n\n\n这些方法顾名思义可知是为了根据时间流逝比得到回弹的距离。 那么问题来了，怎么样让一个回弹距离是从大到小最后逐渐变为0呢？ \n\n 正弦、余弦函数？NO！看看函数图像就知道，并不会从大到小的变化（虽然最后会变成0） 那么答案是什么呢？ 我的答案是 \n\n 简谐振动函数（我怎么知道的呢？百度….） 地址就是 \n\n http://www.jcodecraeer.com/IOS/2015/0614/3038.html 大家可以去学习下。\n\n我用到的函数算式是 ((1 - Math.exp(-2 * (x + 0.052)) * Math.cos(20 * (x + \n\n 0.052))) - 1) * rebounceX / 3 * 2 之所以x需要+0.052是因为我测试算式时在这个https://www.desmos.com/calculator网站上看到当x=0.052时，算式得到的值才是0，若x=0，则算式值不是0（也就是我们其实的时候算式值有偏移量，这并不是我们想要的。） \n\n 而之所以是x+0.052,不是x-0.052，我想这得问你的高中数学老师了::>_<:: 截图，写代码写了一大串，终于算是撸出来我们想要的效果了！给自己一个赞！❤\n\n使用方法也超级简单，三行代码轻松搞定。（因为我把逻辑操作全部封装到了jellyball中，大家可以轻松使用到自己的下拉刷新库中了，只需要获取且暴露出自己下拉刷新库下拉和复位和刷新时的接口即可！） \n\n 在Mainacitivty中 \n\n\n\n代码可能会有点点乱糟糟，下一次我再把path刷新时的小球刷新的效果做出来再更新一遍代码好了。", "link": "http://blog.csdn.net/mr_immortalz/article/details/51137319", "publishDate": "2016-04-12 21:19", "title": "\r\n        "}
{"readCount": "552", "article": "今天主要来分享个自定义viewpagerindicator，效果主要是仿 猫眼电影 顶部的栏目切换，也就是我们常说的indicator,难度简单，为了让滑动时效果更炫酷，我在滑动到左边第一个item或者最右边的item时，添加了滑动到边缘位置后，回弹然后复位的效果（其实也是很简单，只要计算好距离就好啦） \n\n 大致的效果图就是这样。大家可以凑合看看（可以看到当滑动到边缘位置的时候有回弹的效果，是不是挺带感的O(∩_∩)O） \n\n\n\n很明显，核心代码在ViewPagerIndicator中，因为代码中已经对每个函数方法给出了注释，下面说下大体思路。\n\n1.首先init()，onMeasure中对paint，width,height等必不可少的数据进行获取。 \n\n 2.因为整个indicator是继承自linearlayout，对于里面的文字展示，用textview来显示，因为不知道用户使用的时候到底有多少个item，所以在setDatas()方法中对textview数目进行绑定。然后在onSizeChanged中动态生成需要的textview数目（isSetData用来控制是否绑定了数据，绑定了的话，需要将之前所有生成的全部清空）\n\n只所以在onsizechanged中动态添加，是因为该方法会在ondraw前，onMeasure方法后回调，这样就保证我们能获取到需要的width,height。 \n\n \n\n 3.Ok,现在获取到需要绘制的数目后接下来就是绘制白色背景框框啦。\n\n很好理解，不解释`(∩_∩)′ \n\n 4.接下来，最最关键的就是setViewPager()这个方法。 \n\n 为了方便理解，大家可以看看 \n\n onPageScrolled（页面滚动时回调） \n\n onPageSelected（滑动松手后回调，在一个滑动流程中只会回调一次） \n\n onPageScrollStateChanged（在一个滑动流程中会回调三次，具体代表含义可以看图中标注） \n\n 这三个方法滑动时，具体回调顺序。 \n\n 从第一个item向右滑动到第二个item \n\n \n\n 从第二个item滑动到第一个item（无论左滑还是右滑回调流程都一致） \n\n \n\n 知道了上面我们就应该很好理解了。\n\n下面在详细说说onPageScrolled。 \n\n onPageScrolled中也有三个判断\n\n1.处于最左边item且手滑动松开 \n\n 2.处于最右边item且手滑动松开 \n\n 3.其他item不管手是否滑动松开（这里用rebounceOffset记录手松开时，已经拖动的比例positionOffset）\n\n分析第一种情况。 \n\n 为了实现回弹。在松手后的（positionOffset-0 ） 的时间段呢，分成三部分 \n\n 看图 \n\n\n\n分析第二种情况（剩余时间（positionOffset - 1 ）也是分成了三部分，一部分回到边缘，一部分偏移，一部分用于复位，与第一种情况相似，不再贴图），当item滑向最有边缘时，与第一种情况不同的是，Linearlayout是需要向左移动的，所以liearlayout向左移动了X，我们绘制的白色边框需要向右移动X，才能保证，视觉上看起来白色边框没有动，动的是，我们的Linearlayout(不知道大家能理解不，可能我说的有点不太好理解，用纸好好绘制下简单理解些`(∩_∩)′)\n\nOK，三种情况都分析完毕。最后我们的控件也算是大功告成啦`(∩_∩)′", "link": "http://blog.csdn.net/mr_immortalz/article/details/50981449", "publishDate": "2016-03-25 16:14", "title": "\r\n        自定义ViewpagerIndicator （仿猫眼，添加边缘回弹滚动效果）            \r\n        "}
{"readCount": "430", "article": "玩过微信的都知道，微信用的是懒加载的模式，之所以使用懒加载是因为：当使用viewpager+adapter作为应用大的布局时，viewpager会通过setOffscreenPageLimit来设置预加载的项目，不设置setOffscreenPageLimit，则默认为1（设置0无效，可以查看该方法源码知道），也就是当我们打开应用看到的时候fragmentOne时，实际上其他fragment（例如fragmentSecond）也进行了加载，只不过没有显示出来罢了，但是这样就造成了不必要的资源浪费（例如，fragmentSecond没有显示，但是却进行了大量的网络加载操作）。 \n\n \n\n 基于上述情况，就有了懒加载方式的诞生（即只加载当前显示页面且只加载一次，滑动到其他页面时才加载其他页面数据，当再滑动到已加载过数据的页面时不再进行数据加载操作，若想要刷新数据，再调用相应的加载数据方法就好了）\n\n为了更好的知道懒加载的实现原理,下面通过几个测试来学习下。 \n\n 测试的几个文件如下 \n\n （可以看到有3个fragment，由FragmentPagerAdapter+viewpager构成）\n\n可以看到无论是情况一还是情况二,fragment都会调用fragment的setUserVisibleHint进行判断，所以我们就需要在这里做文章。 \n\n\n\n1.当isVisibleToUser 为true则进行数据加载，当isVisibleToUser为false则不进行数据加载 2.对于已经加载过数据的fragment，再次被滑动到也不在进行加载数据，也就是每个fragment仅做一次数据加载工作\n\n下面就来看代码实现 \n\n 主要代码都在BaseFragment中，整个项目大家可以在最后给出的地址处下载\n\n可以看到initView方法是在onCreateView中调用，而initData只有执行过onCreateView才会调用，这样的顺序安排就不会导致在initData中执行数据加载过程，找不到需要的view而报错。\n\n可以看到fragment只会进行执行一次initData，懒加载到此完整，下一篇将在此基础上进行高仿微信的效果", "link": "http://blog.csdn.net/mr_immortalz/article/details/51015196", "publishDate": "2016-03-30 15:27", "title": "\r\n        Fragment实现懒加载，让应用更优化            \r\n        "}
{"readCount": "108", "article": "Android的消息机制主要是指Handler的运行机制，Handler的运行需要底层的MessageQueue和Looper的支撑。 \n\n 大致的运行过程如下图 \n\n \n\n 这里以UI线程（即主线程）与其他线程的交互为例。\n\nLooper会以无限循环的方式去查找是否有新的消息（Message），有则处理，没有则等待。 Handler用于post消息（Message）给其他线程，并完成从其他线程到UI主线程的调转\n\n综上可知 除了Handler运行在主线程，其他三个（MessageQueue,Looper,ThreadLocal运行在子主线程） \n\n 为了更好的理解运行时的关系。我们对这四者分别介绍，最后再做总结。\n\n由上图可知，Handler要想将消息投递给子线程，则必须投递到该子线程对应的Looper中。那么对于一个Handler来说，我怎么知道，我投递的消息是否投递到了A线程，而不是B线程呢，换句话说，Handler又是怎么和我想要的Looper建立起联系的呢？答案就是ThreadLocal！也正是ThreadLocal的存在，让队列与线程关联上了！\n\nThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储后，只有在指定的线程中才可以获取到该数据，其他线程无法获取（换而言之，当某些数据是以线程为作用域并且不同线程具有不同的数据副本时，就可以考虑使用ThreadLocal）。例如：对于Handler来说，它需要获取当前线程的Looper，很显然Looper的作用域就是线程并且不同线程具有不同的Looper,这个时候通过ThreadLocal就可以让Handler轻松获取到想要线程的Looper，从而进行其他操作。（之所以说轻松，是因为如果不采用ThreadLocal的方式来获取Looper，系统为了让Handler来得到想要的线程的Looper，则必须提供一个全局的哈希表供Handler查找指定线程的Looper,这样一来就必须提供一个类似LooperManager的类的管理，增加了使用成本）\n\nThreadLocal其他场景下作用 \n\n ThreadLocal另一个使用场景是复杂逻辑下的对象传递，比如监听器的传递，有些时候一个线程中的任务过于复杂，这可能表现为函数调用栈比较深以及代码入口的多样性，在这种情况下，我们又需要监听器能够贯穿整个线程的执行过程，这个时候可以怎么做呢？其实就可以采用ThreadLocal，采用ThreadLocal可以让监听器作为线程内的全局对象而存在，在线程内部只要通过get方法就可以获取到监听器。而如果不采用ThreadLocal，那么我们能想到的可能是如下两种方法：第一种方法是将监听器通过参数的形式在函数调用栈中进行传递，第二种方法就是将监听器作为静态变量供线程访问。上述这两种方法都是有局限性的。第一种方法的问题时当函数调用栈很深的时候，通过函数参数来传递监听器对象这几乎是不可接受的，这会让程序的设计看起来很糟糕。第二种方法是可以接受的，但是这种状态是不具有可扩充性的，比如如果同时有两个线程在执行，那么就需要提供两个静态的监听器对象，如果有10个线程在并发执行呢？提供10个静态的监听器对象？这显然是不可思议的，而采用ThreadLocal每个监听器对象都在自己的线程内部存储，根据就不会有方法2的这种问题。\n\n这里任玉刚大神也在http://blog.csdn.net/singwhatiwanna/article/details/48350919博客中给出了一个例子，正如大神所言：\n\n这里看看hongyang大神对Looper两个主要方法prepare(),loop()的分析（截图上是我的理解）\n\n消息的发送可以用过post或send一系列方法来实现，而post的一系列方法最终是通过send一系列方法来实现的。\n\n由上可知，Handler发送消息仅仅是想消息队列插入了一条消息。MessQueue的next方法会返回这条消息给Looper,Looper经过取消息将取得的消息交给Handler处理，即", "link": "http://blog.csdn.net/mr_immortalz/article/details/51066869", "publishDate": "2016-04-05 18:20", "title": "\r\n        "}
{"readCount": "2942", "article": "当你用Sharepoint Designer 做好一个工作流，并且勾选更改和新建的时候启动工作流。希望 我们每次都能够自动启动相关的工作流，完成之后，我们来试试看：\n\n却发现工作流不会启动，当我们去手动启动工作流的时候，发现却可以启动：\n\n这是什么原因呢？其实原因很简单，因为以站点管理员身份登录的用户是不会自动启动工作流的，我们需要以别的身份登录创建才可以启动，接下来我们以普通用户登录看看：\n\n所以记得在测试的时候不要以站点集管理员去测试。", "link": "http://blog.csdn.net/fogyisland2000/article/details/51166366", "publishDate": "2016-04-16 10:04", "title": "\r\n        SharePoint 工作流无法启动？            \r\n        "}
{"readCount": "14422", "article": "今天到达杭州客户现场拜访，客户看到我来非常HAPPY，寒暄之后突然想起他们一个问题，希望能够帮忙处理！状况如下，SVCHOST和WMIPRVSE 这两个服务一共站到了\n\n我们可以发现这三个进程占用的CPU很高，差不多占用了90%以上的内存了。这什么原因呢？我们通过Sysinternal 工具的processexplorer .来查看具体进程，发现WMI进程中占用系统资源比较大的是WMI 的 NETWORK SERVICE\n\n在对比下系统资源管理器，我们发现系统资源占用比较大的是来自于网络服务，经过初步判断，我认为这是来自于网络对于这台AD服务器的WMI调用导致CPU占用率偏高：\n\n接下来我需要确定下这个进程中WINPRVSE 与SVChost 的关联关系，我采用如下的命令 tasklist /svc 可以得出当前以服务模式的应用关联的PID及应用\n\n安装好了以后，我们利用网络数据分析数据包，选择好相应的网卡：\n\n在当前界面Capture,抓取与这台机器相关的数据包，点击Start 开始抓取：\n\n然后我们停止抓取，点击上面PID对应的SVCHOST进程，这个PID 是前面我们用tasklist /svc 查到的进程。\n\n来源找到了，上面是一张演示图片，不是真实的环境。我们在真实的环境中发现，他们目前的一个验证设备会与这台机器不断的进行WMI查询。在这台设备上取消与这台机器关联后，我们发现CPU立即降下来了。", "link": "http://blog.csdn.net/fogyisland2000/article/details/7930810", "publishDate": "2012-08-31 21:57", "title": "\r\n        WMI 查询服务导致服务器CPU非常高！            \r\n        "}
{"readCount": "13928", "article": "最近从网上下载了所谓的2000W的开房数据，我不会告诉你从哪里下载的，因为那是犯罪滴，给大家过过眼瘾就好了。\n\n仔细分析了下数据，发现表的内容其实不像是酒店的开房流水表，而是所谓的会员数据，能够达到2000万的数据，这是很恐怖的一件事情，我怀疑这个不仅仅是某单个会员数据库泄露，你想想如果全国2000万的用户都办理了某个酒店会员，这是多恐怖的一件事情，所以这个应该是某个系统的数据，我更加认为！单单分析下目前的这个数据表中的数据，貌似数据的内容没有开房的时间，只有信息录入的时间，因此从这个看来可能不是所谓的开房记录，，可能真的如别人评论所说的会员数据库，相应记录的时间也只是登录的时间。\n\n那么大家最在意的可能是怎么从这些CSV 记录中找下看下自己在不在里面呢？\n\n这下大家估计有很多办法，有的人把这些数据导入SQL 数据库，也有人用Ultraedit.有的人还用别的很多方法。\n\n这里有一个很简单的方法，就是利用Powershell,PS的强大功能能够帮我们处理我们需要看到的数据，那从一大堆的文件中找到自己的那个记录更简单，简而言之可以用如下的命令去这庞大的数据中找自己的记录：\n\nget-childitem |select-string -pattern \"360425**********\"       后面身份证我就不说太多了，我想找找看，在这些记录中是否存在我的会员记录呢？好，跑一跑：\n\n3-4分钟后，结果跑出来结果说明了一切，这个数据库还真是很有用的，虽然不是所谓的开房记录，但是对于个人，这太危险。对于泄露的信息，我只能说一句，我去。。。。。\n\n这里还是希望大家能够保住自己的一些隐私，否则带来的后果不堪设想啊，这里提供一种快速的方法供大家查询相关信息，不要把这个用到坏处去哦，否则 俺良心不安！\n\n", "link": "http://blog.csdn.net/fogyisland2000/article/details/13017949", "publishDate": "2013-10-25 23:29", "title": "\r\n        利用Powrshell 查看在2000万信息中看看自己在不在所谓的开房信息中！            \r\n        "}
{"readCount": "11337", "article": "博客是大家的分享自己的技术的场所，我估计很多朋友也想知道自己的博客的内容是否和大家期待访问的内容一样，或者有什么相对访问量比较高的内容可以针对写一些？\n\n因为目前我的所有的内容都是在CSDN 上面，我们就以CSDN的方法给大家来讲一下怎么来将腾讯和百度的统计功能加入到我们博客中来。我们按照如下的步骤进行操作：\n\n8. 添加完成后，过一会登陆腾讯分析网站我们就可以看到所有的分析数据了，虽然数据不完全准确，但是也可以作为一个参考，特别关键词：\n\n9. 我们通过查看相应的页面，可以看到具体的信息，这就是添加腾讯分析达到的目的，下次我们添加百度的统计功能嵌入到博客功能，提供访问的具体数据：", "link": "http://blog.csdn.net/fogyisland2000/article/details/51152880", "publishDate": "2016-04-14 17:20", "title": "\r\n        如何获取到我们博客的访问数据之腾讯分析网站            \r\n        "}
{"readCount": "10428", "article": "7.      由于这里是默认的机器上，所以直接点击下一步\n\n\n\n11.   如果安装的机器是在DC上面会有如下提示\n\n4.      在安全选项卡中，.在用户中选择GALSYNC添加到用户当中并确认用户具有同步复制和同步复制更改的允许已经勾选上。\n\nB.             写入用户的proxy address 源域的属性必须进行权限设定，这个MMC默认不会安装，必须安装Windows 2003的Support Tool 后才可以使用，以下为实现步骤\n\n2.     展开DOMAIN，找到需要进行存放对方联系人的OU，如果有多个同步来源，Microsoft或者英业达在不同的OU则需要做两次操作\n\n4.     打开对方域所同步的OU，这里是 CONTACT\n\nH．点击下一步，设定Source和Target. Source来源选择需要进行同步的用户，Target选择Contact OU即可。\n\nI．添加SMTP Address为本地域的地址。点击下一步\n\nL. 选择默认的注意Contact user和GROUP三个的 RULE Extension\n\nO．选择默认继续下一步，确认下面的选项被选择\n\nH．点击下一步，设定Source和Target. Source来源选择需要进行同步的用户，Target选择Contact OU即可。\n\nI．添加SMTP Address为本地域的地址。点击下一步\n\nL. 选择默认的注意Contact user和GROUP三个的 RULE Extension\n\nO．选择默认继续下一步，确认下面的选项被选择\n\nB.完成后，我们在相互的OU中能够看到相应的联系人\n\nC．利用OUTLOOK登陆后，查看相应结果如下，旁边有个地球的为联系人，其他为用户：\n\nB.导出完成后可以见到4个文件，利用批处理将四个文件打包在一起，然后定期执行，即可完成增量的变化及变更操作。", "link": "http://blog.csdn.net/fogyisland2000/article/details/7818684", "publishDate": "2012-08-01 15:55", "title": "\r\n        使用IIFP同步两个不同域的GAL进行同步！            \r\n        "}
{"readCount": "10311", "article": "\n\n \n\n \n\n \n\n\n\n 上面的限制，邮件中的附件总大小受到 的限制，但是邮件中的一个附件的大小受到 。其次是一个单独的邮件的大小限制。 \n\n \n\n \n\n\n\n \n\n ）、设置单个附件大小。这是邮件限制里面的最高权限，它与服务器无关，只和 \n\n ）、使用者信箱传送大小的限制和接收大小的限制 \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n\n\n \n\n \n\n\n\n\n\n ）之间的权限相等，以最小值来限制单个邮件的大小 \n\n 后未设置邮件大小，则单个邮件的大小默认值会被限制在 \n\n\n\n ）、使用者邮箱传输大小的限制和接收大小的限制，不用修改，保持默认的不限制就好了，单独设置了邮箱传输大小限制是无法发送大邮件的，它是限定条件之一。如果要修改 \n\n \n\n\n\n ）全局限制，单独设置了全局限制是无法发送大邮件的，它是限定条件之一。 \n\n \n\n \n\n \n\n \n\n \n\n \n\n ）、接收连接器，单独设置了接收连接器是无法发送大邮件，它是限定条件之一 \n\n \n\n \n\n 得到所有的接收连接器的名称（其实就是在 \n\n \n\n \n\n \n\n ）、发送连接器，单独设置了接收连接器是无法发送大邮件的，它是限定条件之一 \n\n 的发送连接器在默认安装情况下，在安装集线器传输服务器角色或边缘传输服务器角色时，不创建任何 发送连接器，而是使用基于 站点拓扑自动计算的 发送连接器在集线器传输服务器之间以内部方式路由邮件。在 上是看不到发送连接器的，即使使用 \n\n 的集线器传输服务器或未订阅的边缘传输服务器必须手动配置发送连接器。所以我们必须要手动添加后再配置它。 \n\n \n\n \n\n \n\n \n\n \n\n 的服务器发送邮件；内部是给域内用的； 记录来路由；伙伴是给纳入了安全域列表的伙伴域的服务器用的。我是内部使用，所以选了第二项内部； \n\n \n\n \n\n \n\n \n\n 作用域发送连接器，限制发送连接器的作用域，勾选后只给域内传输服务器使用，我保持默认没有勾选。 \n\n \n\n \n\n \n\n\n\n \n\n \n\n 中的命令为（假设建立的连接器名字叫做 \n\n \n\n\n\n \n\n \n\n\n\n \n\n \n\n \n\n \n\n \n\n \n\n\n\n\n\n\n\n \n\n\n\n \n\n", "link": "http://blog.csdn.net/fogyisland2000/article/details/6226677", "publishDate": "2011-03-06 11:21", "title": "\r\n        配置邮箱和邮件大小限制 !            \r\n        "}
{"readCount": "9580", "article": "1.   很遗憾，在office 2016 版本中已经将表单功能移除，office 2013 版本已经成了infopath 绝唱，所以我们必须安装office 2013 版本的office Professional plus来完成我们的表单组件安装：\n\n3.   这里我们可以创建多种表单，我们这次做一个简单的案例，建立一个标准的空白表单后点击设计后进入到相应的表单设计界面，我们先设计好整个页面的布局：\n\n13.  输入表单库的地址，他会弹出验证信息，输入我们的账户名和密码：\n\n14.  选择employee 后，设置需要接受的数据。点击下一步：\n\n15.  不需要点击缓存数据，直接就可以点击下一步了：\n\n20.  接下来我们来添加按钮，来提交相关的信息：\n\n21.  接下来我们来启用提交信息，这里面我们用电子邮件传送信息，我们也可以提交为附件转发相关信息，关于提交到Sharepoint 文档库，我们通过案例给大家详细解释了，这里我们就不做过多的例子：\n\n22.  多数情况下我们的业务存在多个页面，不可能吧所有的业务数据全部在一个页面中全部展开，所以我们需要创建新的视图：\n\n27.  接下来我们需要在客户端为表单启用兼容性选项，来保证表单兼容浏览器打开了，点击检查方案：\n\n36.  好了，我们接下来需要发布表单到表单库地址，我们点击发布：\n\n我们看到数据已经提交到了相应的地方了。到此整个过程已经完毕，infopath 功能设定基本完成。", "link": "http://blog.csdn.net/fogyisland2000/article/details/51138580", "publishDate": "2016-04-13 00:14", "title": "\r\n        Sharepoint构建轻量型应用之InfoPath的简单应用案例！            \r\n        "}
{"readCount": "8369", "article": "我们以嘉昊信息为背景作为此次我们MOSS 系统的背景，实现基于MOSS系统的招聘构建。\n\n最上层是我们的老板，中层包含部门经理和HR 经理，而我们的最下层是我们的前台接待和我们招聘专员。\n\n招聘专员负责发出面试邀请，同时作为第一轮面试的筛选人员和面试人员，同时负责初试面试结果的通知，复试面试的通知和第三轮面试通知及入职通知等等事项。\n\n而我们的HR 部门经理基本上作为第二轮面试的参与人员，与部门经理一起面试面试者，而BOSS针对的是中高层的职位面试。只有在第三轮出现，因此整个业务流程如下，经过了第一轮进入到第二轮，否则通知未录取。第二轮通过后如果是普通职位，则进入入职流程，否则通知未录取。高级职位进入到第三轮，可能由总监级别人士面试。所以我们的面试的流程如下：\n\n我们所有的表单及工作流程会完全按照这个方式来走。从表单设计这块来看，我们会设计如下的表单界面：\n\n在这个界面我们的HR 专员填入我们的面试人的基本信息，便于后面我们在面试各个过程中提取到相应的信息。\n\n这里是我们的HR人事专员面试界面，我们可以在这里对于面试者印象做一个评分，并且将基本信息从通知界面拉取过来。\n\nb.   通知通过初试，并确定复试日期。同时会发送给我们的前台、部门经理和HR经理。\n\n6.   三试面试页面，这里是总经理面试的相关界面，这里面是我们总经理及相关的印象\n\n8.   隐含参数界面，这部分主要涉及到我们的页面切换，及我们的参数传递到我们的Designer,因此必须在这里设置我们隐含的参数，保证页面在不同的用户进来之后看到不同的界面。\n\n我们的表单基本上就上面的这些表单了，接下来我们就需要使用SharePointDesigner 来实现我们的数据业务流转了。", "link": "http://blog.csdn.net/fogyisland2000/article/details/51161749", "publishDate": "2016-04-15 14:57", "title": "\r\n        SharePoint 构建轻量化应用之招聘业务背景及业务流程分析！            \r\n        "}
{"readCount": "8017", "article": "但是针对前端，大家的概念在很多情况下模糊起来.什么是CAS ARRAY？什么是NLB？这两者有神马关系呢？我们现在就此讨论下。\n\n目前网上博客流行的前端高可用部署方案都是CAS Array+NLB,因此在很多人思维里面意味着我如果要做CAS ARRAY，就要做NLB。我做NLB，我就必须要做CAS ARRAY。\n\n这两种观点其实都是有失偏颇的。严格来说CAS ARRAY 与NLB 并没有太大的关系。他们只是高可用的结合方式的一种！\n\n什么是CAS Array，CAS Array 是否必须呢？\n\n 严格来说，企业内部部署CAS ARRAY 不是必须的前端高可用解决方案，我们知道如果不部署CAS ARRAY的话，访问节点可用的点也是可以对数据库进行访问的。部署CAS ARRAY\n\n 是为了统一访问企业内部访问节点。比如我有两台前端服务器，分别是MX1和MX2.这两台机器的节点名称分别是MX1和MX2，这在数据库的访问体现上是无法统一的。\n\n 我们为了统一数据库的访问节点，就必须建立相应的CAS Array。建立CAS ARRAY 我们必须将相应的内网所有的地址统一的变更为CAS ARRAY 名称，否则利用EWS进行EX链接的服务\n\n 器会发生问题，如果大家碰到过的话就知道outlook 2011 MAC 是采用EWS目录的方式访问Exchange 服务器，这也意味着如果不统一访问点的话，通过MAC访问的话则会发现访问点\n\n 会发生奇怪的跳转。\n\n 所以，我们说CAS Array 基本上是同一我们用户的访问入口点。\n\n他是通过硬件设备来负载目前各台前端服务器的相应的压力负载，硬件负载均衡器相对其他种类负载均衡的好处在于我可以利用硬件负载均衡器监控各个端口状态与安全。同时我可以\n\n 控制客户端对于一台机器的访问。我们可以添加相应的多个服务器的端口来了解服务器中某个服务是否正常来决定是否将相应请求转发到相应的服务器对象 。硬件负载均衡器有多种负\n\n 载均衡方式，来通过计算不同的结果来达到相应的硬件负载均衡的最终目的。详细结果如下下图所示，当其中的某个端口出现问题，我们可以将请求不在转发到这台机器。\n\nNLB是利用Windows 系统模拟出来的一种高可用模式，他的优势在于保证在机器不宕机的情况下保证了服务可持续性，但是缺点也非常明显，当其中的服务器并没有宕机，而是其中的某个\n\n 服务出现了停止或者假死的情况的情况下是无法进行高可用切换的，也就是说他无法判断端口的健康状态。这是一种折中性的高可用解决方案，我们在无法实现硬件负载均衡的模式下\n\n 采用NLB 可以达到基于主机的高可用结果，他的模式如下：\n\n\n\n 第三种是我们在项目中也采用的 Dns RR 方式\n\nDNS RR 是一种软性的高可用方式，在客户端我们利用DNS的轮询方式将目标服务器的IP地址返回给相应的客户端，然后客户端根据获取的IP地址任意的选择一台服务器来实现链接，利用\n\n DNS RR 实现的软性负载均衡方案存在的缺点在于无法监控相应的服务器的端口状态及主机状态，因此当机器出现问题的时候我们必须手动的干预才能达到真正意义上的高可用。严格来说\n\n 他不是一种负载均衡方案，他访问服务器的IP是相应的随机选择，因此不会根据当前服务器负载而分摊相应的压力，而是高可用的一种方案。他的工作模式如下：\n\n因此我们可以得出结论，CAS Array 的功能是统一访问的节点名称。而各类高可用方案是CAS ARRAY的具体实现。\n\n在某种程度上，如果您的预算比较多，推荐您采用硬件均衡器方案。如果您的预算有限，我们推荐您采用DNS RR方案。不推荐您采用NLB的方式来实现高可用！", "link": "http://blog.csdn.net/fogyisland2000/article/details/7935620", "publishDate": "2012-09-02 21:55", "title": "\r\n        关于Exchange 2010前端服务器的高可用模式！            \r\n        "}
{"readCount": "7360", "article": "最近比较多的人问到一个问题。我为什么在客户端勾选缓存模式就没有办法查看到我最近更新的人？\n\n而且如果我去掉了缓存模式则没有问题，当我勾选了缓存模式则没有太大问题，而且Outlook 2003 不会出现什么问题，而且服务器是Exchange 2003也没有问题，出现问题多的是服务器是Exchange 2007和Exchange 2010客户端多是Outlook 2007 和outlook 2010?\n\n首先，这是因为Exchange 2007 之后的脱机地址簿不在存放咋公用文件夹数据库中，而是以HTTP方式存放在服务器端的一个文件夹中。如果我们采用公用文件夹的方式发布的话，则不会出现类似的问题。\n\n而在Exchange 2007 之后的版本，我们来看他们发布脱机地址簿的方式：\n\n我们可以看到可以发布到公用文件夹和WEB的分发方式。公用文件夹发布方式一般适合OUT2003版本，而后期版本则采用HTTP的 BITS服务来实现后台的数据传送方式进行传输！当客户端禁用了BITS服务则会出现错误。所以当你客户端报错的时候可能要留意这个。\n\n另外我们知道离线地址簿与数据库也有关系，如果你的数据库没有指定离线地址簿的话，则会通过在线的方式进行用户查询地址簿：\n\n另外提到的一个问题，就是为何脱机地址簿无法更新呢？这里的话我们要了解从地址簿更新到客户端下载的过程是怎样的，我们先来看下\n\n从上图看来，我们知道从建立用户到用户的地址簿传递到客户端是一共需要5个步骤，一般来说生成GAL的不需要太长的时间，因此大部分用户在建立完用户不久后就能查看到该新建用户的信息.但是从GAL 同步到客户端需要经过的步骤是比较久的，我们依次来看看：\n\n1. 邮箱角色生成（更新）脱机地址簿信息可以通过以下PS 命令来完成，它是由系统助理每天晚上1点左右来更新：\n\n生成后的路径我们可以查看Mailbox角色中的路径是否生成了Exchange OAB 来确定，因为我们生成服务器为mail,因此我们需要去Mail这台服务器，找到这台服务器的安装目录：\n\n接下来我们需要将数据同步到OAB的目录中，GUI界面我们通过查询OAB轮询时间来确定：\n\n如果我们需要将OAB的文件同步到多台CAS服务器，我们则需要运行如下的命令：\n\nOK，经历到此后，我们的服务器端已经更新完毕！从这边来看，我们基本上服务器已经OK了，现在从客户端下载相应的OAB文件，下载完就可以更新了。另外每次重启UTLOOK 都会自动去下载OAB，如果出现相关的错误，你可能需要关心下相应的设定是否OK！", "link": "http://blog.csdn.net/fogyisland2000/article/details/8097941", "publishDate": "2012-10-22 11:57", "title": "\r\n        谈谈OAB离线地址簿无法更新问题？（服务器是Exchange 2007和Exchange 2010)            \r\n        "}
{"readCount": "6804", "article": "1.     完成以上所有的步骤之后，我们就完成了整个账户移动的过程，接下来我们就可以把Exchange 2003 卸载了，卸载的步骤不是很繁琐，我们可以按照如下的步骤完成,首先我们登陆到Ex 2003服务器：\n\n3.     在AD上运行adsiedit.msc,然后定位到收件人更新服务，由于Exchange 2010 已经不通过更新服务来更新地址，所以Exchange 2003 的更新服务没有存在的必要，所以我们直接将这两个服务删除，我们登陆到2008 R2的AD服务器，打开adsiedit.msc ,然后导航到配置后点击确定：\n\n7.     接下来我们停止EX03-EX10之间的邮件互发，我们必须删除掉之间的路由器，我们通过执行以下的命令来删除路由连接器。在弹出的确认选择A删除全部即可完成路由组连接器：\n\n", "link": "http://blog.csdn.net/fogyisland2000/article/details/7487182", "publishDate": "2012-04-23 09:51", "title": "\r\n        Exchange 2003升级到Exchange 2010之Exchange 2003的卸载！            \r\n        "}
{"readCount": "3895", "article": "最近一直都在研究powershell 自动化，我属于入门级别，当然不能和牛人比了，有些时候照着葫芦画瓢。画了一些针对exchange  一些功能做相应的定制，如果这些功能是你喜欢的，我非常 happy,如果不喜欢，请不要喷，谢谢！因为这些代码都是我一个一个敲进去的。\n\npowershell 脚本我已经0积分方式放在csdn下载里面了，当然大家希望了解神马功能，也可以和我说说，看下能不能帮大家实现相应的功能。这个powersshell 脚本怎么使用呢？\n\n他一共有四个开关，四个开关对应的是四个不同的功能：\n\n第一个目的是查询各台服务器发送的邮件数量，执行方法如下：\n\n结果如下，他会在默认的c盘生成一个文件夹，文件夹内有当天的邮件服务器发送数量：\n\n第二个开关针对的是邮件服务器计算发送失败的邮件，并且将失败的邮件生成csv 文件，执行方式如下：\n\n在我们的目录下会生成如下的文件，记录发送失败的邮件：\n\n第三个参数针对的是我们发送的这个对象的一定时间内发送接受邮件的数量，包括他在一定的时间段接受的邮件和发送邮件数量，同时还将发送和接受的时间、标题等记录下来，以便用户能够进行相应的查询：\n\n1. 指定用户在这段时间总的收发邮件的量\n\n放到 excel 即可清楚的看到用户在某个时间点是否发送或者接受过相应的邮件！\n\n第四个参数是统计发送邮件的量的总和并进行数量排序，执行命令如下：", "link": "http://blog.csdn.net/fogyisland2000/article/details/10217873", "publishDate": "2013-08-23 19:29", "title": "\r\n        使用基于Exchange 的powershell 代码Exchange 2010 Ps 整合message tracking 功能！            \r\n        "}
{"readCount": "1254", "article": "学习进入到攻坚期，目前我的学习方法还是通过不停的通过各种视频学习来了解JAVA 和Android.\n\n这里有个比较好的找资料的地方。\n\n另外个人感觉目前学习安卓和 java 比较好的教程是 mars chen的网站。网站地址：www.marschen.com\n\n目前听他的课程结合现在在达内学习的方法熟悉课程相对来说就比较快了。", "link": "http://blog.csdn.net/fogyisland2000/article/details/50762586", "publishDate": "2016-02-28 23:34", "title": "\r\n        Android 和JAVA 免费学习资料！            \r\n        "}
{"readCount": "2651", "article": "1.文件服务器是不是必须在域环境下?\n\n    如果公司部署有活动目录,则文件服务器必须是成员服务器,并不一定必须是域服务器才可以.\n\n\n\n2.如何让共享更安全?\n\n   在共享的文件夹的时候,在文件夹后面加一个$,达到隐藏共享的效果,因为共享的木桶原理,所以必须对访问控制进行比较严格的设置,最好采用组模式来限制权限,比设置每个人的权限相对来说工作量少,而且管理方便!\n\n\n\n3.共享名称的设置?\n\n   一般采用两位到三位的缩写来达到共享文件夹的目的,举个例子:\n\n     行政部共享   administrator department  我们可以取 AD$来作为行政部内部共享文件夹\n\n     人力资源部共享 Human recruit Department 我们可以取 HR$来作为内部共享文件夹\n\n4.公司的共享文件夹架构?\n\n    如何设置共享文件夹更合理,很多人为这个问题都感觉很苦恼!其实在大部分公司内部,可以采用如下的架构来定义整个共享文件夹架构!\n\n\n\n   个人文件夹                                         个人比较机密的文件夹             个人可见   可以借助活动目录来设置目录\n\n    人事&行政&公司活动文件夹            可以做为文件模板让大家浏览   可以利用脚本映射\n\n    公司共享文件夹                                作为大家相互之间进行交换     每个用户都可读可写  可以利用脚本映射\n\n    部门内部文件夹                                只有部门内部人员可以使用  Domain user 可读写 可利用脚本影射\n\n\n\n5.建立OU 最好的方式?\n\n   大部分人喜欢利用OU来进行良好的活动目录管理,那么怎样的OU是最好的模式呢?据本人摸索,觉得还是根据部门来建立OU是适合80%的公司的.\n\n\n\n", "link": "http://blog.csdn.net/fogyisland2000/article/details/2270239", "publishDate": "2008-04-09 15:18", "title": "\r\n        文件共享的若干问题！            \r\n        "}
{"readCount": "6347", "article": "问：我的一台服务器是win2008 sp2的，现在无法打开事件查看器。打开时报错mmc无法创建管理单元。此单元可能没有正确安装。clsid:fx:{b05566ad-fe9c-4363-be05-7a4cbb7cb510}，请问该如何解决呢\n\n1)      从具有和这台有问题的windows 2008相同配置的的工作正常的计算机上导出下面的注册表键值：\n\n2)      从具有和这台有问题的windows 2008相同配置的工作正常的计算机上复制下面文件：\n\n3)      同时把此文件和注册表键值放置到有问题计算机上。\n\n4)      然后把有问题的计算机重新启动并进入到安全模式, 最后把从正常计算机复制的文件machine.config覆盖C:\\Windows\\Microsoft.NET\\Framework\\v2.0.50727\\CONFIG\\machine.config 文件。\n\n1)      如果问题依然存在，请在安全模式中把从工作正常计算机上的HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\.NETFramework\\Policy注册表键值导入到有问题的计算机。\n\n1)      如果问题还是存在，请在具有相同配置的计算机上导出HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\MMC\\SnapIns 文件，然后在安全模式下导入到有问题的计算机中。", "link": "http://blog.csdn.net/fogyisland2000/article/details/6835483", "publishDate": "2011-09-29 22:16", "title": "\r\n        MMC 事件查看器无法打开            \r\n        "}
{"readCount": "3247", "article": "我们在CSDN 论坛上看到最多的主题是什么？大家猜猜？-文件共享，这个是被人问了上千遍的问题。可是在于文件服务器的特殊以及出现的情况太多，所以我们 可敬的CSDN的管理员们总是不厌其烦的回答这个问题。\n\n对于现有的大多数企业环境来说，活动目录已经成为了我们的基本架构，文件服务器成为了企业中不可或缺的部分，甚至是最重要的部分。我们的需求大概就是以下几个方面：\n\n1.对应用归类\n\n     2.对安全的控管\n\n     3.空间的限制\n\n\n\n      我曾经作为FAE 去过很多公司，看过很多的部署案例。却发现很少公司能够做到以上这些问题呢？同他们进行讨论的时候这么几个问题经常被谈起：\n\n     1.IT工作累,很少有时间真正自己钻研,等到想钻研的时候,自己却想离开这个岗位了\n\n     2.设备投入问题,由于公司对IT 部门定位作用不清晰导致了IT设备及软件投入不足\n\n     3.工作工资不高,做事情提不起劲\n\n\n\n        大部分作为IT人员在国内来说,没有真正发挥出自己应有的作用.而且由于自己的职业定位问题和目标期望的落差使得自己呈现那种似乎破管子破摔的感觉,也就是说.没有认识到自己的价值在哪里.\n\n\n\n        IT 是做什么的?提高生产效率及利用各类信息化手段减少企业的其他固定投入.这个可能是IT的终极目标.而不是来了一件事情就做一件事情.不是万世太平自己就没事了.\n\n我想问大家:\n\n       上面三个问题,我如何解决?\n\n\n\n       以最少的步骤,达到最大的效益和最简单的方式?\n\n\n\n      欢迎大家能够贴出你的看法, 后续几个篇章就是将如何在活动目录下实现最灵活的控管模式.欢迎您的关注\n\n", "link": "http://blog.csdn.net/fogyisland2000/article/details/2221515", "publishDate": "2008-03-26 23:11", "title": "\r\n        文件服务器的管理-开局篇！            \r\n        "}
{"readCount": "6380", "article": "1.     由于2003 的地址策略及地址簿的 语法使用的是LDAP筛选，而Exchange 2010 中使用的Opath筛选，为了能够在EX2010实现编辑的功能，我们必须升级到EX2010：\n\n3.     升级完成后，我们可以发现可以进行编辑了，升级生效了：\n\n6.     基于自定义的LDAP的地址簿，我们可以通过重建或升级的方式，以下为通过升级的方式来升级：", "link": "http://blog.csdn.net/fogyisland2000/article/details/7486686", "publishDate": "2012-04-22 15:48", "title": "\r\n        Exchange 2003升级到Exchange 2010 之升级默认地址簿及地址策略            \r\n        "}
{"readCount": "3645", "article": "1.     我们已经完成了用户的移动，那么客户端是否会发生变化呢？我们之前设定了4种客户端：\n\n2.     我们首先登录到Windows XP+Outlook 2003 机器，我们登陆后打开Outlook，发现连接的服务器已经自动变更为新的服务器：\n\n3.     加入域的Windows 7,我想应该不会有问题，我们登陆查看，默认没有变化，见下图：\n\n5.     而对于未加入域的Windows XP+OL2003,默认来说，根据输入的用户名和密码能够重定向。单也可能存在手动的更改相关的配置文件的服务器才可能正常使用，我们打开邮件服务器后。邮件服务器名称没有发生变化：\n\n7.     对于未加入域的Windows 7，由于Outlook 具有自动重定向功能，因此问题也不大，如以下截图，我们来看看相关的设定是否会自动变更：", "link": "http://blog.csdn.net/fogyisland2000/article/details/7487172", "publishDate": "2012-04-22 18:31", "title": "\r\n        Exchange 2003 升级到Exchange 2010 之客户端移动后的变化！            \r\n        "}
{"readCount": "3891", "article": "想让PPAPI插件充满整个网页，像这样就好了：\n\n更多文章，参考我的专栏CEF与PPAPI开发。", "link": "http://blog.csdn.net/foruok/article/details/51140607", "publishDate": "2016-04-13 09:52", "title": "\r\n        让一个PPAPI插件充满网页            \r\n        "}
{"readCount": "167402", "article": "那么，如何界定某一段日子是混过去的呢？\n\n其次，回顾起点处的自己的状态（包含技能、精神、灵力等等），回顾终点处的状态，比较这两个状态，看看有没有哪方面有进步。\n\n假如任何一个维度都没有令人欣喜的变化，（排除自我要求过高的情况）那基本上就可以说下面这句台词儿了：\n\n我也是醉了，居然长篇大论来谈混日子……\n\n这些不是混日子的理论依据，它们只是说，人不能绷得太紧，紧过头了容易出问题。\n\n拿程序员来讲，有时候是忙一阵松一阵。有项目了很忙，没项目了很闲。闲的时候就容易混，反正领导也没派什么活儿，反正过一阵儿还得忙，混过这阵子再说。看起来是合理的啊，老那么忙，老加班到后半夜，谁特么受得了呢。\n\n那忙起来呢？其实忙又分两种情况，有目标的忙和没方向的瞎忙活。瞎忙活也是混日子的一种。看起来脚不沾地，一会儿这儿一会儿那儿，实际上干的事儿对自己都没什么意义，这就等同于混日子。当然这是被动的混日子。也有主动混日子的瞎忙活，就是“让自己看起来很忙”，对吧，其实我没啥事儿干，也不想干什么事儿，又担心被领导发现我闲得蛋疼，只好装装样子，让自己忙活起来。这是主动混日子。\n\n二分法，强大的二分法，我总在用。\n\n扯多了，不好收场了亲。还是言归正传吧。\n\n混日子的合理性就在于：你没告诉我要干啥，也没告诉我干成啥样。\n\n其实是酱紫的：自己没有目标，加上被安排惯了，一旦没人安排他了，就只好混日子了。\n\n这个问题我好像提了很多遍，不过还是得提：阿猿，你为什么干开发呢？\n\n但实际上，有一部分程序员看的是第一个，或者干着干着，工作的意义就只剩下每月的那点儿薪水了。这样的情况，是最容易导致混日子的。\n\n有些程序员的一天是这么度过的：\n\n特别说明：游戏只是占位符，浏览网页只是占位符，新闻只是占位符，英超只是占位符，抽烟也是占位符……可以被其它形式替换，比如找人聊聊电视剧，上个淘宝，类似的，都可以。\n\n严正声明：看我博客不能用于替换占位符，我都传递的正能量，磨刀不误砍柴工么，刀磨快了干什么都好使。\n\n我在刚参加工作时，经常会觉得自己在混日子，因为每天都在等待，等待设备出事儿，然而设备并不是分分钟都出事儿，所以就有一些时间要混过去，上网聊天，同事们聚一块打打麻将，日子就这么过去了。这种感觉很不好，大概是因为我虽然是个懵懂的家伙，却不是一个能心安理得混日子的人，所以混起来就有一点惶恐，一点惭愧，一点不安，一点迷惘，一点不知今夕何年的感觉。\n\n我不喜欢这样，感觉自己就像一块地，没人来耕种，野草野兔小鼹鼠都很 HAPPY ，我很荒芜。快乐是即兴的，转瞬即逝的，怅然若失的忧愁却是如影随形的。\n\n为什么没事儿干还能拿薪水你还不快乐？\n\n那天看到一句话：不快乐是因为可以像只猪一样懒，却无法像只猪一样懒得心安理得。\n\n\n\n不知道你混日子的时候是什么感觉？\n\n如果你混日子混得心安理得，就别往下看了。\n\n为毛混日子？这也是一个问题。\n\n我接触过一些程序员，表现出来的行为让人怀疑他们的想法和小学生类似：写程序是给公司写的，干活儿是给公司干的。总而言之，这就不是我的事儿，我把八小时交给你就成了。\n\n这也是部分程序员干活不走心的一个源头。\n\n\n\n不过这说到底还得赖教育，下面的话你是不是经常听到：\n\n就是这样，从小我们都被教育坏了……有的人能把这种错乱纠正过来，有的人就这么一直迷惑着、迷糊着，成人了也还觉得是为别人而活，干的工作是给别人干的，谈的女盆友是给别人谈的……\n\n其实，我们都是为自己而活，说为那谁谁而活，要么是自己骗自己，要么被别人骗了。\n\n既然是为自己而活，那不管干什么事儿，其实所有的付出和牺牲最终的受益人都是自己。\n\n那，不管你是被安排任务的码农，还是给别人安排任务的项目经理，还是被人遗忘在角落里没活儿可干的替补码字猴，日子，都是你的，你为你自己的日子负责。不想荒废，那就往下接着看吧。\n\n“人活着要有生活的目标：一辈子的目标，一段时间的目标，一个阶段的目标，一年的目标，一个月的目标，一个星期的目标，一天、一小时、一分钟的目标”。这话是列夫·托尔斯泰说的，看起来有点儿过细了是吧。我也是大部分时间松懈、想起来了紧张一下的人，我觉得目标到星期就很不错了。\n\n“确定了人生目标的人，比那些彷徨失措的人，起步时便已领先几十步。有目标的生活，远比彷徨的生活幸福。没有人生目标的人，人生本身就是乏味无聊的”。这话是卡耐基说的。我都说了我擅长剪报……要是你觉得自己躺枪了，也别和卡耐基计较，人已驾鹤西游了……\n\n目标决定行动，找一个目标是顶顶重要的事儿。这个目标还得你愿意相信。然后，就朝着这个目标努力吧。\n\n在向着目标前行的过程中，也许你会感到劳累、辛酸和疲惫，不过，一切都是值得的，因为你要的幸福，就在那片更蓝的天空，只要你的翅膀卷起风暴，挣脱自我的牢笼，你就可以像狂风一样舞蹈，飞得更高。", "link": "http://blog.csdn.net/foruok/article/details/42293119", "publishDate": "2015-03-02 07:28", "title": "\r\n        漫谈程序员系列：咦，你也在混日子啊            \r\n        "}
{"readCount": "130360", "article": "我发了一篇题为“35岁程序员的独家面试经历”的文章，结果引起了不少大龄程序员的共鸣和感慨，大家都对大龄技术人员的未来非常关心，有的迷惘，有的坚定，不一而足。因此，我准备写一篇文章专门来谈谈这个问题。\n\n老早网上有人说，软件开发干不过30岁，后来又有人说干不过35岁，后来又有人说干不过40岁，后来又有人说干不过45岁……各种说法很多，所以我写了一篇文章，题为“程序员的年龄天花板”来讨论这个问题，感兴趣的可以跟进去看看。\n\n这里我采取通俗的说法，认为过了30岁的程序员算是大龄程序员，只是为了讨论方便，不同意的请保留自己的意见。\n\n这是至圣先师孔老夫子对人一生的发展阶段的精辟概括，里面谈到三十而立。所谓三十而立，是指人在三十岁之后，就应该在稳定在某一个职业上，有所建树。\n\n现代社会，对人生职业发展阶段研究最为著名的学者是美国的舒伯（D.E.Super），他是世界职业规划发展史上里程碑式的人物。舒伯对人的生命发展过程，提出了以成长、探索、确立、维持、衰退为中心的五个阶段模型。每个阶段都有不同的职业课题需要完成，当前阶段的职业课题没有完成的话，就会影响后续的职业发展和人生生活。\n\n对舒伯感兴趣的可以问下贴心的度娘，她会微微一笑很倾城地告诉你舒伯职业生涯阶段理论的细节。我这里只涉及与大龄程序员相关的阶段。\n\n在舒伯的生涯阶段里有个确立阶段，25岁~44岁。在这个阶段，职业上的发展课题有这些：\n\n如你所见，我们所说的大龄程序员，就是30岁往后，即过了孔老夫子所说的三十而立阶段的程序员，大龄程序员基本也是处在舒伯老前辈提出的安定期内。你要说你超过44岁了，噢卖糕的，按孔老夫子所说，应该不惑了。\n\n31~44岁这个安定期，其实是人生最富有创造力的阶段，如果能稳定到一项工作上，一定可以有所成就，为将来打下保障。\n\n30岁这个年龄，是每个人都会遇到的，不单是程序员、软件开发工程师，它是人生的一个节点。所以，你不是一个人在困惑，程序员，世界上所有的人都会经历这个阶段。而且，已经有人经历过并提出了一些有效的应对措施。\n\n还有一点很重要，25~32岁是人的婚育高峰，所以，此时人会面临工作、生活的双重压力，事业家庭两头忙，身心俱疲。假如两头都不定，那就基本没法愉快地生活了。\n\n我不想扯到太原，还是要聚焦在程序员身上来。\n\n前文书咱说过，30岁是所有人都会面临的人生转折节点，那对于程序员来讲，这样的节点，有什么特殊的表现和含义呢？且来水水。\n\n软件现在已经成为各行各业的基础服务，它具有非常特别的属性：软件本身形成了一种产业，它又和其他产业结合形成了交叉领域。\n\n说白点，纯粹的代码没有意义，解决现实问题是软件存在的最大意义。而现实问题来自各行各业，所以，大部分的软件产品，是软件技术和行业需求的有机结合。\n\n所以，多数程序员的工作方式是这样的：使用某种开发工具、通过编程语言来实现一个解决特定问题和需求的软件。有了这样的界定，真的可以开始水了。\n\n程序员需要掌握编程语言、应用框架、开发工具等这些具体的知识和技术。这是第一点，必须的。 \n\n 不同的语言和技术，都有特定的应用场景，这种语言解决这种问题效率高，那种语言解决那种问题效率高。\n\n随着人类社会的不断发生发展，随着信息化和互联网化的不断深入深化，现实问题越来越多，越来越复杂，老的知识、技术在面对新的问题时可能力不从心或效率低下，所以不断有新的语言和技术问世，比如Go、比如Scala、比如Swift、比如ROR，都才出现没多久，都是因为特定领域问题而出现的。没有最好的语言，只有最合适的语言。\n\n面对这样的现状，程序员就需要保持学习，为了更好的解决问题，可能需要掌握多种语言和技术，而且会随着社会的发展和技术的发展不断地调整自己的知识、技术图谱。\n\n所以，早在几千年前，我们的儒家经典《大学》就预料到了将来会有程序员这种人群，对他们的生活做出了概括性的预言：“苟日新，日日新，又日新”。\n\nOK，这就是程序员面临的知识、技术现状，所以有人觉得过了30岁奔四张去的时候，家庭事业两头忙，身心疲惫精力不足没时间充电没时间学习不再适合做程序员了。\n\n这是一种现状，当然它对某些人如此，对另外一些人则不然。其实，31~44岁，正是人年富力强精力旺盛创造力爆棚学习能力焕发第二春的黄金阶段啊。不信你去看看舒伯的生涯彩虹图，一看便知。\n\n举个例子，王江民就是这个时候（38岁）转做软件开发，后来（45岁）一骑独行白衣飘飘杀进中关村创造了江民杀毒的传奇历史，塑造了一代软件神话。\n\n在30岁到44岁这个阶段，如果你还在做程序员，对自己的学习模式一定有所了解了，加上之前的积累，学起新东西来很快，应该会不断收获举一反三触类旁通的愉快体验。\n\n对程序员来讲，知识、技术是一方面，是容易习得的，是较浅的层面。那较深的层面，就是技术能力与阅历。\n\n技术能力是指，对具体的知识和技术的运用水平。它在很大程度上决定了一个程序员身上的技术价值。\n\n技术能力是在不断地运用知识、技书解决现实问题的过程中培养出来的。在这个过程中，有的人爱琢磨好总结能升华，技术能力提升就快，干一年可能能收获一般人两三年的技术经验；有的人可能会停留在写段代码写完了事儿这种层面，那可能干三年不如人家干一年。\n\n《天龙八部》中的神仙姐姐王语嫣，很多少年看了都很喜欢。从IT的角度看，她实际上就是一个掌握了很多知识、技术的字典型程序员，但不会实际开发。当然，她也可以是很妙的程序员鼓励师，既能极大激励程序员的干劲，又能在必要时提供字典式的帮助与指导。\n\n与王语嫣对应的另一个人物是扫地僧，超越了知识、技术，阅历极深，不拘泥于招式，一抬手一投足就拍“死”了慕容博和萧远山这种超强高手。他是我们专业技术者的梦中梦。\n\n扯了这么多，我想说的是，技术能力和阅历，随着程序员年龄和工作经验的增加，其重要性和价值将超越知识、技术本身。这是我们必须意识到的，这也是老江湖的价值所在。\n\n你可以在三两个月学会服务端开发，但如何应对大用户量、大业务量、大数据、大并发带来的挑战，绝对不是一个小白三两个月能搞定的，不积累个五年八年，不随着企业的产品、服务的发展而经历技术架构的变迁，你很难有能力去解决这些问题。\n\n大部分软件是技术和业务的结合，甚至有的行业软件，开发技术只占20%，80%的都是业务层面的知识、流程。所以，对于一个程序员来讲，熟悉业务也是非常重要的。做电商网站和测绘软件绝对是天差地别。\n\n业务和行业紧密相关，你选择一个行业，选择一家企业，就会决定你能积累的产业、业务知识、经验。而这部分业务积累，是程序员的重要价值所在，它和技术阅历一样是经得起时间考验的。\n\n有句老话，早已告诉了我们业务积累的重要性：隔行如隔山。还有一句老话也说明了同样的道理：男怕入错行。\n\n学一门编程语言容易，深刻理解业务却没那么简单。而你不理解业务，空有编程语言和应用技术框架，实际上没什么卵用。这就是我们强调业务积累的原因。\n\n我在“程序员的年龄天花板”一文中曾经提出过软件企业的分类：\n\n这里结合前面提到的“技术人生的三个方面”再啰嗦一下。\n\n外包型公司，通过承接别的企业的部分或全部软件业务来发展。这导致了业务不稳定，编程语言、技术框架等技术方面也不稳定。\n\n外包型公司做软件的心态，是“干活、交活、拿钱、完事儿”。在这样一种心态支配下，程序员较难有机会仔细打磨产品，对技术能力的积累会有一些影响。另一方面，因为业务随时会变，对行业知识积累也会有较大影响。\n\n还有，从企业角度讲，考虑成本的话，更愿意用成本低的年轻人，所以，大龄程序员的将来，在这种公司不够乐观。你一个35岁的程序员和22岁的程序员，做同样的App，老板不会觉得你35岁就比22岁做出来的东西好多少，他会认为年轻人多加个班多改改就差不多了，这时候会产生劣币驱逐良币的效应。\n\n项目型公司通过承接电信、银行、电力、政府或其他单位的软件项目为生，比外包型稍强一些，技术上可以自己选择，也能够在某个行业长期积累经验。如果这类公司的项目规模小而多、行业不集中，那就与外包型公司类似。另外，做项目的心态和外包有些类似，对成本的考量较多，对程序员的持续技术发展不利，比如有新技术出现，公司不一定会用，可能为了快和规避风险而选择较老较趁手的技术来完成项目，这一方面会减缓开发人员的技术更新周期，另一方面也减少了锻炼机会降低了技术成长速度。\n\n产品型公司是最好的，一个产品，要产生竞争力，要么靠对业务的深刻理解，要么靠技术上的领先优势。这类公司是对程序员的技术阅历、业务知识都很有好处，我认为是程序员的较好选择。\n\n用一句话来概括，程序员最大的价值就是运用技术解决问题的能力。而这种能力的构成里，技术能力与阅历、业务这两方面是具有经久价值的，是相比语言、技术更耐得住时间考验的。\n\n程序员的将来，就与价值维系有关，可以参看我发布在微信订阅号“程序视界”的文章“程序员保值的四个秘密”。在我们进一步展开阐述之前，需要先看看四大职能取向。\n\n管理者又分为职能管理者和全面管理者。CEO、总经理之类的角色属于全面管理者，开发经理、研发部门经理、项目经理、项目总监、HR经理等属于职能管理者。\n\n专业技术者指靠技术吃饭的人群，比如程序员，比如测试工程师，比如UI设计师，比如会计，比如律师，比如编辑……这些人的一个共同点就是拥有独特手艺和技术，能用自身所掌握的技术为别人解决问题创造价值，他们通常会依附一个组织来工作。\n\n自由职业者首先是一个专业技术者，然后他脱离了特定组织，自己跑单帮了，自己安排自己，今天想干就今天干，老子今天不爽就明天再干。\n\n创业者是特殊的一类职能取向，他们特别想拥有自己的产品和服务，于是就拉一帮人成立一组织，协调各种资源来实现自己的梦想。\n\n程序员的职能取向，多数会落在专业技术者。我个人来讲，做了6、7年管理，现在还是回到了专业技术上来，因为做具体技术工作会让我更自然更自在也更快乐。每一个程序员都应该理清自己的职能取向，只有职能取向清晰了，谈将来才比较靠谱。\n\n有人说，三十出头的程序员，如果你混的不够成功，面临的压力就会山大。话听起来没错，不过也不尽然，这里面有个关键的问题需要澄清。那就是“成功”的定义。\n\n世俗的成功，古时候是“十年寒窗无人问，一朝成名天下知”，是“春风得意马蹄疾，一日看遍长安花”。现在也差不多，财富更多，老婆更多，社会地位更高，不过如此吧，你看流布甚广的“当上CEO，迎娶白富美，走上人生巅峰”之类的说法就是这种观念的反应。\n\n但我这里说的成功，是指找到适合自己的职业，完成自我实现。简单点说，就是你在干你想干的事儿，又有成就感又快乐。就这么简单了。\n\n我们不必活在社会统一的价值取向里，也不必活在别人的期望里，你的人生是你自己的，哪怕父母非要你成为一个什么样的人，也不必去听。\n\n有了这样的基本认识，就可以继续了。\n\n技术总监和CTO带一些管理职能，也可以从另外一条路上来。这条路就是程序员的管理之路：工程师–>项目组长–>项目经理–>项目总监–>技术总监–>CTO。\n\n一条技术通道，一条管理通道。这是程序员常见的职业晋升通道。\n\n最后，还有一个选择，就是离开软件行业，到别的行业里自由自在的飞翔。啊哈，朋友再见，朋友再见，再见吧再见吧。祝你好运。\n\n走管理路线的人十不其一，这次不谈也罢（回头我会写文章聊）；转做别的职业的朋友们我已经说了再见了；那剩下的，就只能说说技术这条路的将来了。\n\n其实这原本不是一个问题。你说，哪行哪业没有老将？\n\n而这之所以又成为一个问题，是因为程序员是“有知识、有技术、有理想、有焦虑”的四有新人，觉着自己已然学了那么多，付出了那么多，将来总不能停滞不前吧总不能走下坡路吧总得蒸蒸日上吧，所以就焦虑这件事儿，就担心，就困惑，就觉得这行当是青春饭吃不了几年。\n\n其实根据我前面的分析，结论已经呼之欲出了：保持学习能力，丰富技术能力与阅历，积累行业知识与经验，然后就可以持续走下去。即使会有衰退阶段，那也是正常的，人生就如花儿一样，有含苞待放，有盛放，也有枯萎的过程，我们需要自然接纳。\n\n先说技术路线和管理路线的选择，基本上也是二八开（或者一九）。\n\n小部分的人走了管理路线，剩下的大部分程序员，走技术通道。那技术通道，有多少人能成为高级软件工程师、架构师、技术专家、CTO？\n\n那剩下的百分之八十，在技术路上不能走得更远，但还得维持自己的竞争力，保持价值不衰退，这样才可能继续做下去。怎么维持竞争力，前面已经说过了。\n\n大量的大龄程序员将面临无法晋升和如何维持竞争力的问题，这是每个人都必须看到事实。\n\n从晋升角度看，任何一个行业的从业人员的分布，都是金字塔型的。大锅饭不存在，共产主义按需分配也还没到来，我们必须接受、接纳这个事实，然后才能在此之上谋求发展。\n\n前面已经确认，技术路线可以走下去。现在我们来看，如果一个程序员的四大职能取向定位到专业技术者，到30多岁时，该如何走好，如何适应。\n\n就做技术来讲，如果想维持竞争力，在选择企业时就应当做一些考量，选择将来向好的行业，选择产品型、重视技术的公司，这种选择非常重要。它会严重影响你将来能在技术路线上走多远。\n\n我前阵子找工作，就根据行业、企业、产品，只选了三家来面试。我35岁，需要稳定下来啦。\n\n有人说可否选择创业公司，我的观点是，如果你能承受一定的风险（金钱和时间成本），创业公司的创始团队和产品又都比较靠谱，可以尝试。小米当时创立时，从摩托罗拉等公司找了好大一批开发工程师哦。\n\n根据舒伯的职业生涯阶段理论，31~44岁是安定期，程序员应该稳定于一项工作，发现适当的晋升通道，确立自己将来的保障。\n\n在这个时期，频繁的跳槽对将来的发展不利，这是毋庸置疑的，所以选择要慎重。尤其你到了40岁还没在哪个行业长时间待过，技术也换来换去，那再出去找工作，就会遇到比较大的困扰。\n\n到招聘网站遛一遭，看看招聘信息中对年龄的要求，你就知道我所言非虚，除了技术总监、架构师、技术专家、高级软件开发工程师等岗位的年龄区间落在30~45岁，其他岗位，绝大部分都要求你30以下。所以，如果你在不同行业、不同公司晃来晃去，到了三十四五岁还没稳定，也没能达到高级软件开发工程师应有的水平，那再找工作肯定会遭遇比较尴尬的状况。\n\n技术路线，可以初级、中级、高级、架构师（技术专家）……这么走下去，假如一个程序员发现自己到一定程度无法再走下去，就会产生挫折或倦怠。通常这种情况会在你稳定一项工作7年左右出现，所谓七年之痒。对本科毕业来讲，这个年龄就在33~35岁左右。\n\n此时怎么办？这是很现实的问题。\n\n这个我们就要具体问题具体分析：是你很牛X限于企业环境无法晋升？还是你自身能力到了天花板了无法晋升？\n\n不同的原因对应的行动是不一样的，前者的话，可能应该考虑换一下。后者的话，要调试心态，建立第二生活中心，在职业之外发展其他的兴趣爱好来平衡。\n\n在这个年龄阶段，有一大批程序员会因为晋升受挫或倦怠而成为创业者或参与到创业中来。这是需要留意的现象。\n\n程序员的价值和竞争力，其实是相对的。比如你在腾讯，牛人太多，无法晋升了，其实别处可能有鸡头的位置等着，比如其他行业内的小公司的技术总监、部门经理，如果你看重职位和头衔，就可以去尝试。这也是典型的一种路线，有部分程序员在大公司镀镀金，回头到其他行业的相对规模较小的公司去做管理或技术专家。\n\n如果你很在意职位等级，很在意比别人更受尊重，那就找一个能凸显出你价值的环境。比如乒乓球运动员何智丽，在39届世乒赛上因为没按领导指示输球，后来被取消参奥资格，在国内无法发展了，她移民日本，继续在乒乓球领域活跃并取得了辉煌战绩，还曾经战胜邓亚萍取得亚运乒乓球女单金牌。类似的还有一些国外的业余足球运动员或退役的足球选手到中国来，迅速成为热门选手受到重视。这都是一个道理。\n\n哦，亲爱的，如果你有时间，也可以学习其他可以赚钱的技能，因为，虽然我们说大龄程序员可以一直做技术，但能一直做到退休的，估计也只有20%。如果你是那80%，当你不得不离开心爱的开发岗位时，就能够因为有所准备而不至于忽然失重。\n\n这点是我们必须要谈的，程序员的人生里不只有软件和工作，还应当有其他的。生活是多元中心的，要有一些其它的兴趣爱好，能够滋养心灵，修复纯技术工作给心灵带来的磨损。\n\n提笼架鸟，雕刻，书法，围棋，游戏，写作，读书……都挺好的，有比没有强太多了。很多人（包括我）缺乏信仰，再没有点兴趣爱好，那就太容易内分泌失调了。\n\n还问啊……让星爷来回答你吧：\n\n“曾经，有一份真诚的爱情放在我面前，我没有珍惜，等到我失去的时候才后悔莫及，人世间最痛苦的事莫过于此……如果上天能够给我一个再来一次的机会，我会对那个女孩子说三个字：‘我爱你。’如果非要在这份爱上加上一个期限，我希望是……一万年！”", "link": "http://blog.csdn.net/foruok/article/details/50323093", "publishDate": "2015-12-16 07:36", "title": "\r\n        大龄程序员的未来在何方            \r\n        "}
{"readCount": "65174", "article": "之前公司项目，为了移植一个依赖 Qt 的程序到安卓平台上，我自己交叉编译了 Qt Embedded 4.5.2，费了老大劲儿，还修改了源码（只把 QtCore、QtNetwork、QtXml、QtNetwork 编译过了）。现在终于有官方版本了。\n\n今天试验了一下，在 Windows 7 下把开发环境搭建完成，跑了一个 helloAndroid 示例。\n\n环境搭建其实很简单，首先下载 Qt 5.2.0 for Android(Windows 32-bit) ，安装，注意选中 Tools 里面的 MinGW。安装完成后打开 Qt Creator（版本是 3.0.0 ），打开“帮助”菜单，选择“索引”子菜单，输入 Android，选择“Getting Started with Qt for Android”，里面有详细的步骤，指导我们完成接下来的操作。下图是 Qt Creator里的帮助：\n\n我使用的 ndk 版本是 r8d ，到 这里（点我 下载，zip包，解压即可。\n\napache ant 是1.8.4，到官网（点我）下载，zip包，解压即可。\n\njdk 是 6，到 oracle 官网（点我）下载，安装包，跟着向导安装即可。\n\n接下来需要在 Qt Creator 中针对 Android 做一些设置，打开“工具”菜单下的“选项”子菜单。下图是我的设置：\n\n看上面的图片中有 AVD 设备，是我自己创建的，通过 Qt Creator 可以启动 Android AVD 管理器，创建自己想要的虚拟设备。\n\n我选择了 Andorid for armeabi-v7a ，接下来就很简单了，编码，构建，运行，选择目标设备。\n\n针对一个项目，可以做一些设置，有构建的，有运行的，和其它版本 Qt Creator 类似，不同的是有一些 Android 相关的设置，比方说签名、SDK 版本、Qt 库的部署方式等，如下图所示：\n\n我连接上我的手机 XT882 ，运行时也可以找到设备，选择手机，启动比虚拟机快多了，OK ，GOOD。建议直接在真机上调试。\n\n好了，尝鲜到此为止。进一步的开发可以参考 Qt 的文档。\n\n美中不足的是，如果选择 Bundle Qt  libraries in APK ，那么 APK 就会变得比较大，我的示例程序 APK 有 6MB，部署到模拟器后通过设置查看，20MB。 Qt 提供了其它两种部署方式，可以弥补这一缺点。除此之外，还有另一个途径，自己编译 Qt 源码，通过裁减来缩小 Qt 库的体积，参考 Qt 5 For Android Building。\n\n翻译了大神 BogDan Vatra 的几篇关于 Qt on Android 的文章（原出处 http://www.kdab.com/category/blogs/ ），列出来参考一下：\n\n我的关于 Qt on Android 的系列文章：", "link": "http://blog.csdn.net/foruok/article/details/17305697", "publishDate": "2013-12-13 18:23", "title": "\r\n        Windows下Qt 5.2 for Android开发入门            \r\n        "}
{"readCount": "41263", "article": "《推背图》相传由唐太宗时期的司天监李淳风和袁天罡合著（此两人其实是超级武学高手，参见小椴的《开唐》），推算大唐以后中国两千多年的国运盛衰，在中国七大预言书中居首，是当之无愧的中国第一预言奇书。\n\n我最喜爱的当代小说作家之一格非也有一篇小说以《推背图》为名，很好看。\n\n\n\n说真的，本文和推背图没有一毛钱关系，唯一的关系就是大家都占个图字。\n\n最近在琢磨程序员到底路在何方，经过不断的自虐和代入，终于在迷雾森林中得图一张，看之豁然开朗。独乐乐不如众乐乐，share了：\n\n就这么多吧，其它的也不想说了。因为我们要讨论的是程序员的出路……\n\n图1中框起来的，是程序员的主旋律。\n\n程序员，专业人士也，与瓦工、木匠、发型师、保洁员等类似，不过是社会万千分工之一种，没什么高大上，也没什么矮矬穷，只不过时代大潮中被滚滚洪流裹夹着前进的一群人而已，所谓泯然众人矣，就是说的这个。\n\n那就想想吧。有好处。\n\n有的人是为了程序员的高薪\n\n有的人是想要一份体面稳定的工作而已，别出差\n\n有的人是过来打酱油的早抱定了过两年就走的心\n\n有的人想了解这个世界，试试看自己合不合适\n\n有的人就喜欢计算机的世界，如鱼得水\n\n有的人觉得这个行当既专业又神秘，感觉倍儿棒\n\n有的人喜欢挑战，因为软件开发每一刻都有战斗的感觉，各种问题纷至沓来\n\n有的人就喜欢不断学习新技术，为技术而生，而没有哪个行业像这个一样时刻都要学习\n\n有的人喜欢这个行当的成就感，持续不断的小刺激总让人高潮不断\n\n有的人渴望有自己的软件作品\n\n有的人想用软件改变世界\n\n有的人觉得这是一片净土，罕见尔虞我诈，不必江海寄余生\n\n有的人觉得这行门槛低，谁都可以来搞两下\n\n有的人是来发动战争的，攻破别人的防线感觉很爽\n\n有的人是冲着 IT 界牛人半数都出柜这一点来的\n\n总之各种理由都有，你也一定有自己的那一个。对吧，你自己的。\n\n前几天在朋友家翻看米兰昆德拉的《不能承受的生命之轻》，里面开篇对轻与重的辩论，很有意思，好像和我们也有一点关系，感兴趣的可以读读，这本书是倒退十来年那个时候小资必读。\n\n你今天的选择，决定了明天的路。\n\n那些来打酱油的，明天就走了。比如我原来有个同事，干了一阵子，来找我辞职，说准备回家搞民间金融去了。后来还在QQ上联系过我，据说搞得还不错，问我要不要投资。\n\n有些人听说IT行业薪资高，巴巴地进来了，可是干了两三年，工资还是三两千，只好失望的走了。其实除非你有经天纬地之才，没有一开始就高薪的道理。先做事，后有钱。先想钱，钱难来。做程序员搞开发大抵是酱紫的。听说有个哥们跳到了华为，天天晚上十一二点的搞，有一天他终于不慎抱恙，晚上九点多回去了，被整个组的人鄙视；可是华为熬过三年，钱多多的，年终奖和分红抵得上你一年的工资。关键是，你熬得住吗？你媳妇熬得住吗？\n\n有一段时间我觉得心不够静，买了几本佛经想受点熏陶，读了《金刚经》、《坛经》、《心经》、《地藏经》，不过都没读完。后来在一个同事的工位上看到她贴了一个即时贴：\n\n观自在菩萨，行深般若波罗蜜多时，照见五蕴皆空，度一切苦厄。舍利子，色不异空，空不异色，色即是空，空即是色，受想行识，亦复如是。舍利子，是诸法空相，不生不灭，不垢不净，不增不减。是故空中无色，无受想行识，无眼耳鼻舌身意，无色声香味触法，无眼界，乃至无意识界。无无明，亦无无明尽，乃至无老死，亦无老死尽。无苦集灭道，无智亦无得。以无所得故，菩提萨埵，依般若波罗蜜多故，心无挂碍，无挂碍故，无有恐怖，远离颠倒梦想，究竟涅槃。……\n\n\n\n原来心不净的人可真多呀，好吧，我不是一个人在战斗，太欣慰了。\n\n我看到女同事贴的这段《心经》中的文字没多久，她离开了公司。再后来我到书店闲逛，发现摆在显眼处的都是什么这个禅师、那个道长、某个灵修、西方冥想者出的拯救大家心灵的菩提书，也有很多国内的心理作家写的鸡汤，多得很呢真是。我这才意识到，原来我们都有病，药不能停啊。\n\n我想说的是，作为程序员，心态决定你的将来。你自己怎么看待你所从事的工作，你是享受它、厌烦它、无所谓、爱恨交加……这些决定了你将在这条路上走多远。\n\n我们生活在一张社会关系网中，因为别人能够看到你你才存在，这是《作为意识与表象的世界》，你看到的人、别人看到的你，都只是作为观察者的那个人想看到的，而非真实的人。虽然真实的人客观存在，但没有人能看到这样一个真实的、完整的人，包括你自己。\n\n你看到你想看到的，他看到他想看到的，张三看到张三想看到的，李四看到李四想看到的……周围一圈人对你的意识构造了社会化关系中的你，但那只是你的一小部分。仅此而已。如果别人不知道你，你就不存在。为了存在，你就要在别人面前出现，这就是“存在感”。\n\n所以现在很多人在刷微信、微博、博客、论坛、陌陌，都是在刷存在感。当然也包括我自己。\n\n让别人知道你，你才存在。你只有留下点让别人难以忘怀的东西，你才因这些东西而存在。\n\n如果想明白了这个道理，一个真正热爱技术的程序员，想在这个行当里干点儿事情的哥们姐们，就不会去在意别人说什么“软件开发是青春饭”、“程序员平均寿命低于普通人”、“程序员群体社会地位低下不如鸡”、“过了30就要另谋出路”之类的话。作为一个与其它行业没有什么差别的行业，仅仅是分工不同而已，为什么有这么多说法呢？众说纷纭，都是杂音。有用的话不这样，大音希声。其实黄小琥在《没那么简单》这首歌里也说了：\n\n当然你也可以认为我通篇都是P话，真没关系。\n\n其实如果你不在意这种周围的看法，做技术未尝不是一条幸福的路。\n\n前面我提到有同事搞金融去了，还有别的故事。\n\n我原来有个同事，程序很厉害，是公司的高级工程师，后来不干了，开便利店去了。\n\n    前几天有个朋友说他找了个合伙人包了点儿地在搞有机农业，种菜……\n\n\n\n有个阿媛在淘宝上卖内衣，后来把工作辞了……\n\n有个阿猿开了家咖啡馆，名字就叫程序员咖啡……\n\n这都是跳出三界外的故事。其实也很平常，你的选择，你做主。如果你觉得这个行当不是人待的地方，再也不要受这罪了，那就走吧。如果一份工作带给你的痛苦比欢乐多很多，确实没有留恋的必要。真的，你肯定是走错了路。\n\n我在看《高效程序员的45个习惯》时，第一章里引用了一句土耳其谚语，写在下面，送给诸位，也送给我自己。\n\n看图1很明白了，程序员有两条主要的职业通道：技术和管理。在中国有个很不好的传统：学而优则仕。如果你在一个单位干技术干了很多年，还当不上领导，就会被人瞧不起。这也是很多人干开发干了几年后，正当年富力强生产力旺盛的时候脱离技术通道的原因。因为领导大部分都是这么一个套路：“干得好？行，带人吧。带得好？行，升经理吧……”所以，很多原本可以成为技术大牛的人，就这么被拐走了。也有一些专注搞技术的开发人员，就要走技术通道。有个哥们儿，做 CMS ，前台后台都能搞，领导让他带三个人，让他当项目经理，他不乐意，说我自己干就行了，管别人净浪费时间。领导好说歹说把他绑在了项目经理的位置上，结果他不管那几个小伙伴，也不安排工作给人家，人家来问他这个怎么干，他就说你不用管了，我来干。最后呢，一个人干了80%以上的活儿，其它几个人闲得蛋疼。再后来呢，领导不住地找这哥们儿谈话，教育他怎么做项目经理……再后来这哥们儿就离职了……“学而优则仕”还有一个非常不好的地方：普遍认为当领导的薪水要比高技术的高。这也是很多本来有灵气的开发人员想走管理路线的原因。我想干技术啊，可你们看不起我，不给我那么多钱，周围人也这么看，我没法老这么干下去。", "link": "http://blog.csdn.net/foruok/article/details/40585139", "publishDate": "2014-12-03 07:15", "title": "\r\n        漫谈程序员系列：一张图道尽程序员的出路            \r\n        "}
{"readCount": "40421", "article": "作为程序员，身边总是有牛逼的前辈、后辈或者同辈。牛逼的人总是让人羡慕。比如自己苦搞一天的 BUG ，头发快抓掉完了，人家扫上两眼，改一行代码，问题就解决了；比如自己干了十年开发，薪水还不到 10K ，人家才毕业就签了 16K 的合同；比如我要天天辛苦加班工作还干不完，人家嘛事儿不干每天就喝喝咖啡，结果写出来的软件居然比我的稳定多了好用多了。这样的事情太多太多，怎么办？\n\n作为程序员，面对牛逼的同类，其实我们也可以愤而追之：大丈夫当如是也！\n\n有梦想有追求总是好的，关键是，如何才能牛逼起来耶？\n\n早上翻看陆其明陆老师翻译的Jeff Atwood的书《高效能程序员的修炼》，里面有一篇文章，名字是《程序员的八种境界》，讲得很好，受益匪浅。不过我打算从另外一个角度为程序员分一分类。\n\n博主鲁钝，不知道谁能生而知之，我本人是困而学之，而后学而知之。一切从自我出发，窃以为困而学之、学而知之这两类，都可以牛逼起来。有兴趣的话，可以评估一下自己是哪种类型的。\n\n迈阿密大学的 AndersEricsson 教授写过一篇论文——《有目的的训练在专业人才培养中的作用》（The Role of Deliberate Practice in the Acquisition of Expert Performance），介绍了他在研究“最好的音乐家”有什么共同点时的发现：卓越的音乐家的练琴时间，没有一个人小于 10000 小时。\n\n2008 年，畅销书作家 Malcolm Gladwell ，将这篇论文写进了他的新书《异类：成功人士的故事》（Outliers: The Story of Success）。\n\nMalcolm Gladwell 概念化了原始论文的结论，宣称存在一个“ 10000 小时法则”（10000 hour rule），即成功至少需要 10000 个小时的投入。\n\n\n\n你造吗，这本书出版后，成为《纽约时报》畅销书排行榜的第一名。\n\n10000 个小时法则背后的思想是：真正决定一个人成就的，不是天分，也不是运气，而是严格的自律和高强度的付出。\n\n看到这里你可能以为博主扯淡又扯远了……其实不是的，刚开始而已，真正扯的在下面。\n\n我想很多人看过古龙大师的《边城浪子》，里面的主角是傅红雪，傅红雪的绝技是拔刀术。我靠，简单吧。苍白的手，漆黑的刀，刀过人亡，血还没见着刀又还鞘了。这就是傅红雪的拔刀、收刀之术，关键在一“快”字。天下武功，唯快不破。傅红雪的刀，已超越了速度的极限。\n\n可是你造吗，傅红雪是癫痫症患者，资质也仅仅是中等，比起叶开，那是差了一大截，比到处留情的楚香帅，也差了一大截。关键是，傅红雪永远看着都那么苦逼：在苍茫的关外，握着刀，拖着腿，背负着于己无关的血海深仇，在“一入万马堂，刀断刃，人断肠”的歌声里寻觅不是仇人的仇人。\n\n这下扯大发了，其实我想说的是，捡来的孩子傅红雪，资质平庸又身有残疾，结果却炼成了举世无双的刀法，其秘诀非常之简单，卖油翁一言概之：无他，惟手熟尔。要知道，傅红雪被不是妈妈的妈妈每天逼着练一本残缺到只有拔刀式的白家刀法，苦逼地每天拔刀两千次以上，拔了十几年，你试试，要是你拔刀拔十几年，不疯掉的话肯定也能炼成个无影刀什么的。\n\n傅红雪是另一个 10000 小时法则的实例。\n\n我们来对比一下帅到一塌糊涂的钟汉良版的傅红雪与老派功夫帅哥狄龙的傅红雪：\n\n我很喜欢狄龙的扮相，钟大帅哥嘛……\n\n我在前面介绍了“ 10000 小时法则”，当然那只是一个必要条件，不是充分条件。我以为要想让 10000 小时法则有效，还有一个条件。\n\n为了将事情做好，首先你得喜欢做这件事，而不是喜欢这件事情的结果，那仅仅是第二位。\n\n\n\n想牛逼的程序员，不能仅仅盯着一个项目干完后的奖金吧，也不能老想着忙过这阵子就可以休息了吧，也不能盼着应用能 Run 就交差了吧……也不能老想着我学了 Scala 就能拿到 20K 的薪水吧……\n\n牛逼的程序员很多是酱紫的：喜欢干，干得牛逼了，收益来了，机会多了。\n\n要说你不喜欢一件事情，有时被逼着也能胜任，但要说你讨厌一件事又能干得出类拔萃，那我不相信，最好你也别让我相信——我怀疑你早晚有一天会人格分裂。\n\n伟大的科学家爱因斯坦（他的宗教观也很有意思http://en.wikipedia.org/wiki/Religious_views_of_Albert_Einstein）说过：“兴趣是最好的老师。”这就是说，一个人一旦对某事物有了浓厚的兴趣，就会主动去求知、去探索、去实践，并在求知、探索、实践中产生愉快的情绪和体验，而这种愉快的情绪和体验反过来又会促使他继续去求知、探索、实践。这样就产生了良性循环。“成为达人”的欲求就会推动着你不断前行。\n\n\n\n你爱编程，享受做设计、写代码、解决问题的过程，再遵循 10000 小时法则，那你想不牛逼都难啊。\n\n前面是开胃酸汤，现在到正题了，我们来聊聊一个程序员，要如何才能一步一步慢慢牛逼起来。\n\n毫无疑问，你必须得编码，持续不断地编码，要达到一定的量。\n\n持续编码的结果有两个，一个是达到质变，水平不断提升；一个是重复重复再重复最终麻木。\n\n只编码，不走心，那是万万不行的。不走心的程序员很多，干多少年了水平还和初干时差不多，十年如一日。走心就不一样，走心一日如十年。\n\n我们要周期性的回顾自己，看看以前的代码，分析下现在的设计，看看哪些可以改善，有多少种改善思路……这样就能看出以前的自己与现在的自己这两者之间的差距。如果你觉得自己以前的代码是翔，那恭喜你，你绝对提升了不少。\n\n要回顾以前，还要分析现在。程序员还要经常梳理一下自己的状态，看看我现在都掌握了什么技能，在哪些方向和领域有所成就，再加上对过去的回顾，看看哪些是延续性的前进，哪些是无心插柳，哪些是冤枉路，哪些是意外之喜。这样就会对自己的能力边界有所了解，知道自己知道什么，也知道自己不知道什么，更重要的是，你会发现自己能把什么东西学好用好，还能发现自己为什么可以把这些东西学好，那样你就可以找到自己擅长的方向，做得更好。\n\n回顾了以前，分析了现在，还要想想将来。在技术上，我要在哪些方向继续前行深入挖掘？这点非常重要。我们伫立现在，回首过去，仰望未来，这是上山的姿势啊。哈哈，上山好啊，值得期待的只有前方。\n\n有人说上到山顶就只有下山喽……那，这也是真的，不过，顾城有首诗《避免》可以看看：\n\n作为有追求的程序员，我们不必这样担心吧。只管积累我们的 10000 小时去，只管思考如何有效地利用这 10000 小时去，不但过程是美丽的，将来也会是美丽的。\n\n台上一分钟，台下十年功。那些牛逼的程序员，无一不是付出了比普通程序员更多的精力。\n\n我们在开发时，会接触各种各样的新技术。有时因为项目时间原因，很多技术只能是走马观花的用，解决问题为目的，项目结束了可能就扔一边儿去了。但要想让自己有更大的成长，那我们就应该学多一点，用一分学两分，广里一分，深里一分，不能不求甚解一带而过。对于用过的技术，最好在当时，项目的间隙或者项目结束时，抽时间了解它的背景、长处、机理，让自己对用到的技术都有相当程度的了解。惟其如此，我们的知识面和技术深度，才会随着开发经验而不断递进。\n\n选择或者学习一门新的技术，必须要实践。可以把它应用到工作中的项目，如果工作条件限制，那也要自己定义一个自己喜欢的项目，坚持使用你的新技术做下来。唯有实践，你的新技术才能理解得更为深刻。\n\n知道有那么一门技术，与实际使用过，其间的差异可不止一点。\n\n我想说的是：要想成为牛逼的程序员，沟通一定要过硬！\n\n程序员是干嘛的？不是写代码的，而是解决问题的。\n\n客户会找你，市场会找你，产品经理会找你，UI设计师会找你，开发同事会找你，测试妹妹会找你，老板也会找你，女盆友会因为你的投入与执着爱上你也会在爱上你后因为这些而不断与你争执……\n\n当然我不是说程序员要像销售、市场、营销等等岗位的兄弟姐妹们一样妙语生花，其实沟通最重要的是能听懂别人说什么，能把你想说的以对方能理解的方式说出来。至于是妙语连珠还是磕磕绊绊，是语言沟通、眼神沟通还是书面沟通，只要达到目的即可。\n\n有人说我天生不爱说话，跟机器打交道才觉得踏实。其实这没关系，你要找到自己的沟通方式，看怎样才能让别人理解，也调整自己的聆听和理解方式，看怎样才能理解别人说的话。\n\n怎样才能让别人正确理解你的话，怎样你才能正确听懂别人的话，这都需要不断的学习、练习，这方面有很多的书啊视频啊，可供参考。这没什么不好意思的啊，我认识一些朋友，觉得学习说话技巧是很不好意思的一件事儿，好像这样做就说明自己心怀鬼胎就多丢人似的。其实不必，我们的目的不是巧舌如簧地骗取别人的信任然后来谋取利益，我们的目的很简单，就是让别人理解我们也让自己理解别人。\n\n沟通这事儿真是一门学问，虽然我在这方面一向鲁钝，还是想以我们程序员的方式，打个比方来说明一下沟通模型。\n\n首先每个人心里都有一个 TCP Server ，监听到某个端口上，等待陌生人或者熟人或者半生不熟的人来访问。\n\n其次呢，不同的人对自己的端口是否开放持不同的态度，OPEN的人就会监听到知名端口，比如80、21、7、13、22、23等等，这样别人就知道我们找这个 OPEN 的家伙说事儿该连接哪个端口。当然，只开放端口还不够，灵慧的人还会慢慢把自己的协议 SHOW 给别人，这样想找他聊天的人就可以遵循这个协议来说，事情就容易多了，双方就都能理解。\n\n还有一些人呢，比较内敛，虽然内心很饥渴，希望别人找自己聊聊天谈谈心，可是不知道怎么把自己的端口开放给别人，或者出于某种原因隐藏了端口。比如他本来是监听到 21 端口上，走 FTP 协议，因为被别人通过端口扫描的方式黑了两次受了点不大不小的伤害，就小心地封掉了 21 端口，把自己的服务挪到了其它端口上，并且也不告诉别人。这就出问题了，别人找不到端口号，怎么和你沟通咧……\n\n还有一些人呢，自己也不知道该监听到哪个端口上，不能有意识的训练自己，今天是 21 ，明天就 80 ，后天又走 37 了，结果不但自己混乱，跟他打交道的兄弟姐妹们也混乱：昨天这么说还挺融洽，今天再这么说他居然翻脸了呢！\n\n这是我们每个人内心的 TCP Server 。其实每个人还有一个 UDP Server ，是为那些夹生的人或者拥有特别标签的人准备的。你可以知道我的 UDP 端口，但是你发消息过来我就不一定搭理你，被拆穿了我还可以说 UDP 协议不可靠，我没收到……。这两个 Server 就是我们每个人身上基本的沟通模型。\n\n最后呢，如果你要想向别人说明你的意图并让别人按你的意图去做某件事，那就要花费精力去研究如何找到对方监听的端口、使用的协议。和 OPEN 的人沟通比较容易，访问 80 端口，走 HTTP 就行了，或者夜半三更翻墙过去幽会也能成。而针对那些隐藏了端口和协议的，就要启用端口扫描这种神器，扫到端口，再抓包分析协议，成功的可能性总是有的，只不过费些力气罢了。\n\n用这种模型来解释现实生活中的沟通问题，程序员们就可以释然了：啊哈，原来我给他说的事儿他老不反应，是搞错了端口或者走错了协议。\n\n理解了沟通模型，找到了对方的端口和协议，还有一个问题需要解决：你怎么准确地表达你的意图。\n\n对于相当一部分程序员，这是个难题。有的人本身就寡言少语（我是这类的）；有的人很厉害，与别人说话时脑子转得比别人快几倍，脑子里转的是长长的带上下文的句子，从嘴里出来后就成了嘎嘣脆的词语，还以为自己说过了别人都能理解；有的人写代码一二三四条理清楚，说话时就比较发散，正说股票呢忽然就转到APEC蓝上了；有的人比较羞涩，大男人说话却声若蚊蝇……总之各类情况都有，你见到的绝对比想到的多。\n\n不管你属于哪一类，要想能顺畅地与人沟通，先要训练自己，让自己可以准确地表达。\n\n我是不会表达的人呢，你看我洋洋洒洒长文千字，其实我不大会说话。不过我要说的是：如果你说不好，那就想办法先写好。\n\n“写”这个事情，比说更容易让人条理清楚，因为写这个过程时间相对宽松，上下文简单，不像与人沟通那样你来我往还要时刻注意话外音整个过程比较复杂。所以，写，是一个很好的锻炼自我表达的手段。写作能训练你表达的准确度。\n\n你可以通过写博客，写日志等等手段，把自己的想法表达出来。然后呢，过一段时间，你能通过写作来表达自己的了，再回头来影响说话，你把嘴上说的当作纸上写的，多练习练习，就能准确的表达自己的意图了。你看人家领导人讲话还需要先打打草稿呢不是，更甚之的还有念稿子的。\n\n程序员干的是技术活，找到一个谈得来的小伙伴很重要，可以相互促进，消除登顶路上的寂寞。\n\n胡一刀和苗人凤就是好伙伴，两人经常切磋，水平都很高。\n\n可能你需要在不同的阶段找不同的伙伴，最好是找某方面比你牛的人一起研究技术，这样可以学到东西。\n\n“在你所有的能耐中，至少应该有一样是拿得出手的。不会做很多事情并不可怕，可怕的是没有一件事情能做好。”\n\n其实有相当一部分程序员离职的一个原因是：在这个公司真的太寂寞了，都找不到一个可以讨论技术相互促进的人！\n\n这个，真的很重要，千万别掖着藏着，对待向我们求助的兄弟姐妹，要像春天般的温暖……", "link": "http://blog.csdn.net/foruok/article/details/42061247", "publishDate": "2014-12-24 07:23", "title": "\r\n        漫谈程序员系列：怎样成为技术达人            \r\n        "}
{"readCount": "38040", "article": "android-async-http 开源框架可以使我们轻松地获取网络数据或者向服务器发送数据，最关键的是，它是异步框架，在底层使用线程池处理并发请求，效率很高，使用又特别简单。\n\n以往我们在安卓上做项目，比如要下载很多图片、网页或者其他的资源，多数开发者会选择一个线程一个下载任务这种模型，因为安卓自带的 AndroidHttpClient 或者 java 带的 java.net.URL ，默认都是阻塞式操作。这种模型效率不高，对并发要求高的 APP 来讲，并不适用。有的人会选择使用 nio 自己实现，代码复杂度又很高。\n\n上面的代码演示了如何使用 AsyncHttpResponseHandler 和 BinaryHttpResponseHandler ，相信 AsyncHttpClient  会给大家带来很大的便利。", "link": "http://blog.csdn.net/foruok/article/details/18013113", "publishDate": "2014-01-08 22:47", "title": "\r\n        Android开源框架AsyncHttpClient (android-async-http)使用            \r\n        "}
{"readCount": "34379", "article": "Qt Quick 技术的引入，使得你能够快速构建 UI ，具有动画、各种绚丽效果的 UI 都不在话下。但它不是万能的，也有很多局限性，原来 Qt 的一些技术，比如低阶的网络编程如 QTcpSocket ，多线程，又如 XML 文档处理类库 QXmlStreamReader / QXmlStreamWriter 等等，在 QML 中要么不可用，要么用起来不方便，所以呢，很多时候我们是会基于这样的原则来混合使用 QML 和 C++： QML 构建界面， C++ 实现非界面的业务逻辑和复杂运算。\n\n那这篇呢，我们就来看看 QML 和 C++ 之间如何交互。\n\n其实话说回来， QML 的很多基本类型原本就是在 C++ 中实现的，比如 Item 对应 QQuickItem ， Image 对应 QQuickImage ， Text 对应 QQuickText  ，……这样看来，在 QML 中访问 C++ 对象必然不成问题。然也！反过来，在 C++ 中其实也可以使用 QML 对象。\n\n对于这两种情景，我们分别讲述。先看如何在 QML 中使用 C++ 类和对象。\n\n首先我们需要创建一个 Qt Quick App ，请参考《Qt Quick 之 Hello World 图文详解》建立一个名为 colorMaker 的项目，接下来我们的学习将会伴随 colorMaker 项目进行，等我们讲完，一个完整的 colorMaker 项目也会完成。需要新建两个文件， colorMaker.h 和 colorMaker.cpp 。\n\ncolorMaker 只是一个示例项目，我在 C++ 中实现一个 ColorMaker 类，它可以被注册为一个 QML 类型供 QML 像内建类型一样使用，它的实例也可以导出为 QML 上下文属性在 QML 中访问。我们的示例只是在界面顶部显示当前时间（时间文字的颜色随时间变化而变化），在界面中间显示一个变色矩形，在界面底部放置几个按钮来控制颜色如何变化。\n\n我们知道， QML 其实是对 JavaScript 的扩展，融合了 Qt Object 系统，它是一种新的解释型的语言， QML 引擎虽然由 Qt C++ 实现，但 QML 对象的运行环境，说到底和 C++ 对象的上下文环境是不同的，是平行的两个世界。如果你想在 QML 中访问 C++ 对象，那么必然要找到一种途径来在两个运行环境之间建立沟通桥梁。\n\nQt 提供了两种在 QML 环境中使用 C++ 对象的方式：\n\n不管哪种方式，对要导出的 C++ 类都有要求，不是一个类的所有方法、变量都可以被 QML 使用，因此我们先来看看怎样让一个方法或属性可以被 QML 使用。\n\n看起来好像和使用信号与槽的前提条件一样……没错，的确是一样的。这两个条件是为了让一个类能够进入 Qt 强大的元对象系统（meta-object system）中，只有使用元对象系统，一个类的某些方法或属性才可能通过字符串形式的名字来调用，才具有了在 QML 中访问的基础条件。\n\n一旦你导出了一个类，在 QML 中就必然要访问该类的实例的属性或方法来达到某种目的，否则我真想不来你要干什么……而具有什么特征的属性或方法才可以被 QML 访问呢？\n\n只要是信号或者槽，都可以在 QML 中访问，你可以把 C++ 对象的信号连接到 QML 中定义的方法上，也可以把 QML 对象的信号连接到 C++ 对象的槽上，还可以直接调用 C++ 对象的槽或信号……所以，这是最简单好用的一种途径。\n\n在定义一个类的成员函数时使用 Q_INVOKABLE 宏来修饰，就可以让该方法被元对象系统调用。这个宏必须放在返回类型前面。\n\n我给 ColorMaker 添加了两个使用 Q_INVOKABLE 宏修饰的方法，现在 ColorMaker 类的声明变成了这个样子：\n\n一旦你使用 Q_INVOKABLE 将某个方法注册到元对象系统中，在 QML 中就可以用 ${Object}.${method} 来访问，colorMaker 的 main.qml 中有使用 algorithm() 和 setAlgorithm() 的 QML 代码 ：\n\n我在根元素创建完成时初始化 colorMaker 对象，给它设定了颜色生成算法，同时改变界面上切换颜色生成算法的按钮的文字。\n\n\n\n如果你要导出的类定义了想在 QML 中使用枚举类型，可以使用 Q_ENUMS 宏将该枚举注册到元对象系统中。\n\nColorMaker 类定义了 GenerateAlgorithm 枚举类型，支持 RandomRGB / RandomRed 等颜色生成算法。现在 ColorMaker 类的声明变成了这个样子：\n\n一旦你使用 Q_ENUMS 宏注册了你的枚举类型，在 QML 中就可以用 ${CLASS_NAME}.${ENUM_VALUE} 的形式来访问，比如 ColorMaker.LinearIncrease ，上节展示的 QML 代码片段已经使用了导出的枚举类型。\n\nQ_PROPERTY 宏用来定义可通过元对象系统访问的属性，通过它定义的属性，可以在 QML 中访问、修改，也可以在属性变化时发射特定的信号。要想使用 Q_PROPERTY 宏，你的类必须是 QObject 的后裔，必须在类首使用 Q_OBJECT 宏。\n\ntype name 这两个字段想必不用细说了吧？ type 是属性的类型，可以是 int / float / QString / QObject / QColor / QFont 等等， name 就是属性的名字。\n\n其实我们在实际使用中，很少能够用全 Q_PROPERTY 的所有选项，就往 QML 导出类这种场景来说，比较常用的是 READ / WRITE / NOTIFY 三个选项。我们来看看都是什么含义。\n\nQML 中的 Text 类型对应 C++ 中的 QQuickText 类，下面是我摘取的部分代码，可以看到 Q_ENUMS 和 Q_PROPERTY 的使用：\n\n是时候看看它的实现了。翠花，上代码：\n\n看过了怎样实现一个可供 QML 访问的类，这节我们看看怎样将一个 C++ 类型注册为 QML 类型以及怎样在 QML 中使用这个类型。\n\nColorMaker 已经就绪了，现在看看怎样将其注册为 QML 可以使用的类型。\n\n要注册一个 QML 类型，有多种方法可用，如 qmlRegisterSingletonType() 用来注册一个单例类型， qmlRegisterType() 注册一个非单例的类型， qmlRegisterTypeNotAvailable() 注册一个类型用来占位， qmlRegisterUncreatableType() 通常用来注册一个具有附加属性的附加类型，……好吧，我这里只说常规的类型注册，其它的，请您参考 Qt SDK 吧。\n\nqmlRegisterType() 是个模板函数，有两个原型：\n\n先说模板参数 typename ，它就是你实现的 C++ 类的类名。\n\nqmlRegisterType() 的第一个参数 uri ，让你指定一个唯一的包名，类似 Java 中的那种，一是用来避免名字冲突，而是可以把多个相关类聚合到一个包中方便引用。比如我们常写这个语句 \"import QtQuick.Controls 1.1\" ，其中的 \"QtQuick.Controls\" 就是包名 uri ，而 1.1 则是版本，是 versionMajor 和 versionMinor 的组合。 qmlName 则是 QML 中可以使用的类名。\n\n上面的代码将 ColorMaker 类注册为 QML 类 ColorMaker ，主版本为 1 ，次版本为 0 ，而我起的包名则是 an.qt.ColorMaker 。注册动作一定要放在 QML 上下文创建之前，否则的话，木有用滴。\n\n一旦你在 C++ 中注册好了 QML 类型，就可以在 QML 文档中引入你注册的包，然后使用注册的类型。要引入包，使用 import 语句。比如要使用我们注册的 ColorMaker 类，可以在 QML 文档中加入下面的 import 语句：\n\n引入包后，你就可以在 QML 中创建 C++ 导入类型的对象了，与 QML 内建类型的使用完全一样。如下是创建一个 ColorMaker 实例的代码：\n\n如你所见，ColorMaker 的使用与 Retangle 没什么区别。如果你想在别处引用 ColorMaker 的实例，可以给实例指定一个唯一的 id ，就像上面的代码中那样。\n\n如何定义一个可以导出到 QML 中的 C++ 类、如何注册 QML 类型、如何在 QML 中使用 C++ 导出的类型，都介绍完了，现在来看看完整的 colorMaker 。\n\n我构造了ColorMaker 类的一个实例， id 为 colorMaker ，初始化颜色值为 green 。\n\ncolorMaker 实例界面的中间是一个 Rectangle 对象，id 是 colorRect 。我使用 Connections 对象，指定 target 为 colorMaker ，在 onColorChanged 信号处理器中改变 colorRect 的颜色。\n\n界面的底部就是几个按钮，使用锚布局把它们排成一行。 start 按钮的 onClicked 信号处理器调用 colorMaker 的 start() 槽，启动颜色生成器。 stop 按钮的 onClicked 信号处理器调用 colorMaker 的 stop() 槽，停止颜色生成器。而 colorAlgorithm 按钮则每点击一次就切换一个颜色生成算法，同时调用 changeAlgorithm() 函数，根据算法改变按钮上的文字。 quit 按钮一点就退出应用。\n\nmain.qml 还引入了一个新内容：定义函数。这个可以参考 JavaScript 的教程。我们定义的 changeAlgorithm 函数，接受两个参数， button 和 algorithm 。如果你是 C++ 程序猿，可能有点儿不适应：怎么参数就木有类型呢哈…… JavaScript 就是酱紫滴，拥有动态类型，一个变量在赋值时决定其类型。\n\n这就是 colorMaker 的全部了。\n\n好啦，现在再来看看怎样导出一个对象到 QML 中。\n\n上面看了怎样导出一个 QML 类型在 QML 文档中使用，你还可以把 C++ 中创建的对象作为属性传递到 QML 环境中，然后在 QML 环境中访问。我们还是以 colorMaker 为例，对其代码做适当修改来适应本节的内容。\n\n要将一个对象注册为属性很简单，colorMaker 的 main.cpp 修改后如下：\n\nviewer.rootContext() 返回的是 QQmlContext 对象。 QQmlContext 类代表一个 QML 上下文，它的 setContextProperty() 方法可以为该上下文设置一个全局可见的属性。要注意的是，你 new 出来的对象， QQmlContext 只是使用，不会帮你删除，你需要自己找一个合适的时机来删除它。\n\n还有一点要说明，因为我们去掉了 qmlRegisterType() 调用，所以在 main.qml 中不能再访问 ColorMaker 类了，比如你不能通过类名来引用它定义的 GenerateAlgorithm 枚举类型， colorMaker.setAlgorithm(ColorMaker.LinearIncrease) 语句会导致下面的报错：\n\n一旦调用 setContextProperty() 导出了属性，就可以在 QML 中使用了，不需要 import 语句哦。下面是 main.qml 修改后的代码：\n\n你看到了，导出的属性可以直接使用，与属性关联的对象，它的信号、槽、可调用方法（使用 Q_INVOKABLE 宏修饰的方法）、属性都可以使用，只是不能通过类名来引用枚举值了。\n\n我们可以使用 QML 对象的信号、槽，访问它们的属性，都没有问题，因为很多 QML 对象对应的类型，原本就是 C++ 类型，比如 Image 对应 QQuickImage ， Text 对应 QQuickText……但是，这些与 QML 类型对应的 C++ 类型都是私有的，你写的 C++ 代码也不能直接访问。肿么办？\n\nQt 最核心的一个基础特性，就是元对象系统，通过元对象系统，你可以查询 QObject 的某个派生类的类名、有哪些信号、槽、属性、可调用方法等等信息，然后也可以使用 QMetaObject::invokeMethod() 调用 QObject 的某个注册到元对象系统中的方法。而对于使用 Q_PROPERTY 定义的属性，可以使用 QObject 的 property() 方法访问属性，如果该属性定义了 WRITE 方法，还可以使用 setProperty() 修改属性。所以只要我们找到 QML 环境中的某个对象，就可以通过元对象系统来访问它的属性、信号、槽等。\n\nQObject 类的构造函数有一个 parent 参数，可以指定一个对象的父亲， QML 中的对象其实借助这个组成了以根 item 为父的一棵对象树。\n\n而 QObject 定义了一个属性 objectName ，这个对象名字属性，就可以用于查找对象。现在该说到查找对象的方法了： findChild() 和 findChildren() 。它们的函数原型如下：\n\nQMetaObject 的 invokeMethod() 方法用来调用一个对象的信号、槽、可调用方法。它是个静态方法，其函数原型如下：\n\n\n\n先说返回值吧，返回 true 说明调用成功。返回 false ，要么是因为没有你说的那个方法，要么是参数类型不匹配。\n\n第一个参数是被调用对象的指针。\n\n第三个参数是连接类型，看到这里你就知道， invokeMethod 为信号与槽而生，你可以指定连接类型，如果你要调用的对象和发起调用的线程是同一个线程，那么可以使用 Qt::DirectConnection 或 Qt::AutoConnection 或 Qt::QueuedConnection ，如果被调用对象在另一个线程，那么建议你使用 Qt::QueuedConnection 。\n\n然后就是多达 10 个可以传递给被调用方法的参数。嗯，看来信号与槽的参数个数是有限制的，不能超过 10 个。\n\n对于要传递给被调用方法的参数，使用 QGenericArgument 来表示，你可以使用 Q_ARG 宏来构造一个参数，它的定义是：\n\n现在让我们创建一个新的项目，名字是 callQml ，添加 changeColor.h 、 changeColor.cpp 两个文件。 main.qml 内容如下：\n\n紧接着，我使用 QObject 的 findChild() 找到了 quitButton 按钮，把它的 clicked() 信号连接到 QGuiApplication 的 quit() 槽上。所以你点击这个按钮，应用就退出了。\n\n后来，我又通过名字 \"textLabel\" 找到了 textLabel 对象。首先我企图使用 invodeMethod() 调用 setText() 方法来改变 textLabel 的文本，这个注定是会失败的，因为 QML 中的Text 对象对应 C++ QQuickText 类，而 QQuickText 没有名为 setText 的槽或者可调用方法。我查看了头文件 qquicktext_p.h ，发现它有一个使用 Q_INVOKABLE 宏修饰的 doLayout() 的方法，所以后来我又调用 doLayout() ，这次成功了。\n\nHello World 这行字变成了红色，是因为我在 main() 函数中使用 setProperty 修改了 textLabel 的 color 属性。\n\n下面是 Qt Creator 应用程序输出窗口的信息，可以验证对 Text 方法的调用是否成功：\n\nMy God ！终于说完了吗？ QML 中使用 C++ 对象， C++ 中使用 QML 对象……不知道你看明白没？", "link": "http://blog.csdn.net/foruok/article/details/32698603", "publishDate": "2014-07-04 12:22", "title": "\r\n        Qt Quick 之 QML 与 C++ 混合编程详解            \r\n        "}
{"readCount": "33451", "article": "人生天地之间，若白驹过隙，忽然而已。蓦然回首，头上似霜雪，脸上似山川。我的 2014 啊，你就这么毫无眷恋地离我而去了。既然往事已不可追，未来尚未到来，在这年末岁首的间隙，就让我来回忆一下余烟尚存的 2014 吧。\n\n2014 年，对我而言，发生了很多事，不管怎样，我还是一个程序员，这是工作、生活，以及我自己，给我的标签。也许很快这个标签会泛黄、蝶化、零落成泥碾作尘，不过不论怎样，它是我青春的纪念，它仍将伴随着我继续前行。\n\n是啊，这一年我不务正业，虽然每周都会更新博客，但是技术含量越来越低了，扯淡越来越多了。谁说不是呢，我丝毫也没打算掩饰这个。\n\n2014 年，我在 CSDN 开了好几个专栏，没人邀请我，是我死乞白赖找 CSDN 申请的。有这么几个：\n\n我在这上面花费了大量的时间和精力。有个面试官曾问我，你怎么平衡写博客和工作？你叫我怎么说，怎么说都是错……其实你看我的很多文章，要么是大清早，要么是晚上，要么是深更半夜……所以，我以为，这是不会影响工作的。\n\n以前我干事情总是三天打鱼两天晒网，随性而为，不想弄了就停了，今年我希望有些东西可以坚持下来，持续地去做。于是我就这么坚持下来了。关于写博客有什么好处，真是一言难尽，请看这里： 技术人员为什么要写博客。\n\n在这一年里，我在 CSDN 的技术博客排名，由于我出乎意外的勤奋，从万名之外上升到了千名之内。\n\n至于明年还会不会这么写下去，那就两说了，不过“漫谈程序员”系列，至少还会更新 3 个月。\n\n我的书在这里：\n\n《Qt on Android核心编程》主要分两部分，一部分讲述Qt核心的概念，比如信号与槽、元对象系统、网络、Qt Widgets等等，非常适合Qt初学和进阶；另一部分讲解Qt在Android上的开发主题，比如触摸、手势、传感器、JNI扩展等等，适合对使用Qt开发Android应用的感兴趣的朋友。总之这本书既可以作为Qt入门参考，也可以作为Qt移动开发的入门参考。\n\n《Qt Quick核心编程》是专门讲述Qt Quick技术的，从QML语言、Qt Quick基本元素、Model-View、动画、多媒体、网络、Android主题……该讲的都讲了，不该讲的也讲了，总之我觉得它是业内第一本系统讲述Qt Quick的书，是填补空白之作，对于初学 Qt Quick（QML）的开发人员和想进阶的开发者都有很好的参考、借鉴意义。\n\n\n\n这里是 CSDN 对我的专访：专访安晓辉。\n\n有一天我媳妇问我：你写这两本书花了多长时间？\n\n我掐指一算，呀，从开始写到交稿到修改到出版，前前后后七八个月了。\n\n我媳妇说了一句话：没想到我忍了你这么长时间了。\n\n是啊，我给媳妇、孩子带来多大的影响啊，我夜以继日的搞搞搞，牺牲了陪女儿的时间，牺牲了陪老婆的时间，牺牲了娱乐的时间，图什么呀。我媳妇说，难道就为了你的一个梦，就牺牲了我们这许多人？是啊，我太自私了点儿。所以，我决定今年不再写书了。\n\n好吧，我起早贪黑，花费了很多精力录制了一门视频课程。这是与我的书相关联的，但又是独立的一件事情，也是我从未做过的。\n\n是我要做的，很多个早上五点多，很多个晚上十二点，我坚持下来了。\n\n我一直以为自己是一个很稳定的人，不幸的是，我今年让很多人失望了。\n\n今年我历经了四家公司，变换了 N 种身份：部门经理、总监、高级开发工程师、技术图书作者、CSDN 上坚持扯淡的程序员、讲师……惊讶吗？\n\n现在呢，我是一个初创公司的技术合伙人，一切从零开始，我们要来一次说走就走的旅行，而结果，是未知的。未知，才美丽。\n\n2014 是我工作、生活变动最大的一年，再不折腾就老了，这是我这一年的注脚。\n\n我仅仅是在一些方面做了一些尝试（都没有深入）：\n\n一个人的战斗是孤独的，程序员也是社会化的动物，我们需要与他人同在，我们需要帮助他人，也需要他人的帮助。\n\n我申请了CSDN Qt版的版主，我加入了多个 Qt 开发群，我在博客上分享我的技术心得，我还主动将线上的关系延伸到线下……而在以前，我不会去做这样的事情，现在，我觉得这是很自然的事儿。\n\n虽然去的是泰国，毕竟还是出国了，对于我这个土包子，也是一次难得的经历。\n\n林青霞来西安签售，排了一下午队，终于看到了女神，买了本《云去云来》，有签名。\n\n书越看越杂了，有的看完了，有的翻了翻。\n\n列出来才知道，原来还是看了一些书的，总算可以坦然面对“时间都去哪儿啦”这个问题了……\n\n上面我列了很多事情，还有很多未能罗列的，一年之中事情太多太多，多到我已经忘记了 90% 的时间是如何度过的。\n\n我们每个人都有一个记忆的筛子，筛去那些不重要的，留下那些在我们心上刻下痕迹的。\n\n2014 年，对我来讲最重要的不是那些具体的事情，而是：\n\n我终于想通了生活与工作上的一些事。\n\n在我 34 岁的时候可以想通工作、生活、梦想这些事情，虽然有些晚，但我依然感到高兴。\n\n想通的结果是，做事不再过分执着于形式，他人的看法也不能再对我产生致命的影响，虽然我还不能像诗里说的那样“世路如今已惯，此行到处悠然”，但也可以慢慢地跟随心的方向了。\n\n\n\n也许旁人看起来我在折腾（我媳妇有时也这么看），昨天很执着地要告别这个，投奔那个，过两天又要告别刚刚投奔的这个，……不过对我的内心来说，这都是必然，我已经有了一张可以指引我的心灵地图，我每一次的决定，都是坚决的，是受到了发自内心的某种指引，而不是人云亦云。我能够用属于我自己的经验与认知来解释这不断发生的一切，并且，不悖于心。\n\n以后还会发生很多事，或许我还会有很多的犹疑与彷徨，但我相信，我已经有了坦然面对的能量。\n\n最后让我引用济慈的第一首长诗《恩底弥翁》里的几句来概括我现在的认知并结束我的 2014 吧：", "link": "http://blog.csdn.net/foruok/article/details/42191569", "publishDate": "2014-12-29 06:31", "title": "\r\n        漫谈程序员系列：一个老程序员的2014年终总结            \r\n        "}
{"readCount": "32007", "article": "我在“漫谈程序员系列：咦，你也在混日子啊”一文中描述了一种混日子的现状，有朋友说该文只提到了设置目标告别混日子而没有展开论述“如何设立目标”、“怎样为目标而努力”这两个关键问题，也就是说，我提出了问题但答案没有落到实处。这次呢，我决定认真地来谈一谈如何建立目标，如何为目标而努力。一切从个人经验出发，仅供参考。\n\n“目标是个人、部门或整个组织所期望实现的成果。 ”\n\n这个定义看起来冷冰冰的，那还有另外两个更感性的词语：梦想、理想。但这两个词语似乎又过于虚无缥缈，谈起来感觉就像遥遥无期永远无法实现的东西。\n\n理想和目标是密不可分的，结合在一起讨论会更有意义。\n\n有理想才有目标，有目标才有行动，有行动才有结果。\n\n这句简单的话，我以后还会提到，它阐述了理想、目标、行动、结果这四者之间的关系。\n\n感觉文章越写越正式，这偏离了我的初衷，有点惴惴不安，也有点不适应呢。\n\n我把程序员的目标分为三类：公司目标、职业目标、生活目标。\n\n程序员是公司的一份子，参与到实现公司目标的过程中。这个没什么好说的，食君之禄忠君之事，拿了人家的钱，就是要给人家干活儿的。\n\n美国管理学家彼得·德鲁克在其1954 年出版的《管理的实践》一书中，首先提出了“目标管理”的概念，然后目标管理（Management by Objectives，MBO）大行其道，到现在依然被广泛使用，有非常多的公司在使用 MBO 。我之前所在的西安信利软件科技有限公司，也曾经推行过目标管理。当时还学习了另外一本书，（日）串田武则的《目标管理实务手册》，感觉大有收获。\n\n通常公司在实施 MBO 时，还会和绩效挂钩，目标完成得好呢，绩效结果就好，奖金就多，升职加薪就快。\n\n公司目标，一部分来源于远景规划、环境变化，这是纵向的；还有一部分则是横向的，来源于部门之间，不同部门有交叉协作， A 部门的目标要达成可能需要 B 部门协助，或者多个部门在一条产品线上，它们的目标有依赖关系。不管是纵向的还是横向的，都需要自顶向下分解，大目标分成小目标，最后落实到具体的员工来执行，程序员就是负责执行的员工。\n\n公司目标最终分解到个人，产生了个人的工作目标。\n\n如何寻找公司目标、如何分解、如何制定措施、如何执行，我是半吊子，具体就请参考《目标管理实务手册》吧。这里要提的是：\n\n程序员作为公司的一员，必然要参与到公司目标的实现中来，公司成功，个人才可能成功，所以一定要搞明白自己对公司目标能有什么贡献，积极地去实现由公司目标而来的个人目标。\n\n假如你在一个公司，都不知道要干什么，那要么是公司管理出了问题，要么是你的领导不合格，这两种可能性会比较大。如果是这种情况，那你多半可以考虑离职了——在一个不知道要干什么的公司，很难干出成绩来。\n\n职业目标是指人在选定的职业领域内所要达到的具体目标。\n\n这是每个人都要想的问题。\n\n我在面试时经常会问应聘者未来三到五年的规划，这个问题实际上针对求职者职业目标中的中期目标。有的程序员会告诉我说，三年后他希望成为项目经理；另外一些程序员说他希望五年后成为视频解码方面的技术专家；还有一些程序员会不好意思地笑笑，说还没想过这个问题。你是哪种呢？\n\n短期目标一般是2~3年以内的目标，比如你刚进入移动开发领域，那你可能希望花2~3年的时间熟练掌握 Java 语言、Android 应用框架的各个方面以及系统框架的某些部分、能够独立完成较为复杂的 App 开发。\n\n长期目标，5~10 年的规划，一般设定较为长远的目标，比如你希望 30 岁时可以成为 IBM 西安分公司的一线经理，或者希望成为某个小型公司的技术副总。\n\n说来说去，忽然发现我自己就是一个职业目标不明确的人啊，冷汗一身。\n\n其实呢，好吧，我开始为自己辩解了，希望你不要这样。其实呢，我们真能看那么远吗？\n\n现在有一种职业，叫作“职业生涯规划师”。哈哈，我觉得挺好玩儿的啊，这个还可以考 GCDF 证书，谁有兴趣可以考一个。\n\n我要说的是：看不到 10 年后的目标很正常；3年左右的规划也没有，就有点儿说不过去了；假如连一年内的目标都没有……呜呼哀哉，我该说什么好呢，去找“职业生涯规划师”聊聊吧，他们真的可能会帮到你。\n\n假如你有自己的职业目标，那当遇见在一个公司没事儿可干的情况时，你就能非常清楚地意识到自己应该离开，果断的离开。如果碰到间歇性空闲，那职业目标也会帮助你在空档期建立一些有助于实现职业目标的短期计划，让你不至于拔剑四顾心茫然浑身没个着力处。\n\n这个是最难扯明白的……你看那么多小说、散文、身心灵书籍，心理学书籍，励志书籍，都企图说明白这个问题，可是，从你的角度看，谁说明白了？所以呢，我一扯淡的主儿，也不大可能把这个东西说明白，我只有一句话，还是舶来的：\n\n我们在生活中所做的各种努力，多数是为了让自己有归属感和价值感。\n\n我其实是一个懵懂的人，当我决定做一个程序员时，像“我就适合干这个”、“我就喜欢干这个”、“我能干这个”之类的感觉和判断都没有，我的出发点相当朴实：在上一份工作中我感觉不到自己的价值，干得没劲。\n\n所以，从个人经验出发，就工作而言，我觉得有时不是你觉得新的工作特别适合你、能让你一展所长，而是你对上一份工作的现状感到强烈的失望导致你愿意花一些机会成本来尝试一下。如果你新公司所做之事与你个人的职业目标方向一致契合度高，那就更好了，简直是中大奖了。\n\n工作即生活，工作和生活不是割裂的，应当是和谐统一的。\n\n工作是生活的一个重要组成部分，占据了我们年富力强的那段岁月的大部分时间。当我们考虑生活目标的时候，很可能就包括了工作目标。比如你想成为一个唱作俱佳的歌手，那唱歌和创作就会成为你的工作也会成为你的生活。比如你想成为一个伟大的程序员，写出一个新的移动操作系统，把 Android 和 iOS 拍死在沙滩上，那估计你的生活也会因此发生翻天覆地的变化。\n\n我们来说普通人吧，像我们这种屌丝程序员，大部分都是一般人儿，生活平淡、平凡、平常、平实，那么，我们的生活目标是什么呢？\n\n哦，“年轻时拼了命赚钱，年老时拼了钱保命”，这当然不是我们推崇的生活。\n\n那，“起得比鸡早，睡得比狗晚，干得比驴多，吃得比猪差”，自然也不是我们想要的。\n\n在我看来，这都是说不清道不明的东西，你喜欢干这件事儿，他愿意干那件事儿，你钟意一掷千金花天酒地的生活方式，他甘于一箪食一瓢饮的日子，都挺好的。如果你能做到“采菊东篱下，悠然见南山”，我会非常羡慕，甚至还会有嫉妒恨。\n\n我就恨自己这种没有立场的态度！来骂我吧，求虐。\n\n时间永是流逝，而未来不会自动到来。未来需要我们自己去创造。简单点说，我们就是通过实现一个目标又一个目标来抵达并创造未来的。没有目标、规划，就没有你想要的未来。\n\n有时我们看不了太远，那就从近期的目标着手，看看自己今年、明年的想做的事情都有什么，在一张纸上列一列，分析一下。哪些事儿不做就会让自己后悔，那这些事儿就具有重要的意义，要制定计划去完成它们。哪些事情做了会让我们更有成就感，那也可以排在前面去实现。哪些事情具有递进特性，可以延伸出新的目标……分析之后，你就可以确定那么几件必须完成的，这就是你的目标了。\n\n生活目标其实就是一件如果你愿意投入精力去做，就可能达到的事。\n\n比如你今年想考个驾照，明年买辆车，也算一个非常具体的目标。\n\n再比如你今年要找到一个妹子告别单身，明年让你老妈报上孙子，也是一个很切实际并令人振奋的目标。\n\n今年再写一本技术周边的书，这是我的一个目标。\n\n比如你希望用三年时间完成一次职位晋升，从程序员变成软件项目经理……\n\n只要你愿意正视自己并花时间去分析，一定会找出一些你想做的事情。而这些事情，能让你有归属感和价值感的，就可以成为一个好目标。\n\n最后，我想说的是，不论你追求什么样的生活方式，你的生活目标是什么，最终落脚点，其实是“心”，当你或舒缓或紧张地随着时间的河流抛洒自己的生命时，只要你感到心安，感到喜悦，感到平和，这就够了，别的说多了都是扯淡，因此就生活目标这个话题，我打算就这么着了。\n\n要实现目标，得坚持、努力执行你的计划。\n\n前面我们谈公司目标时提到公司目标会分解到个人，还提到 MBO 。那 MBO 里其实不但有目标，还有实现目标的措施，以及对这些措施的管理。如果你是个普通的程序员，公司或者你的上级应该辅助你制定这些东西，如果你们公司不用目标管理法，那我建议你自己搞明白目标管理法是怎么回事儿，因为它不仅适用于工作，也适用于生活。\n\n我们以开发一个推送服务为例来说明如何建立目标和计划。\n\n目标是：开发一个推送服务。这个有点笼统，还需要把服务指标细化一下：\n\n现在服务指标有了，假如你是项目经理，你的 MBO 卡中“开发推送服务”这条内容基本就 OK 了，再填入实现措施、预期时间什么的，就完整了。\n\n而要弄明白实现措施和时间，我们就还需要进一步来考虑实现措施。\n\n在制定实现措施前，这些需求还要进一步细化。我们以第一条，支持 Android 、 iOS 两个平台为例来说明。\n\n服务端是不需要跨平台的，你可以使用 Windows 、 Ubuntu Server 、 Cent OS 之类的，随便选一个好啦。服务端还需要管理界面，能让运营人员从管理界面上编辑并提交推送消息。估计还得要 API 接口，可能有些程序会自动产生要推送的消息。\n\nAndroid 需要实现接入模块，必须是 Service ，还得应对待机问题、第三方安全软件查杀问题。 iOS 必须考虑到苹果的限制，可能要与 iOS 内置的 push 机制结合。\n\n这里面事儿挺多的啊。再挑一个来细化，拿通信协议说吧。\n\n通信协议有开源的啊，比如 XMPP ，MQTT ，当然也可以自己定义。那选择哪个呢？你要开放给第三方使用吗？\n\n你看，有这么多事儿等着我们做呢，兴奋吧。不管你顺着哪个需求点梳理下去，都会分解出很多功模块，每个功能模块又可以再拆分……本文不可能来干这么专业的事儿，留给项目经理吧，他们干这个靠谱。我在这里只是想说明，在工作上，你要想实现一个目标，必然是得经历目标分解的过程，把大目标分解到一个又一个小的、可以在三两天就能实现的任务，这样才具有可执行性。然后把这些任务排排座，每个任务都给个时间盒，计划就出来了。最后就可以按计划来执行你的项目完成你的目标了。\n\n前面谈职业目标时提到，清晰的职业目标会帮助你渡过工作期间的闲暇时间（如果有的话）。\n\n举个我个人的例子吧。\n\n2014 年年中，我负责的产品终止开发（只剩维护），有几个月的时间没什么具体的事情可做。晃荡一天可以，晃荡时间长了这心里发慌啊。幸好我对技术情有独钟，也比较爱钻研（脸有点儿红，其实我是个浅尝辄止的家伙），于是，我就想看看之前用过的框架—— Qt ——怎么样了，于是就去研究，哇，居然支持 Android 了，也支持 iOS 了！兴奋呢，立马下载最新版本，搭建环境，开始写代码做实验，完了总结一下，分享到博客上。\n\n就这么着，继续学习技术，帮助我度过了原本可能无所事事的几个月，庆幸时光没有白费。那段时间的研究，还机缘巧合出了本书：《Qt on Android核心编程》。说实话我很享受那个学习、写书的过程。天天晚上熬夜写，天天早上早起写，周末窝在家里调试代码，乐而不觉其苦。很多事情都是这样子的，你喜欢干就不觉得苦。当我写完书时，反倒觉得空荡荡的。\n\n其实我们在开发过程中，会用到各种各样的技术，多数时候为了赶项目，都是以实现功能为第一个要务，只见树木不见森林，用过了就扔一边了。新项目来了，急吼吼地又忙活去了。但你要想提高，就得回顾、总结、拓展，把用过的那些技术一一列出来，在闲暇的时候，以你用过的那个技术点为中心来画同心圆，一层层向外扩展，丰富你的积累。这是不辜负大好时光的好办法。\n\n也有程序员的中期职业目标是做技术管理，那如果你有空闲的时候（没空闲也要挤时间），那就可以看看项目管理方面的书籍，比如《项目管理知识体系指南（PMBOK指南）》、《项目管理：计划、进度和控制的系统方法》、《人月神话》、《带人的技术:不懂带人你就自己做到死》、《软件工程（实践者的研究方法）》、《项目管理修炼之道》……等等，让自己对项目管理和团队管理有个理论上的认识。相关书籍很多，简直可以用汗牛充栋来形容，我列出的那些不过九牛一毛，更多的书籍你可以利用亚马逊之类的网站的相关推荐来了解。\n\n生活就像翻山越岭，一山过去还有一山，我们就这么一直不断地攀登。在攀登的过程中，有时你会发现新的山峰，新目标就诞生了。\n\n在我写作《Qt on Android核心编程》的过程中，我发现 Qt Quick 这个框架简洁、优雅、强大，而我没有照顾到它，心里总不是那么安宁，觉得这么好的东西应该给它一点关注。于是我就定了目标：研究 Qt Quick ，写一本专讲 Qt Quick 的书。\n\n有了目标，我很快从写完《Qt on Android核心编程》的空虚中走出来，把自己的闲暇时间都投入到研究 Qt Quick 中了。\n\n选定要讲的内容，列出大纲，制定计划，评估每个主题预期花多长时间，写成文章又花多长时间，最终制定了一个粗略的计划，准备在三到四个月内完成整个工作。\n\n有了计划后，我就梳理安排自己的时间，把晚上、清晨、周末都用上，一个主题一个主题的去研究，学习时记录自己的心得保留示例程序……\n\n3 个月过去后，我积攒了大量的原始资料，《Qt Quick核心编程》也基本完稿了。\n\n没人要求我写书，这都是因为我本身喜欢写作又喜欢技术，是一种自发的行为。研究学习技术的过程让我感到舒服，写作让我觉得自己有价值，所以我愿意做这样的事情，哪怕金钱上的回报寥寥也不以为意。\n\n最后的最后，我们必须强调的是：一切目标、计划，必须落实到行动上来，否则都是空谈！个体之间为什么有那么大差异？除却拼爹的因素，最重要的一点就是：有的人坐而论道，有的人用行动证明自己。", "link": "http://blog.csdn.net/foruok/article/details/44096235", "publishDate": "2015-03-18 07:25", "title": "\r\n        漫谈程序员系列：怎么告别“混日子”            \r\n        "}
{"readCount": "28667", "article": "前段时间（大概是8月份吧）我终于拿到了驾照，科目一、科目二、科目三、科目四都是一次性过的，没有给教练塞钱也没有给教练递烟。考科目三（路考）时，有个女生没能通过还被陪考员讽刺，伤心地哭了，梨花带雨让人心疼。同行的还有两个学员考了三次都没过。媳妇的同事听说我什么致礼的事儿都没干居然一次性过了，对我表示了一些些敬仰之情。好吧，我承认这让我有点儿沾沾自喜。可是我们在谈程序员啊，和驾校有两毛钱关系没有？别急，兄弟姐妹们，有的，这个真的有。\n\n有一次我在上海Qt开发群（企鹅号279906625）和人讨论软件开发与炒菜大妈的可比性，当时我说将来的软件开发会很简单，成为像英语、驾驶一样的基本社会能力，你能学会炒菜就能学会编程，可以根据自己的需要从半成品软件商店里购买组件，按自己的需求加工成成品软件。我相信不久之后这个就会实现，用户可以用自己的需求和智慧，借助一个平台，像搭积木一样生产软件。虽然实际上他们不懂我们现在谈论的所谓编程、开发，但确确实实，他们可以按需开发出自己的软件来，而且很可能他们都不需要懂计算机，只要在手机之类的移动设备上搞两下就好啦。\n\n其实现在硬件已经在往这个方向发展了，什么面包板，什么模块化，什么什么什么呀，看看这个文章：Make!Sense 动手好伴侣，带你轻松做实验。摘要：\n\n简单来说，Make!Sense 可以看作是一套传感器连接系统，它自带通用接口，可以快速便捷地将不同类型的传感器连接到电脑或智能手机。作为一个有趣的学习互动平台，Make!Sense 最大的亮点就是操作简单，小盆友们可以用它感受身边物体细微的运动、空气中的水分、光线、温度甚至心跳，好奇什么，就感受什么。\n\n\n\n要说司机就得说驾校，我还想说出租车、快的、滴滴、易到用车……因为我是个真诚的喷子，想到哪里喷哪里，不会掩饰，我打星际争霸时最喜欢的是口水虫，编上个七八队，哇喔，喷的那个叫壮观，瞬间平地变湖泊……现在社会上有些资源被某些谋取私利的官、商占据了，所以产生了很多问题。就比方说驾校，为什么那些无牌驾驶十几年的老黑司机也要到驾校来花个钱呢？这不扯淡吗……应该有自考的途径啊。\n\n驾校会教我们控制汽车，比如怎么把握方向盘，怎么使用离合、油门、刹车，怎么半联动，怎么起步，怎么半坡起步，怎么过S弯，当然还有调整后视镜、侧方、倒库等等，对于新手来讲，这些其实也是比较伤脑筋的。但是所有这些都是相对简单的事情，大部分学员通过练习都能掌握，不会有太大的问题。多练习一下，科二、科三不成问题，至于科一、科四，到驾校一点通做两遍题，对于上过初中的朋友们也没太大问题，我的堂兄弟小学文化水平也过了，去年春节回家他开车接的我。\n\n当你花上五块钱买了个实习的黄牌子贴到车屁股上准备上路时，真正难受的经历才正式开始。这时才是真正学习开车的时刻！虽然控制汽车是成为好司机的非常非常重要的前提条件，但远远不够，很远很远，比你爱一个人那个人却在搞基还要远。只有你看淡了风云，能够预料和避免大多数意外的情况时才能成为一个好司机。不幸的是，驾校不可能教给你这些技巧，你会漂移的朋友也不可能教会你，神仙姐姐来了也教不会你反倒会让你分心YY。\n\n总之一句话：拿到了驾照，实际你会不会开车，只能听天由命了。哦不，我要传递正能量，靠人不如靠己，此时此刻，只有你能对自己的生命负责，所以你必须Fighting，学会应对所有的紧急状况，你必须亲自经历过很多驾驶危险并且要幸存下来才能拥有教练们企图通过说教、演示来教给你的那些应急反应能力。这是少林寺的十八铜人巷，要下山必须得通过。什么，你想启用飞行模式？抱歉，待你长发及腰，肋生双翅再说吧。\n\n舒马赫，阿隆索，汉密尔顿，阿兰琼斯，普罗斯特……这些名字你可能知道。好吧，也许，韩寒这个全民岳父你更熟悉……这些知名的赛车手，还有在《头文字D》中送豆腐却能在山道神漂移的周董，与刚走出驾校拿到驾照的学员们，到底有多大差别？到底哪些新手司机可以成为未来的神司机？\n\n这是一个问题，很大的问题。\n\n在《漫谈程序员系列：程序员零门槛？》中我说软件开发门槛为零，在本文开始也45度角仰望星空畅想了404也能开发软件的悲惨未来。亲们，不要怕，这里我要做一点点修正，所谓失之毫厘谬以千里，我这点微不足道的修正，会大大改变本系列文章关于软件开发门槛这一话题的未来走向。\n\n所谓的没有门槛，是指：成为新手程序员没有门槛。也许之前你已经笑话过我图样图森破，我这么一改，哈哈，Bug没了吧。\n\n如果你想成为程序员，或者被逼迫必须成为程序员，那可以去达内、北大青鸟、黑马、野马等等培训机构学几个月，也可以自己到软件开发4S店当几天学徒，基本上就可以掌握一门编程语言，能够控制某个IDE，让它Run出一个Hello World或者别的什么。此时此刻，你满怀激情地成了4B青年，可是“金樽清酒斗十千，玉盘珍羞直万钱”，买个房子贷难还，娶个媳妇岳母嫌，压力不是一般的大啊，于是你停杯投箸不能食，拔剑四顾心茫然，最后只能辗转反侧寤寐思服……那么，你想什么呢？\n\n终于可以连连看了，此时你就相当于刚从驾校出来的新手司机，站在钢筋水泥的丛林里，面对着人潮拥挤又车来车往的十字路口，眺望堵到霾云深处的车流，开始了事关将来的深度思考：什么时候我才能成为一个神乎其技的好司机，穿越这神鬼难破的堵局？\n\n其实作为程序员，你也要想这个问题：我来了，面对那么多的大拿、怪咖、呆萌，我的路在何方？怎样找到那条通往优秀程序员的羊肠小道？\n\n入门不难，优秀很难！上有六龙回日之高标，下有冲波逆折之回川。黄鹤之飞尚不得过，猿猱欲度愁攀援。肿么办？肿么办？\n\n摆在你面前的有很多选择：蹩脚的程序员、合格的程序员、优秀的程序员、卓越的程序员，还有在职退休的好汉……\n\n你要做哪一个？你能做哪一个？怎样成为你想做的那个？\n\nBig Problem ! 你需要看《自我发现，找到适合自己的职位》，step into ，或者F11，进去看看吧。不过这篇文章目标太大，说的都是一般之理，没有针对“程序员”这个与“农民工”、“保洁员”一样响当当的称谓所代表的社会群体投去特别的温暖与关注。因此，我会在漫谈程序员系列文章中来讲这个问题，稍微详细一些的来唠一唠它，不过不是现在……\n\n有个哥们儿（叫他GG吧）考科三，起步、百米加减档、超车都O了，快结束时，陪考员说，减速停车，这哥们一听暗暗吐了一口长气，心想终于通过了，然后右脚猛踩油门，陪考员反应挺快猛踩副驾的刹车，结果呢这哥们挂了……\n\n其实我的神经好错乱的是吧……\n\n当然普通程序员和优秀程序员可能不像两幅图里的区别那么明显，但他们之间确实有一条鸿沟……\n\n有哥们儿已经红眼了，愤怒了：博主，丫到底敢不敢说明白！到底差别在哪里？\n\n咦，你真关心这个呀……其实我不是马路边的贾半仙，很难一言半语说明白，但是，姑且从以下三方面喷喷吧。\n\n请先阅读《漫谈选人与培训》了解知识、技能、才干的差别。这里咱搞个摘要：\n\n才干就是你那些贯穿始终的思维、感觉和行为方式，它基本上是与生俱来的。任何可以产生效益的贯穿始终的行为模式都是才干。多数时候我们并没有意识到它们的存在，只要你有意识的识别出它们并发扬光大，就可以有所成就。因为，取得出色成绩的关键在于使你的才干与工作相匹配。\n\n理解了才干这个说法，我是再也不迷信“勤能补拙”、“扬长补短”这些个看似励志的说法啦。假如你要干好一件事情，必须要改变你的才干和个性，只有当你非你时才可以干好它，那这件事情压根儿就不适合你。换句话说，它不是你的菜。\n\n上小学时老师总是批评有的小朋友马虎，是马虎虫……马虎可以改变吗？对于有些人可以，对于有些人不可以，因为马虎是他的天性。有的人小学马虎，中学照样，成家立业了还是粗心大意丢三落四马马虎虎……你让他改什么？马虎就是他的天性啊。请表逆天，亲。\n\n还有些项目经理对团队里的程序员不满意，说P1要是多想想，用心一些，就不会写出臭虫乱爬的程序；说P2要是责任心强一些，就不会天天上班打游戏……其实，哥呀，有的人就是不认真，不用心，天生就那样；而有的人就是不负责任；这些都是教不会的，改变不了的……你寄望于改变那些无法改变的东西来提高某人的工作效率和产出，那可真是痴人说梦话缘木求鱼……\n\n那造就优秀程序员的，是哪些才干呢？\n\n因为才干不太能直接看得出来，但它会决定你有什么样的行为。所以，从行为上，其实也可以看出普通和优秀的差别来。\n\n当然还有其它的……这个列表可以很长很长\n\n因为普通程序员老是和测试MM沟通，告别单身的几率比优秀程序员大100倍。", "link": "http://blog.csdn.net/foruok/article/details/40075201", "publishDate": "2014-10-21 08:56", "title": "\r\n        漫谈程序员系列：看看你离优秀有多远            \r\n        "}
{"readCount": "27483", "article": "程序员薪水有高有低，有的人一个月可能拿30K、50K，有的人可能只有2K、3K。同样有五年工作经验的程序员，可能一个人每月拿20K，一个拿5K。是什么因素导致了这种差异？我特意总结了容易导致薪水低的九大行为表现，避开这些大坑，你就离高薪不远了。\n\n他不懂得只有春天播种，秋天才会有收获。刚刚付出一点点，甚至还没有付出，就想要得到回报。技术刚刚掌握，能一边百度一边干活了就觉得该拿到多少多少钱了。找工作先想着多少多少钱，入职了没干几个月就想着要加多少多少钱，干了没几个月，薪水要是没涨，就放弃了，准备通过跳槽加薪，不跳槽的话，往往也会因为没加薪而牢骚满腹，工作敷衍了事。\n\n一个程序员的价值，是通过他带给公司的价值体现的。先给公司带来了价值，然后才会反过来在薪水上体现出自己的价值。公司都很现实，很少会为你的潜力买单，在你还没有体现出价值时就给你很高的薪水。\n\n在生活和工作中，一定要懂得付出，不要那么急功近利，马上想得到回报。天下没有白吃的午餐，你想获得什么，就得先付出什么。唯有种下种子，然后浇水、施肥、除草、杀虫，然后才能等来收获。\n\n很少有哪个岗位的人像程序员这样需要持续不断的学习，软件开发的技术日新月异，而每一项技术又往往博大精深，不持续、深入钻研是很难掌握的，更别谈精通了。如果你对一项技术不能深刻理解熟练应用，表现出来的水准仅仅是能干活、还行，那很难说会有公司愿意为“还行”付出大的代价，只有脱颖而出，才可能备受重视。\n\n假如你对学习、掌握、精通技术没有兴趣，面对不断涌现的新语言新技术新框架没有学习欲望，那但就软件开发这个工作而言，你不但眼下不太可能拿到高薪，将来也不会。在这样一个快速变化的时代，只有不断地学习才不会被抛弃。\n\n虽然我们都知道努力学习可以改变我们的技能水平，持续努力不懈坚持可以让自己有所建树，可还是有很多人浅尝辄止，三天打鱼两天晒网，搞两下能Run就放下了。\n\n人和人在聪明才智上的差距并没有想象中大，甚至很多时候，从大多数人的努力程度之低来看，根本还轮不到拼天赋。如果两个人的实力半斤八两的话，热情工作努力坚持的人，一定比较容易成功。\n\n做事拈轻怕重，不愿挑战。殊不知能力就是在不断挑战不断突破自己的过程中历练出来的。在一个公司里面，经常承担高难度任务的程序员，一定是成长比较快的，薪水增长也一定是比较快的。越是困难的事情，越能体现出个人价值，也越能带给个人成长。\n\n万事起头难，不要害怕困难。事情做不好往往不是因为没有能力，大都是由于缺乏恒心。只要不怕困难，坚持前行，一定会有不一样的收获。\n\n事业就像女人，谁去追求，谁就能得手。金钱也一样。\n\n工作上不管什么事儿，反正不是自己的事儿，缺乏责任心，干好干不好都无所谓，对交付承诺、对产品质量都不在意，没什么事儿能让他上心。\n\n一个人的责任心如何，决定着他在工作中的态度，决定着其事业的好坏和成败。如果一个人没有责任心，即使他有再大的能耐，也不一定能做出好的成绩来。\n\n工作稍有不顺，就怨气沸腾，这个怎么怎么样，那个怎么怎么样，而我怎么就这样，任务不公平，资源不公平，那谁谁不支持我，那谁谁不配合……\n\n抱怨不能使事情变好，反之，它会让负面情绪蔓延，蚕食你的精力和时间，让你产出更低。成功者永不抱怨，抱怨者永不成功。立刻停止抱怨，早一分钟停止，你就离目标近一分钟。\n\n每个人的一天都只有24小时，人和人的差别就在于如何利用时间上。\n\n有的人每周都有目标，每天都有计划，早上起来会想今天要做的几件重要的事，晚上会回顾今天完成的事，总结干成了什么干坏了什么，还会有计划的学习新知识新技能，这样日积月累不断坚持，每一天都是高效的，每一天都朝着更丰富更完美的自己前进。\n\n而有的人则漫无目的，走哪算哪，到了公司，上午基本做不成事儿，到下午了还不知道要做什么，晚上也发愁如何消磨时间……\n\n虽然工作的一大目的是获取薪水，养活自己以及供给家庭所需；但是，这只是工作最直接的报偿，同时也是最低级的目标。\n\n如果我们为薪水而工作，将注定我们是短视的，也将注定受到最深的伤害。假如你看不到工资以外的东西，斤斤计较于薪水、福利、职位等，那外界的些微风吹草动就可能让你像浮萍一样飘来荡去，你很快就会失去平衡，失去信心，失去热情，失去平和，进而在工作时总是采取一种应付了事的态度，能少做就少做，能躲避就躲避，觉得只要对得起自己的那份薪水就成了。长此以往，你追求的高薪水反倒得不到。\n\n我们进入一个公司工作，是为了自己，不是薪水也不是别人，比薪水更重要的，是成长和成就自己的机会。我们一定要明白，公司、企业、组织，都是我们锻炼自己、修炼自我的平台，我们不是为薪水工作、不是为老板工作、不是为家人工作，是为实现自我而工作，是为更完美的自己而工作。\n\n有一部分人从事软件开发工作，并不是因为喜欢，也没有干着干着从不喜欢变成喜欢。他们可能是喜欢软件开发附带的高薪水——平均薪水比其他行业高。人做一件自己不喜欢的事情时，心理上没有亲近感，不会想着怎样把事情做得更好，往往是差不多就成了，不太可能有精益求精积极向上的追求。因为在做不喜欢的事情时，情感上是拒绝的，情绪上是想逃离的，总想着早点儿完事儿拉倒，每一天去单位时不是充满期待，而是各种担忧、烦躁、畏惧，到了单位，稍有困难或不顺心，就会消极、抱怨、抵触、拒绝……\n\n做喜欢的事，能最大可能发挥一个人的潜能和热情，会最快速地通向成功成就自己。而做不喜欢的事，一开始就注定了事倍功半，最后也往往会是痛苦不堪或半途而废。", "link": "http://blog.csdn.net/foruok/article/details/49245349", "publishDate": "2015-10-19 07:02", "title": "\r\n        月薪3万的程序员都避开了哪些坑            \r\n        "}
{"readCount": "25143", "article": "在国内，很多人说程序员是吃青春饭的，一开始说过了30岁就得转行，后来又有人35岁是一道坎……看起来好像程序员真的和风尘女子一样，注定有朝一日会年老色衰不再受人青睐。\n\n真的程序员，敢于直面惨淡的人生和淋漓的鲜血，一定能够在荒草满布的岁月荒原里踏出一条自己的路来。\n\n其实别人说的话，听一听就算了，决定还得自己来做。面对别人的怀疑、否定、讥讽，我们只需要坚定地前行，做给他看。行动是最好的证明，多坚持一秒，未来就会不同。\n\n相当大一部分的程序员都在做应用层面的开发，所做的软件用来解决特定场景的问题，给用户的工作和生活带来方便。\n\n开发一个应用，经常会用到高级语言和框架，比如 C# 和 .NET ，比如 C++ 和 Qt ，比如 J2EE ，比如 Ruby on Rails ，比如 Python 和 Django ，比如 Java 和 Android ，比如 Objective-C 和 Cocoa Touch ，比如 JavaScript, PHP……太多了，数不胜数。\n\n应用层面的开发技术，很多人觉得门槛低，小年轻和富有经验的老资格差别不大，后浪会把前浪拍死在沙滩上，所以当新一茬韭菜长成时，老一茬就得玩完了。\n\n其实不是的，即便从纯技术的角度来讲，你对一个语言和框架的理解与把握程度，也会严重的影响开发效率和产品质量。\n\n什么样的人会被轻易替代？不求甚解，似懂非懂，干了多少年还看不透所用技术的本质，遇到问题仍然懵懂不解茫然无措，这样的程序员，注定很快被一大波正在赶来的小鲜肉挤下工作岗位。\n\n假如你对一门语言的各种特性都体察入微了悟于心，假如你对一个框架的机理和各种应用场景都有独特的理解和丰富的实践经验，那你几乎是不可替代的，你已经成了这个语言和框架方面的专家，价值不可估量。你的一句话就可能为一个项目节省几个月的时间，别人一筹莫展的问题到了你这里分分钟就搞定。\n\n所以，不要理会“能 Run 就行”、“完成任务就可以了”、“用不到学那么深干什么”之类的话，在你用完一项技术解决了一个实际问题满足了某个需求之后，继续钻进去吧，多学一点，深入一点，日积月累，你必然会与众不同。上班时没时间，那就下班了继续投入。记住，你的学习和研究都是为了自己，不是为了老板，不是为了项目，你唯一的产品就是你自己，而这个产品值得一辈子打磨。\n\n有一些技术，门槛是相对较高的，比如汇编语言，比如操作系统内核，比如驱动……正因为门槛高，回报也高。比如你熟悉 Windows 内核或 Android 内核，能够熟练撰写各种驱动，那找个月薪五六十K的工作不成问题，百八十K都不在话下。惟其稀缺，所以保值。\n\n大部分程序员其实不懂算法，都是用框架里的模块拼积木。如果你妙悟算法真谛，那你就超越了90%的程序员了，你的重要性和价值将不可估量。\n\n比如你精通图像处理算法，比如你精通视频编解码算法，比如你精通搜索推荐相关的算法，比如你在模式识别领域有建树……试看谁能挡得住你前进的脚步！\n\n在一个行业内持续积累，对业务的理解到位，积累深厚，你的价值是巨大的。不信你去浏览招聘网站上的岗位需求，99%都要求相关行业背景。所以，选择一个靠谱的、前景好的行业非常重要，只要这个行业能够不断发展、前进，你的积累就是有价值的，你自己就是不断增值的。\n\n特定领域的业务有一定门槛，比如金融，比如电力，比如电商，比如彩票，比如考古，比如医疗……在这些行业里，你是个业务门儿清的程序员，即便技术不是特别优秀，那也是价值无限的。\n\n互联网时代，产品为王。有产品意识，懂产品思维的程序员，是最受欢迎的人群，也是最能做出好产品的程序员。\n\n商业意识通俗地讲，就是要思考这个产品能不能卖出去，好不好卖。这个一定是要有的，程序员虽然很少直接接触市场，但是一个产品成功与否，多数时候就是看市场表现，如果你能关注市场，从市场的角度来看待技术实现，接纳“技术为市场服务”的理念，那你更容易把产品做好。\n\n用户意识是最容易理解的，它是说我们要从用户的角度来思考这个产品该如何设计，因为产品好不好用最终由用户说了算。如果你在实现产品时也能站在用户的角度来思考，斤斤计较一个功能是否符合应用场景、是否与用户的行为特点吻合、是否贴合用户的使用习惯，那恭喜你，你超越了90%的程序员——大部分程序员是按产品经理和UI设计师的要求来实现产品。\n\n创新是人类发展的源泉，是社会进步的动力，同样也是产品的核心竞争力。但这里所说的创新不一定是那种颠覆性的创新，也许是把众多不被重视的细节做到更好，也许只是把另外一种理念引入到这个产品中去，也许是像海底捞的员工一样给用户不一样的感受，这些都是创新。创新意识是产品经理必须有的，否则，他永远不会有进步，产品永远也做不好。创新意识也是优秀的程序员必须要有的，否则他就不能把一个产品实现得很好，不能把产品的核心竞争力演绎到极致。\n\n当下已不再是孤胆英雄单兵作战的年代，我们要想做好一个产品，多数时候都需要一个团队。团队意识是必不可少的，你是和一帮程序员在一起，你还和产品经理、UI设计师、业务分析师、项目经理等等在一起，如果你能融入团队，并且能影响、促进其他人为共同的目标做出有效的努力，那么，你这样的程序员，是无敌的，是国之瑰宝！\n\n我开通了微信订阅号“程序视界”，关注即可第一时间看到我的原创文章以及我推荐的精彩文章：", "link": "http://blog.csdn.net/foruok/article/details/46407723", "publishDate": "2015-06-08 06:48", "title": "\r\n        程序员保值的4个秘密            \r\n        "}
{"readCount": "21192", "article": "2015的5月已经过半了，3、4月份的求职高峰已经过去了，你换工作了吗？\n\n这次我们想聊的，就是程序员跳槽这件事儿，我打算从三个方面来说：\n\n我在“自我发现，找到适合自己的职位”一文中提供了“周末探视法”让大家分析自己对当前工作的感觉。这个方法很简单，你只需做下面这件事儿：\n\n在周日的晚上，想着明天要上班了，记录自己此刻的念头和心情。\n\nOK。就是这样。如果你内查到犹豫、恐慌、紧张、担忧、抗拒之类的情绪，很可能你已经需要慎重考虑换工作这件事儿啦。\n\n周末探视内心感觉是一种通用的做法，每个人在使用时都可能找到一些导致自己必须换工作的具体情况。那这里是我遇到的和想到的一些情况，列出来大家相互印证一下：\n\n经常有公司上马一个产品时行差踏错，做着做着就感觉这玩意儿恐怕是方向搞错了，不会有前途了：要么错过了好时机，要么没有切中刚需，要么这个产品所需要的营销运营能力以及资本都不具备……总之，眼看着事儿难成，继续做下去只是聊以自慰。作为程序员，你需要在一个有希望的行业里做有希望的产品，这样自己才有希望。\n\n互联网时代，公司起来或倒下都很快。稍有不慎，一个公司多年积累就可能轰然崩塌，资金跟不上，亏损，最终面临倒闭。这些都是能看到的，流言四起，议论不绝，周围的人已经纷纷心猿意马四处出击，准备换工作了，你怎么想呢？\n\n有时你自觉有才有能力，却总被安排打下手，深深觉得不受重视，有一种英雄无用武之地的感慨，此时也有必要考虑换个能发挥你长处的地方。士为知己者死，千里马需要伯乐。在不对的地方跟着不对的人，很难做出对的事情，自己也很难由此成长起来。当然，要你真的有才。因为，怀才就像怀孕，只有足够大时别人才看得出来，你才能享受到相应的重视和特别的待遇。往往我们觉得有志难伸，只是我们的才还小，没被别人看到而已。\n\n公司不尊重人，领导不尊重人，看不起下属，内心不屑鄙夷，动辄横眉冷眼呼来喝去，甚至把你当牲口用，给你头上蒙个黑布罩就想让你拉一辈子磨。他只当你是一颗小石子，用得着就捡起来，用不到一脚踢飞。这样严重缺乏基本尊重的环境，不待也罢。\n\n你只要完成上头交待的任务就行了，你的技术之路如何发展，你在公司的职位和等级怎么晋升……从来没有人找你谈过，也没有人真的关心你。\n\n有时公司和产品到一定程度，新东西少，老东西多，维护性东西多，你技术上已经到顶了，不能再进一步，眼看着没机会再挑战了。技术就如逆水行舟，不进则退。你木有锻炼和挑战的机会，是很难百尺竿头更进一步的。\n\n当然你可能不做技术，做管理。可一个萝卜一个坑，你上面的人不走，你就没有机会。上面的人还年轻，一时半会儿既不会内退也不会走人，人家干得好好的呢。那你呢，短时间内怕是看不到希望了。\n\n凡此种种，不论怎样你都看不到自己的成长空间在哪里……\n\n一般普通人的生活路线，在特定时期都会面临谈对象、买房、结婚、生子等问题，一但你到了这个年龄段，各种压力和支出纷至沓来，很可能你原来的收入已经不足以维持生活，而此时放眼单位和工作，一时半会儿升职加薪无望，迫于生活的压力，你是否会选择换一个收入更好的工作呢？\n\n你和老板或上级发生矛盾，比如经常性的在某些事项上分歧严重，经过努力也无法调和，那很可能会给你带来比较大的压力和不适，让你心生不公、委屈、厌倦、绝望，感到再也无法待下去了……\n\n“昔孟母，择邻处。”这其实讲的是外在环境对人成长的影响。工作上也是一样的，假如你周围的人都浑浑噩噩不思进取，那你也很难一枝独秀勇往直前挽狂澜于既倒。这种环境就像一盆污水，你就是一滴昆仑山矿泉水，滴进去也很快就被同化了，赶紧走人是正事儿。\n\n当你心已不在所做的事儿上，无法保持激情，也不能全身心的投入，整天懒洋洋的，干好干不好都不在乎了，那你也该和当下的工作说拜拜了。因此这种状态，消磨的是自己的生命。\n\n大部分人需要和周围的人比较来平衡自己，当你发现同行业同经验的小伙伴们拿的钱比你多出一大截子时，你就很难淡定了。虽然有人说“追求财富不如追求满足，满足才是最大的财富。”，可是你的价值也需要通过收入来体现，当收入和自身价值严重脱节时，恐怕满足感、归属感是很难再有了。\n\n有的公司有的领导很奇葩，宁愿花更多的钱请新人，也不给老员工涨工资，以至于同样的工作经验，新来的人居然工资比老员工高一大截，这叫辛辛苦苦兢兢业业的程序员情何以堪啊。\n\n这也是有的。比如你的公司老是没日没夜的加班，晚上十点走都有人给你白眼，而你媳妇又怀着小宝宝，你说这怎么受得了……\n\n一旦你决定要离职，（除非事发仓促，比如家庭变故之类的）一定要做充分的准备。那么，在跳槽前我们都要做哪些准备工作呢？\n\n其实我觉得从大的方面讲就三件事儿：\n\n人贵自知，自知者明。这是老化俗话套话烂话，好吧，我承认，但，这是有道理的。\n\n要知道我能干什么，这也是很重要的，一定要明了自己的能力边界。比如：\n\n很重要的一点是，我愿意干什么，对，就是这个。因为你从一个地方离开，一定是这个地方有什么东西你不能接受，那你找新工作时，一定要考虑自己愿意干什么，如果这个考虑不清楚，那才出虎穴又入狼窝的可能性就非常大。\n\n最后我们还要想我能失去是什么，千万别并小看这一点，这是相当重要的。这世上并不存在完美的工作，没有哪个公司、哪个岗位、哪个产品是为你量身定做的。就算你狗屎运，碰见了这么一个机会，那随着时间的轮转和周围环境的变化，曾经你觉得百般熨帖的，也会慢慢出现各种不适。所以，无论何时，痛苦和快乐是伴生的，你必须考虑取舍。在找工作时尤其如此，鱼与熊掌不可兼得，这是必须明白的。\n\n类似的太多了，总之我们需要明白什么对我们是最重要的，然后就可以在必要的时候，从那些不那么重要的东西里舍弃一些\n\n我们找工作时，需要结合自己的现状，瞄准特定的行业和公司来做准备，跑到网上见什么职位都投，绝不是最好的方法。\n\n举个例子，比如你之前在做医疗软件，你还想做这方面，那你找工作时就要分析你所在的地区做医疗软件的公司分布情况，每家公司都什么状况，做了分析之后，锁定目标，再来看哪家公司在招人有机会。\n\n那如何知道有哪些公司在做类似软件呢？你在一个行业里待着，一定要了解这个行业的现状，前景如何，竞争对手都有哪些，竞品优势在哪里……虽然你是技术，但也要了解这些，否则换工作时会手忙脚乱遇到各种状况。如果你自己在日常工作中接触不到，那也可以从公司里其他岗位的同事（比如市场、销售、产品等）那里了解到。有心，你一定可以知道。这是和你的工作息息相关的，绝对有必要去了解。\n\n一旦你锁定了行业和公司，找工作时就不会那么随意那么匆忙那么慌张了。凡事预则立不预则废，机遇只青睐有准备的人。\n\n分析了自己又分析了公司，接下来就是撰写简历了。网络上有很多谈如何写简历的文章，可以搜搜看看，找一个模板来参考，先根据自己的工作经验写一份基础简历，把你前面对自己的分析、项目经历等等都捋清楚写进去。\n\n有了基础简历，接下来就到了非常重要的一环：针对性修改。\n\n为每一个公司的每一个岗位准备一份简历，这是非常非常重要的。所以，我在这里只谈谈如何根据目标公司的招聘信息来修改自己的简历。\n\nCSDN JOB 上的招聘信息里，职位描述和任职要求很详尽。还有公司信息，我截图时去掉了。当然还有其它的，你看得仔细的话会发现我摘的这则，还有月薪范围、工作地区、要求的工作经验等重要信息。这些信息加上职位描述，结合你之前对自己的分析，基本上就可以确定这个公司的这个职位是否值得进一步了解。\n\n如果你确认了这个公司值得你投递简历，那就需要仔细分析职位描述和任职要求 。职位描述会说明你应聘的这个岗位要做什么，不过很多公司填写的也很空泛，都是行业黑话，有效信息不多。所以我们的重点就是任职要求了。\n\n我在图上标注了几点，可以针对它优化简历：\n\n如果是我的简历，针对“会Qt优先”这一点，我会在简历的技能与评价一栏写上“著有《Qt on Android核心编程》和《Qt Quick核心编程》”这句话，那一定会加分。你可以写别的，匹配度越高越好。\n\n比如“有Android/iOS平台开发经验者优先”这一点，如能在你的简历中列出你已上线的App和你在其中负责的事项就会很好。\n\n有些看起来比较虚的要求，类似“较强的学习能力”这种，可能我们一开始觉得很难针对它来修改简历。其实不然，如果你做的某个产品用到的技术是你第一次接触（一定有这种情况，除非你天生是会各种技术的大神），你就可以把这个经验当做例子，在里面加入你对产品的贡献。比如这样：“在两个星期内完成了Scala+Play的学习并顺利接手10万代码行的项目”。\n\n每一份有针对性的简历都值得反复琢磨，优化得当你就有很大几率通过简历筛选这一关。一旦通过了简历筛选，就有机会进一步了解公司了，比如可以在面试通知电话里询问要做的产品、团队的大小等，为面试做准备。\n\n我还从 CSDN JOB 截取了另外一则招聘信息，你可以对着它来练习一下如何有针对性的优化简历。图在下面：\n\n我在上图中做了一些标注，供参考。\n\n现在来谈谈到哪里找机会的问题吧。\n\n其实现在招聘网站很多，下面几个是我觉得还不错的：\n\n这些网站要么是我在上面投过简历，要么是我在上面发布过招聘信息，简单说一下推荐的理由。\n\nCSDN JOB 依托 CSDN社区 ，在IT方面有深厚积累，对IT从业人员有相当的吸引力，而IT类的、互联网类的公司也认可这一点，会到这里来发布有针对性的职位。我们公司之前在这里发布了一个后端的与 Scala 相关的职位，工作地点是西安，结果很快就有一个懂Scala的朋友找到了我们。\n\n猎聘是相对高端的一个平台，做得相当不错，上面活跃着很多猎头，一旦你在上面发布了简历，看起来很有吸引力的话，就很可能会收到猎头电话。\n\n拉勾专注互联网职业机会，也不错。我们公司在上面发布职位后收到了不少简历。\n\n智联是比较老牌的招聘网站了，早些年我在上面找过工作。\n\n我在“漫谈程序员系列：找工作的辟邪剑谱”一文中提过内部推荐，这也是非常非常值得一试的方式。\n\n很多公司信这个，认为自己的员工不会推荐不靠谱的人。我工作过的公司，如果你推荐的人被录用并且成功通过试用期，你会获得一千大洋的伯乐奖金。我媳妇所在的公司也有类似的机制。所以，如果你能找一个目标公司的员工来推荐你，那你就踏出了成功的一步。\n\n根据六度空间理论，如果你愿意，总是能找到推荐你的人的。\n\n猎头在人力方面还是有很大作为的，他们和企业关系较好，很多企业会委托猎头来招聘高端职位。所以，如果你有机会结识猎头，一定要留下他们的联系方式，保持联系。当你要换工作时就会帮的到你了。猎头拿到职位也是很希望快点找到合适人选的，所以，他们乐意和你保持联系。\n\n我开通了微信订阅号“程序视界”，关注即可第一时间看到我的原创文章以及我推荐的精彩文章：", "link": "http://blog.csdn.net/foruok/article/details/45840147", "publishDate": "2015-05-19 07:05", "title": "\r\n        程序员跳槽神级攻略            \r\n        "}
{"readCount": "20009", "article": "这是系列文章中的一篇，阅读本文前请先阅读《Windows下Qt 5.2 for Android开发入门》，以便确保开发环境和作者一致。\n\n部分文章被转发/转载却没有注明出处，特此声明：版权所有 foruok ，如需转载敬请注明出处(http://blog.csdn.net/foruok)。\n\n我将从实践出发，带领大家一步一步完成在 Android 上的第一个 Qt 应用： Hello Qt on Android 。应用本身非常简单（仅仅是在屏幕上显示一个字符串 \"Hello Qt on Android\" ），这也是每种编程语言的入门教程中 Hello World 程序的共性。\n\n下面我将和大家一起来探索使用 Qt Creator 3.0 创建、管理、编译、部署 Qt on Android 应用的整个过程。每一个步骤都配以我精心挑选并编排整理的截图，力求初学者可以按图索骥、顺畅地走下去，完成自己在 Android 平台上的第一次观光旅行。\n\n\n\n打开 Qt Creator ，点击文 \"件(F)\" 菜单，在弹出的菜单列表中选择 \"新建文件或项目(N)\" 。如下图所示：\n\n\n\n如上操作后， Qt Creator 会弹出新建工程界面，让我们选择工程模板。如下面的所示：\n\n\n\n这里我们选择 \"应用程序\" 项目， \"Qt Widgets Application\" 模板。可以看到最右侧的实时提示，支持的平台中有 Android(蓝线所示)，看到这点，说明前面的开发环境搭建是正确的。\n\n    点击 \"选择(C)...\" 按钮，新建工程向导会指引我们进入下一环节 \"项目介绍和位置\" 。参考下图：\n\n\n\n我已经做了标识，编号为 1 的文本框，你可以填写项目的名字，这里是 \"HelloQtAndroid\" ；编号为 2 的 \"浏览...\" 按钮允许你选择工程的存储路径，我准备把工程放在 \"D:\\projects\\blogs\\qt\" 目录下面。请对照下图检查你的配置：\n\n\n\n点击 \"下一步\" 按钮，跟随向导进入构建套件选择(\"Kit Selection\")环节。\n\n    我选择了两个套件，\"Android for armeabi (GCC 4.7, Qt 5.2.0)\" 和 \"Desktop Qt 5.2.0 MinGW 32bit\"，分别对应下图中的标号为 1 和 2 的区域。请对照下图检查你的配置。\n\n\n\n点击 \"下一步\" 按钮，跟随向导进入 \"类信息\" 配置环节。下图是默认的界面：\n\n\n\n上图中标号为 1 的下拉框，可以选择待创建的 Widget 的基类，默认是 QMainWindow ，我这里选择 QWidget。标号为 2 的复选框，如果选中则会生成一个 .ui 文件，可以通过 Qt SDK 中的界面设计师来编辑界面，为了简单直接，我们去掉了选中，不使用 .ui 文件，全部使用代码完成界面构建。\n\n    请参考下图检查你的配置：\n\n\n\n点击 \"下一步\" 按钮，跟随向导进入 \"项目管理\" 环节。在这里你可以选择是否将工程加入版本控制系统（如 svn 之类），还可以看到即将添加到我们的 \"Hello Qt on Android\" 工程中的文件。如下图所示：\n\n\n\n终于看到 \"完成(F)\" 按钮了，赶紧点击它！看下图，我们将进入日后使用 Qt Creator 这个近乎完美的 IDE 编程时使用频度最高、相依相伴时间最久的界面。\n\n\n\n如上图所示，这就是我们日后天天要面对、不断打交道的界面。我会选择几个最常用的功能简明扼要的介绍它的用法。\n\n    左边栏，标号为 1 的标签，是 \"编辑\" 标签，选中它，会进入编辑模式，就是上面的样子。\n\n    标号为 2 的标签，是 \"项目\" 标签，选中它，会打开项目选项配置界面。该界面功能丰富到有些繁杂，后面我们会多花些时间来一一介绍我们的 \"Hello Qt on Android\" 工程必须要用的选项。\n\n    标号为 3 的是 \"构建版本\" 按钮， 点击它，会弹出一个快捷界面，允许我们快速选择不同构建版本（如 Android 的 Release 构建， Desktop 的 Debug 构建等等）。点击 \"项目\" 标签所进入的配置界面中也可以完成构建版本选择。\n\n    标号为 4 的是 \"运行\" 按钮，点击它， Qt Creator 会执行编译、链接、打包等等工作，直到目标程序运行起来或者出错停止。\n\n    \"运行\" 按钮下面依次是 \"开始调试\" 、 \"构建项目\" 按钮，鼠标悬停在它们上面就可以看到提示，其用途不言自明。\n\n    标号为 5 的那一横排标签，是 Qt Creator 的输出窗口，点击任一标签，都会向上伸展出一个窗口显示与标签名字对应的信息。\n\n    问题标签对应的窗口显示构建问题，找到问题后双击就会跳转到对应的代码行或编译输出窗口（部分链接错误）。\n\n    编译输出标签对应的窗口会把编译、链接、打包、部署过程中的信息都显示出来，这是我们从外面观察 Qt Creator 工作过程的极佳途径，善加使用必将获益良多。\n\n    应用程序输出标签对应的窗口会显示应用程序使用标准输出打印的信息，APK 运行后， logcat 的日志也会显示在这里。\n\n    其它标签不再细说，开发过程中使用几次就熟悉了。\n\n    标号为 6 的区域，就是代码编辑区。\n\n    标号为 7 的区域，是侧边栏、项目管理区域，这里允许开发者以项目、类视图、大纲、文件系统、类型层次、打开文档等等方式来管理项目。\n\n\n\n介绍完了我们的好伙伴——项目管理与代码编辑界面，接下来我们继续完成 \"Hello Qt on Android\" 的项目配置。点击前面介绍的标号为 2 的项目标签，会看到下面的项目选项配置界面：\n\n\n\n我们的新建工程，默认选中了 \"Desktop Qt 5.2.0 MinGW 32bit\" 这个套件。请注意上图左下蓝线标出的按钮，前面提到，它是构建版本选择按钮，现在显示的是电脑图标配Debug字样。\n\n点击标号为 1 的区域中的构建按钮（蓝色圆圈所在），切换到 \"Android for armeabi\" 套件，进行构建相关的配置。如下图：\n\n\n\n构建配置选项繁多，对于我们的第一个应用，只要关注途中标识出的 1 和 2 两个功能怎么使用即可。\n\n    标号为 1 的按钮，点击可以切换到\"运行\"选项配置，马上就能看到。\n\n    标号为 2 的组合框，可以选择构建版本（一般是 Debug / Release 两个）。它完成和左边栏下蓝色圆圈标识的构建版本按钮一样的功能。我们这里选择 \"Release\" 构建。\n\n    注意蓝色圆圈标识区域，随着我们选中 \"Android for armeabi\" 套件和 \"Release\" 构建，它从电脑图标变成了安卓小机器人配 \"Release\" 字样的按钮。\n\n好啦，现在让我们点击标号为 1 的\"运行\"按钮，进行运行选项配置。对目前这个项目来说，运行配置远比构建配置复杂，请擦亮眼睛，用心体会。\n\n\n\n希望你没被吓到，我在上图中作了 9 处标识，比之前的编辑界面（ 7 个标识）还多。让我们化繁为简，一个一个来看。\n\n    标号为 1 的下拉框，可以选择应用针对的目标 SDK 版本，这里默认是 android-17。我得说（ 先请大神 BogDan Vatra 见谅 ） Qt Creator 的这种显示不够完美，如果鼠标悬停在下拉框上时悬浮窗提示一下会更好。\n\n    我这里简要说明一下 Qt Creator 中的这个配置选项。实际上它对应 Android APK 的主配置文件 AndroidManifest.xml 中的  android:targetSdkVersion 配置项。这个配置项允许你指定你的应用针对的Android API Level ，而吊诡的是，它使用 sdkVersion 来作为标签，容易引起混淆。实际上，现在我们可以简单地把 sdkVersion 和 API Level 理解为同一个东西，细微差别以后再说。\n\n    为了让大家对 Android API Level 有个概念，我截取了 Google Android 在线手册（请访问页面\" http://developer.android.com/guide/topics/manifest/uses-sdk-element.html\" ）中的一幅图放在下面：\n\n\n\n标号为 2 的\"对包签名\"复选框，选中时 Qt Creator 会自动对 APK 进行签名。而一旦你选中了它，就需要提供一个密钥文件( keystore )供 Qt Creator 使用。 如果没有，则点击标号为 3 的 \"Create\" 按钮， Qt Creator 会帮你创建一个；如果有，可以点击 \"Browse\" 选择。\n\n    标号为 4 的单选框，是 Qt 库布署策略中的一个，用 Ministro 服务安装 Qt 。我们推荐使用这个，具体原因会在\" Qt 库的部署策略\"一节详细介绍。另外一个可用的策略是把 Qt 库打包到你的 APK 中。\n\n    标号为 5 的复选框，选中时 Qt Creator 会在打包完成后打开包所在的目录，方便开发者访问生成的 APK 。\n\n    标号为 6 的浮现选，对应日志输出选项。\n\n    标号为 7 的按钮， \"Create AndroidManifest.xml\" ，如按钮名所示，帮助你创建并配置 APK 的主配置文件 AndroidManifest.xml 。如果你不点这个按钮呢， Qt Creator 会使用默认的选项帮你创建一个默认的配置文件。建议创建并配置它，否则你的 APK 包名什么的都会让你觉得怪怪的有点不舒服。\n\n    标号为 8 的按钮，\"Install Ministro from APK\"，则是 Qt Creator 提供给我们的一个贴心服务，允许我们把下载到本地的 Ministro APK 安装到 Android 设备上。顺便说下，我在完成 \"Hello Qt on Android\" 项目时就遇到了无法安装 Ministro 服务的问题，我的 XT882 电信定制版手机，根本访问不到 Google Play。 \n\n    标号为 9 的区域有两个按钮，允许我们添加依赖库。现在的工程用不到，以后再说。\n\n    啊，天，终于说完了，你睡着了嘛，醒醒，我们继续往下看。\n\n\n\n让我们回到签名选项（别忘了，标号 2 ），选中它，然后点击标号为 3 的 \"Create\" 按钮，创建密钥文件和证书。你会看到下面的界面（空空如也，没错，是初始界面嘛）：\n\n\n\n如上图所示，有很多选项，照着填写就行，错了会有提示。我配置好后截了图，在下面，请参照着检查你的配置：\n\n\n\n点击\"保存\"按钮，会弹出文件选择对话框，让你选择密钥文件的保存位置，你也可以修改它的名字。下面是我的配置截图，供参考：\n\n\n\n点击——，哦，等下，先记住你刚才起的文件名和保存的位置（在市场中更新 APK 必须要使用和之前发布版本相同的签名），后面还要用到，然后再点击\"保存\"按钮，我们会回到运行配置界面。如下图所示：\n\n\n\n可以对照初始的运行配置截图，我把修改过的选项用蓝色横线标注出来了。\n\n\n\n接下来是我们的另一个重头戏，创建 AndroidManifest.xml 文件。\n\n   好啦，下面是创建向导，允许你选择保存位置，先别动它，使用默认值（工程目录下的 android 子文件夹，回头你可以到这个位置观光一下，AndroidManifest.xml 还有你应用的图标都放在这里）就行。\n\n\n\n直接点击\"完成(F)\"按钮，你会看到 Qt Creator 提供的供你编辑 AndroidManifest.xml 文件的图形化界面（当然你也可以在 Qt Creator 中查看 XML 并手动修改它）。看图：\n\n\n\n这是个中等复杂度的界面，我做了 6 处标识，下面一一说明。\n\n    标号为 1 的编辑框，填写你的包名。如你所见，默认值是 org.qtproject.example ，看起来不那么正式。\n\n    标号为 2 的微调按钮，允许你更改应用的版本号。\n\n    标号为 3 的区域，调整最低 API Level 和 目标 API Level。\n\n    标号为 4 的区域，让你设定你的 APK 图标，有高、中、低三个尺寸（一般对应 72x72 、 48x48 、 32x32）。\n\n    标号为 5 的下拉组合框，列出了所有支持的权限，你可以考虑你的 APK 需要什么权限，选中它，点击标号为 6 的 \"Add\" 按钮就可以在 AndroidManifest.xml 中添加一个权限。当然你也可以点击 \"Remove\" 按钮来取笑一个不必要的权限。\n\n    关于 APK 的权限，这里不细说，会在\"AndroidManifest.xml 介绍\"一节中详细说明。对 HelloQtOnAndroid ，我保持 Qt Creator 设置的默认权限。\n\n    下面是我的配置截图，改动的部分用蓝线标注出来了，请参照检查你的配置：\n\n\n\nQt Creator 提供的图形化 Android Manifest 编辑界面，只支持了主要几个选项，如果你想细细调整体验掌控全局的感觉，请点击上图蓝色方框处的\"XML Source\"按钮，手动编辑 xml 文件。如下图所示：\n\n\n\n和编辑 C++ 代码一样，可以在标号为 1 的编辑区来编辑 XML 文件。\n\n    谢天谢地，一百里路我们走了九十里啦，接下来就会惊吓、惊喜不断。\n\n\n\n虽然你已经准备好迎接惊喜，我们还是得按捺一下心情，把代码稍稍修改几行。回到编辑界面，确保你左侧项目管理窗口选中\"项目\"方式，展开源文件夹，双击其下的 widget.cpp ，在右侧编辑区添加一行代码：\n\n\n\n好啦好啦，九十九里路啦，咫尺之遥，请点击左边栏的\"运行\"按钮（你是否还记得）， Qt Creator 会让你选择目标设备（如果环境配置正确，连接了手机或者创建了AVD），建议直接真机运行（你没有 Android 手机吗？），如下图所示：\n\n\n\n看见了吗？选中我的老古董手机，摩托罗拉 XT882 ，Android 版本是 2.3.6 ，点击\"确定\"按钮，活动一下，静待奇迹出现。\n\n    哦，吓我一跳，我看见了这个界面：\n\n\n\n忘了吗，我们前面在运行配置中勾选了\"Open package location after build\"选项。如果你要在市场中发布你的应用，请注意选择（图中蓝框所示）签过名的版本。\n\n    等一下，现在该看手机了。我看到了这个界面：\n\n\n\n你是否还记得，我们选择的 Qt 库布署策略——\"使用Ministro 服务安装 Qt 库\"？\n\n    现在要操作手机，摸下\"确定\"按钮，会尝试安装 Ministro 服务。惊吓来了，我看到手机屏幕上华丽丽地闪过一个 Toast 提示“安装 Ministro 失败”，然后就是下面的图：\n\n\n\n看样子它是到我手机上默认的安智市场中去找 Ministro 了，没找到。按返回键吧，哦，天，停在了黑屏界面，没有任何反应……好吧，请猛击手机的返回键或者小房子(主页)键。哦，桌面出来了，谢谢。至于为什么 Ministro 安装失败会出现黑屏，请阅读后续章节。\n\n    现在我们需要回头来调整运行配置，换一个 Qt 库布署策略——\"在 APK 中捆绑 Qt 库\"。\n\n    再次运行，再次看到 \"package location\" 文件夹界面……，好吧，看手机，惊喜终于来了：\n\n\n\n现在，终于可以停下来喘口气了，我们的第一个 Qt on Android 的应用 \"HelloQtOnAndroid\"终于在真机上跑起来了。\n\n    如果你是第一次使用 Qt on Android，跟随我的指南走下来，是什么感觉？反正我第一次把 \"Hello Qt On Android \" 跑通时，还是非常振奋的，激动了大半天。毕竟， Qt 作为在移动互联网时代，是唯一可以与 Android 、 iOS 并提的跨平台应用开发框架……；毕竟，作为 C/C++ 程序猿，我们可以为 Windows 桌面、 Linux 桌面 、 Android 手机/平板、iOS、MAC OS X 、 Tizen 、 Meego 、 Windows Mobile 、 Embedded Linux 、 Symbian等等平台开发软件而不需要切换开发框架和工具，是多么令人舒心、自豪