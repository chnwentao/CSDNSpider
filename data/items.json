{"readCount": "44", "article": "STK 或者 UTK 就是 Sim Tool Kit （sim卡工具包）,定制了一系列与运营商相关的应用（查询天气，话费，彩铃等），可以理解为安装在SIM卡上的应用。运营商将相关应用信息保存在SIM卡中，STK应用需要从SIM卡中读取相关应用信息，SIM卡也会向STK应用主动上报应用信息。\n\n我们知道SIM卡是插在Modem中的，要读取SIM卡的内容，就必须要经过Modem层，而与Modem层进行交互离不开AT指令。在framework中，发送AT指令主要是在RIL中完成的。所以读取SIM卡的内容的流程可以归结为：STK应用---->RILJ---->RILC---->Modem---->运营商的基站。而这里只需要跟踪一下STK应用到RIL的RILJ层就可以了，以后有空可以研究一下RILC层的代码。\n\n\n\n既然最后到达的是RIL层，那么我们从RIL层往STK应用层反推它的流程。看看从SIM卡中读取的信息是怎样到达STK应用的。在我们插卡开机的时候，Modem检测到有卡插入，这时候它会读取SIM中的相关信息，并把消息上报给RIL层。Modem上报消息的过程这里先不管。我们只研究RIL，要研究RIL层，我们需要先了解一下RIL层的消息分类。\n\nRIL中的消息类型主要分为两种：\n\n solicited response message: 比如拨号，接听，挂断等这些做主动请求的操作的消息\n\n unsolicited response message：GSM/GPRS Modem硬件模块主动上报的，例如来电，接收短信，基站信息等消息。是从硬件来的消息，RIL层被动接收。\n\n \n\n STK应用在RIL中的消息有：\n\n solicited：\n\n RIL_REQUEST_STK_GET_PROFILE\n\n RIL_REQUEST_STK_SET_PROFILE\n\n RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND // 打开子菜单\n\n RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE //获取子菜单信息\n\n RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM\n\n RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING\n\n RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS\n\n UnSolicited：\n\n RIL_UNSOL_STK_SESSION_END\n\n RIL_UNSOL_STK_PROACTIVE_COMMAND  // 显示菜单\n\n RIL_UNSOL_STK_EVENT_NOTIFY\n\n RIL_UNSOL_STK_CALL_SETUP\n\n\n\n无论是哪一种消息，从Modem处上传上来的信息，它的处理过程大体一致。我们只需要沿着具体一个消息的进行追踪，就可以弄清楚它的流程走向。这里我们研究一下UnSolicited的这个消息RIL_UNSOL_STK_PROACTIVE_COMMAND。\n\n在插卡开机的时候，Modem读取此SIM卡中STK显示的菜单，并向RIL层发送RIL_UNSOL_STK_PROACTIVE_COMMAND消息。这个消息被RILReceiver捕获并处理，从这里开始。流程分三个部分，分别是：1.RILJ部分。2.Framework部分。3.STK部分（应用层）\n\nRILReceiver是RIL的内部类，负责监听Socket消息，从Socket中接收并处理RILC上报的消息。（RILJ与RILC的通信主要通过Socket）其逻辑是：\n\n 一．    维护Socket的连接。\n\n 二．    把从Socket中读取到的消息交给RIL中processResponse()方法处理。\n\n \n\n 这个方法主要是根据消息的两种类型，做分别的处理。Parcel存储着从Socket中读取的信息。\n\n Parcel：Parcel就是一个存放读取数据的容器， Android系统中的binder进程间通信(IPC)就使用了Parcel类来进行客户端与服务端数据的交互，而且AIDL的数据也是通过Parcel来交互的。在Java空间和C++都实现了Parcel，由于它在C/C++中，直接使用了内存来读取数据，因此，它更有效率。\n\n \n\n\n\n这个notifyRegistrant()方法是调用的哪个类里边的呢。我们来看看mCatProCmdRegistrant这个变量：protected Registrant mCatProCmdRegistrant;\n\n\n\n 很明显，这个Registrant.java是Android里的消息处理机制，用一个类把Handler发送消息的操作封装起来，并做了异步的处理。当需要此Handler发送消息时，只需要调用这个消息通知的方法notifyRegistrant()即可。\n\n 那么，mCatProCmdRegistrant这个变量是怎么初始化的呢？由于RIL.java继承了BaseCommands.java，在这个方法中，定义了mCatProCmdRegistrant变量并提供了set方法。\n\n \n\n\n\n\n\n 而调用这个setOnCatProactiveCmd()方法的，在CatService.java中，如下：CatService.java的构造方法不仅仅设置了MSG_ID_PROACTIVE_COMMAND这个消息的Handler，还设置了其他消息的Handler。\n\nCatService.java\n\n 构造方法：\n\n  mCmdIf.setOnCatSessionEnd(this, MSG_ID_SESSION_END, null);\n\n  mCmdIf.setOnCatProactiveCmd(this, MSG_ID_PROACTIVE_COMMAND, null);//Handler的what标示是MSG_ID_PROACTIVE_COMMAND\n\n   mCmdIf.setOnCatEvent(this, MSG_ID_EVENT_NOTIFY, null);\n\n   mCmdIf.setOnCatCallSetUp(this, MSG_ID_CALL_SETUP, null);\n\n 好了，到这里我们先整理一下：\n\n 插卡开机，Medem读取SIM卡信息，上报RIL_UNSOL_STK_PROACTIVE_COMMAND消息。RIlJ中的RILReceiver类进行接收并交给processUnsolicited()方法处理。processUnsolicited()方法根据消息类型通知对应的Handler处理（）。而这些Handler的处理在CatService.java的handleMessage()方法中，如下：\n\n \n\n\n\n\n\n 这个方法最后也是通过发送CMD_START消息，交给StateStart.java处理，decodeMessageParams()这个方法主要是解码，具体的解码过程需要查看Bertlv.java里的代码。从CMD_START消息的发送到解码结束这个过程，流程有点复杂，这里就不做具体的分析了，解码结束后，会发送MSG_ID_RIL_MSG_DECODED消息，查看CatService.java的handleMessage()方法，是的，它又回到了CatService.java中。在这个类中，频繁的使用了Handler的消息机制，我们只要关注好Handler的what标识就可以了。接下来会执行handleRilMsg()方法：\n\n\n\n 查看handleProactiveCommand()最后的一段代码，发现它发送一个广播，那这个广播是谁接收的呢？查看AppInterface.CAT_CMD_ACTION这个变量存储的包名是：android.intent.action.stk.command。\n\n\n\n 通过搜索这个包名，我们可以追溯到了STK应用中的AndroidManifest.xml中，看看这里，定义了一个receiver来接收来自framework中的广播。至此，流程跟踪到了STk应用层。\n\n\n\n StkCmdReceiver主要负责从接收来自framework中的广播，并启动StkAppService服务。\n\n\n\n 这个StkAppService是STK中的核心服务，它主要负责调度各个显示层显示相应的数据。\n\n\n\n onStart()方法经过简单的处理，然后交给内部类ServiceHandler进行处理，根据类型的不同，交由不同的Activity显示。比如，这里交由handleCmd()方法：\n\n\n\n 至此，开机显示STK信息的流程就追踪结束了。当然STK应用层面的东西还是很多的，在这一章就不打算再分析了，如果后面有时间，再继续看看。\n\n StkLauncherActivity.java：入口类\n\n StkMenuActivity.java  主页面（信息列表）\n\n StkInputActivity.java   输入页面\n\n StkDialogActivity.java  对话框页面\n\n StkAppInstaller.java    这个类主要用来设置是否在桌面上显示这个STK图标\n\n StkCmdReceiver.java   接收广播\n\n \n\n \n\n", "link": "http://blog.csdn.net/sjz4860402/article/details/51182078", "publishDate": "2016-04-18 19:41", "title": "\r\n        android之Sim Tool Kit流程分析            \r\n        "}
