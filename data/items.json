{"readCount": "427", "article": "感谢所有人对“漫谈程序员”专栏的关注，是你们的支持让我有动力和热情持续叨叨下去，没成想这个专栏已经走过了将近两年的漫长旅程，感谢ing。\n\n去年的时候，应出版社邀请，将专栏内的部分文章结集出版，书名是《你好哇，程序员》。我还邀请了一位萌妹子为配了插画，她的微博是http://www.weibo.com/udspj，可以到那里一探会画漫画的二次元女程序员。\n\n《你好哇，程序员》，最了解程序猿的程序猿写的关于程序猿的书。我翻看了一下，看时有点儿恍惚，甚至怀疑这是我写的文章吗——风格和我现在的文章有明显差异，以前的文章，满满的开发生活味道，一本正经的不正经，现在的有点太正经了。\n\n需要说明的是，《你好哇，程序员》里的大部分文章都在我的博客及订阅号“程序视界”(programmer_sight)发布过，想看电子版的无须购买，部分未在博客和订阅号“程序视界”发布的文章，稍后也都会发布出来。\n\n另外4月9号，我在我的订阅号搞了一个活动，从出版社买了一些书，做了签名版，现在还有6本，感兴趣的可以加我微信（关注订阅号“程序视界”，回复foruok可获知联系方式）获取，或者看这里http://mp.weixin.qq.com/s?__biz=MzAxMzUzNzYyNA==&mid=403091500&idx=1&sn=48171b9eddcbabf020ded57252c621aa#rd，有说明。原价49，包邮带签名。\n\n书中文章，关注订阅号“程序视界”(programmer_sight)或专栏“漫谈程序员”可以查看，回头我会在订阅号里建一个“你好哇，程序员”专题，把所有书中出现的文章都放进去，敬请关注。", "link": "http://blog.csdn.net/foruok/article/details/51189466", "publishDate": "2016-04-19 13:07", "title": "\r\n        《你好哇，程序员》新鲜出炉            \r\n        "}
{"readCount": "6332", "article": "在之前的几篇博客中，我编写了一篇有关Rxjava学习笔记的，还有一个是RxJava使用示例（一）： 实现Rxbus代替eventbus（这篇博文其实还不算完善，因为没有对被观察者发出的时间进行一个筛选，一次发送所有订阅者都会收到，这样不太好，可以再新加一个筛选器，等以后有空或者是遇到的时候再来改一改，现在不急）。\n\n之前在写那边Rxjava学习笔记的时候，就突出了一点是只涉及使用，不涉及原理，现在就对Rxjava的原理进行一个简单的探索。\n\nRxjava属于一种扩展性的观察者模式，里面的四个基本概念是：Observable (可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable 和 Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。 \n\n \n\n 另外有一点是需要注意的，也是Rxjava很重要的一个特性，里面的onError方法，只要是发生错误的话就一定会被处理，所以可以将一些错误处理的代码直接写在onError中。\n\n还有一点就是，Rxjava跟普通的观察者模式的区别在于如果observable没有任何Observer的话是不会发出任何事件的。\n\nObservable负责在发生什么事件或者是订阅的对应条件产生时，就会发送事件去通知Observer，而具体的如何操作是有Observer接收到之后自己处理的，也就是说Observable只负责发，其余的处理由Observer自己来处理。\n\n在Rxjava中存在flatMap以及Map，他们可以将一些指定的要发送的对象类型转换为另一个需要的对象类型，而这一个在Rxjava中是如何实现的呢？下面是我自己的一些理解，可能会有错误或偏差，欢迎指点。\n\n代码中存在一个lift()方法，这个方法就是flatMap以及Map能够转换对象类型的关键。这里就只总结一下思路： \n\n 通过这个lift方法会创建一个新的observable，这个observable里面包含一个新的OnSubscribe，一个新的subscriber。\n\n当用户调用经过 lift() 后的 Observable 的 subscribe() 的时候，使用的是新的 Observable \n\n 于是它所触发的 onSubscribe.call(subscriber)，也是用的新 Observable 中的新 \n\n OnSubscribe。 而这个新 OnSubscribe 的 call() 方法中的 onSubscribe ，就是指的原始 \n\n Observable 中的原始 OnSubscribe ，在这个 call() 方法里，新 OnSubscribe 利用 \n\n operator.call(subscriber) 生成了一个新的 Subscriber（Operator 就是在这里，通过自己的 \n\n call() 方法将新 Subscriber 和原始 Subscriber 进行关联，并插入自己的『变换』代码以实现变换），然后利用这个新 \n\n Subscriber 向原始 Observable 进行订阅。\n\n也就是说，原始的onSubscribe方法会发送数据发送到这个新的Subscriber中，而在这个新的Subscriber中会对数据进行一个处理，处理完成之后再发送给目标订阅者，也就是最原始的observer。而至于为什么要先发送数据到一个新的subscriber中，上面也提到过了，observable只管发，数据的处理是在subscriber中处理，这样分工明确。而当新的这个观察者处理完数据之后，再转发给原始的观察者。\n\n最开始我接触到Rxjava有三个原因： \n\n 第一个是代码的简洁度，链式。 \n\n 第二个是响应式框架，观察者模式。 \n\n 第三个就是它是一个异步的框架，线程切换功能极其强大，可任意指定观察者发生的线程以及被观察者的线程，随意调整极其强大（观察者发生的线程只能更改一次，被观察的可以随意切换）。\n\n而之前也是一直都很好奇它的这个切换的流程是怎么样的，为什么只能观察者发生的线程只能更改一次而被观察的可以随意切换多次？\n\n线程的切换其实也是使用了上面介绍到的lift方法，被观察者切换线程使用observeOn()，观察者切换线程使用subscriberOn(),可切换为多种线程，例如主线程，IO线程，新线程等等，具体的可以查看我的第一篇Rxjava博文，Rxjava学习笔记。\n\nobserveOn() \n\n \n\n 在lift方法后，会创建一个新onSubscribe和一个新的subscriber。新的onSubscribe会通知原始的onSubscribe，原始的在收到通知后就会把信息发送到新的subscriber中，而这个时候如果设置了切换线程的话就会发生切换线程的操作\n\n而subscribeOn()方法就不同了，它切换线程的位置是在新onSubscribe通知原始onSubscribe之前，这也就导致了如果设置了多个切换线程操作始终只有有第一个subscribeOn()方法切换成功，因为它切换线程是在整个的流程发生之前，而当第二个subscribeOn()方法调用时它已经是处于整个流程之中了，因此就无法设置多个。而observeOn()则不同，它的线程切换是发生在流程之中的，所以多个切换是被允许的。\n\n总结到了这里，我产生了一个疑问，subscribeOn切换观察者的线程为什么要设置在整个流程之前而为什么observeOn方法会设置到整个流程之间？这个应该是创造者指定的一个规则吧，但是我很好奇为什么要这样设置。\n\n————————————————— 更新 \n\n 通过在stackOverFlow以及知乎上提问获得了想要的答案：", "link": "http://blog.csdn.net/jonstank2013/article/details/50981404", "publishDate": "2016-03-25 16:11", "title": "\r\n        Rxjava原理探索：切换线程，变换            \r\n        "}
{"readCount": "5092", "article": "Fragment 俗称 碎片，那么为什么会出现Fragment这个东西呢？鸿洋是这样介绍的：Android运行在各种各样的设备中，有小屏幕的手机，超大屏的平板甚至电视。针对屏幕尺寸的差距，很多情况下，都是先针对手机开发一套App，然后拷贝一份，修改布局以适应平板神马超级大屏的。 \n\n 我们可以唉Activity中随意的使用Fragment，当你的一个界面业务逻辑很复杂的时候，我们可以将逻辑写到Fragment中，这样就不必在Activity写一堆控件的事件处理的代码了，Fragment当然也有自己的生命周期，接受处理事件的回调。\n\nFragment生命周期和Activity生命周期类似，只是比Activity多了几个回调方法而已。 \n\n\n\n其他的都不介绍了，跟activity一样，看一下不一样的那几个吧： \n\n onAttach（）：当Activity和Fragment交互的时候，我们可以在Activity中通过Fragment.setArguments()的方法为Fragment提供数据，然后再Fragment的onAttach（）方法中getArguments()获得一个Bundle对象。 \n\n onCreateView():创建该Fragment对应的视图，在这里你必须将创建的视图返回诶调用者。它跟onCreate（）的区别：onCreate()是指创建该Fragment，你可以在其中初始化除了View之外的东西。 \n\n onActivityCreated() \n\n 当Activity的onCreate()方法调用时，该方法被调用 \n\n onDetach() \n\n 当Fragment和Activity解除关联时调用该方法。\n\n下面我们来看一下在使用Fragment时遇到的那些坑吧： \n\n 对于FragmentManager我们应该知道它的作用，它用来维护Fragment队列，以及Fragment事务的回退栈。\n\n首先我们来看看transaction的几个方法： \n\n add():将一个Fragment添加到Activity中 \n\n remove():移除Fragment \n\n replace()、hide()、show() \n\n 需要我们注意的是：Fragment展示也有两种方式： \n\n 一种是replace，另一种就是hide、show，那么这两种方式有什么区别呢？ \n\n replace显示的话会调用Fragment的生命周期，也就是说它会销毁视图，重新加载，这种方式的话如果你的Fragment里面有大量的数据或者说很多视图结构的话不推荐使用这种，会增大你的内存消耗。 \n\n hide和show就是显示隐藏fragment了，最终结果也就是V’isibliity设置VISIBLE和GONE了。 onHiddenChanged的回调时机，Fragment切换时候有可能会刷新数据，如果你的展示方式为hide、show的方式那么你就需要用到onHiddenChanged（）方法了，但是不推荐在其中做繁重的业务逻辑。 fragment界面重叠问题的终极解决方法 \n\n 原因：为什么会出现界面重叠呢？因为每当我们离开Activity的时候，切换到别的APP的时候，当内存不够用，Fragment所在Activity被销毁，会调用onSaveInstanceState()方法，Fragment都会被保存起来，当我再次回到这个app的时候，通过onCreate中的参数savedInstanceState恢复了之前的fragment，就导致了界面重叠。 \n\n 解决方法： \n\n 1.在进入onCreate函数时，先去判断savedInstanceState是否为null，如果不为null,则表示里面有保存这个fragment。则不再重新去add这个fragment，而是通过Tag从前保存的数据中直接去读取，看一下代码：\n\n到这里，小编所遇到的坑差不多都介绍完了，其实还有很多，比如Fragment嵌套问题，转场动画问题，这个目前还没有去研究，以后会慢慢积累下来。推荐两篇文章关于Fragment的，应该是我目前看到的最全的： \n\n http://www.jianshu.com/p/d9143a92ad94 \n\n 文章中如果有不对的地方希望大家多多指正，谢谢…", "link": "http://blog.csdn.net/lyhhj/article/details/51174973", "publishDate": "2016-04-17 20:01", "title": "\r\n        你真的会用Fragment了么？-Fragment解析            \r\n        "}
{"readCount": "7838", "article": "这次有幸参加了GDC 2016, 终于把三大设备体验了个遍, 也试玩了很多不错的VR游戏. 之前看到很多人总是靠猜测和推测来评价这个三个VR设备, 误导了很多人, 所以在这里我就详细对比一下, 希望能让更多的人清楚的认识每个设备的优缺点, 客观地去评价它们.\n\n从参数上来看, Rift和Vive分辨率是一样的, PSVR略低. 但是有一个大家都忽略的因素, 那就是像素的排列方式. PSVR是RGB排列, Rift和Vive是Pentile排列的. 虽然与Oculus DK2同样的分辨率, PSVR的清晰度改善却非常明显. 另外, Rift对纱门效应多做了一些优化, 所以在像素间空隙上占据十分微小的优势. 个人的总体感觉, 清晰度上Rift > Vive > PSVR > DK2. 不管哪个设备, 像素仍然是肉眼可见的, 只不过这三个设备已经不会像DK2那样第一眼就因为分辨率问题让人出戏了. \n\n PS: Rift需要手动调节瞳距, 我个人需要调节到最大才比较清晰, 有人也反应怎么调都看不清, 可能并不适合瞳距比较大的人.\n\n参数上来看都是100~110左右, 比GearVR的体验要好得多. 另外, GearVR和DK2仍然存在边缘色散的现象, Rift/Vive/PSVR已经察觉不到这个问题了, 所以这个角度算是平手.\n\nRift和Vive都是90Hz, PSVR可以是60/90/120Hz. PSVR的120Hz看起来很美, 但是机能限制一般是渲染60FPS, reproject成120. 从用户体验上来说, 差别不是很大, 可以当作是平手, 延迟上比各种手机VR盒子好太多了.\n\n重量上来看, Rift < Vive < PSVR. 但是, 实际的体验好坏并不是这个顺序. 不得不说这次SONY的工业设计保持了一贯的高水准, 通过前后的重量均匀分布消除了前脸的负重感和压迫感. \n\n 如果不戴眼镜, 那配戴舒适度PSVR > Rift > Vive. \n\n 如果戴眼镜, 那PSVR > Vive > Rift. 我个人也是近视, 所以在这一点上感受非常深, 下面是三个设备在戴眼镜的基础上的穿戴过程:\n\nRift直接集成了耳机, 穿戴过程少了一个设备, 音效也不错, 可以拆掉. 但耳机不是全包式的, 而且那个机械结构给人的感觉很脆弱, 一不小心就会掰断的样子. Vive上预留了耳机孔, PSVR则是在连接线有个耳机孔. 这方面不好说谁好谁坏, 每个人的需求不一样. 对于想自己配发烧耳机的, Vive和PSVR更合适.\n\nHTC这次不光”后头丑”, 前面也丑了, 囧. 但是配戴过程中, 自己是看不到设备的外观的, 所以好不好看无所谓了, 自己觉不出丑, 最多是别人看你丑, 哈哈. 有些人也不喜欢PSVR上那些灯, 所以这是一个主观问题, 不好评价.\n\nVR头戴设备更多的是输出方式的改善, 真正能够改变游戏体验的是输入设备, 这就需要我们好好关注一下能够在VR中模拟双手的控制器了, 未来会基于双手控制器产生各种新的游戏体验(甚至游戏类型). \n\n Rift, Vive, PSVR的专属控制器分别是Oculus Touch, SteamVR Controller, PS Move. 大家的功能差不多, 都有空间定位能力, 能够在VR中模拟双手的位置和旋转. 通过按键模拟手部的动作, 通过摇杆/触摸板控制一些方向操作等. \n\n 从手感上来说, Touch > SteamVR Controller > PS Move. \n\n 从空间定位的稳定性上来说, SteamVR Controller > Touch > PS Move. \n\n 由于PS Move的定位是依赖PS4的Camera的, 所以转身被挡住就会出问题, 而且Camera的精度也最差. 如果是基于体感的操作, PSVR的体验非常不好, 可能SONY会出新版的体感控制器来改善这个问题. \n\n Rift配Touch的话可以增加一个Camera用于增强定位能力, 所以实际的空间稳定性还是不错的, 能够在两三米左右的范围内移动. \n\n Vive的Lighthouse技术定位能力最强, 可以直接在虚拟世界中把手柄抛起来再接住.\n\nVive最大的优势就是它的Lighthouse技术, 可以提供5x5米的空间范围追踪能力. 这就意味着, 游戏中的移动可以通过实际走动来进行, 避免了”被动式”移动产生的眩晕问题. 另外, Vive带了个摄像头, 可以在不摘下的情况下去喝杯水, 拿个东西之类的. 最后就是HTC的特色, 支持手机的蓝牙连接, 可以在穿戴情况下接打电话.\n\nPSVR的特色是分屏游戏, 即一个人戴PSVR玩, 另外4个人看电视机玩, 合家欢的PartyGame. 这非常符合主机的定位, 毕竟一个人玩VR的话, 家人肯定会有意见…一般一家人也不会买多个VR设备, 如何一起玩耍? PSVR给了一个很不错的思路. 不过, 这个特色在PC上也可以实现, 最后还是看游戏支不支持了.\n\n至于Oculus的特色功能, 估计是Facebook? 很可能就因为这个行货会难产, 现在装个驱动都要翻墙……\n\nPSVR的要求最低, PS4 + Camera即可. Rift和Vive的推荐配置几乎一样, 实际上来看的话, Vive对CPU的要求要比Rift更宽一些, 而且Rift还需要占用3个USB3.0接口. 原因是Vive的一些数据处理在硬件层就完成了, Rift需要在驱动层面去处理, 所以对CPU指令集和传输带宽要求更高一些.\n\nPS: 吐槽一下, 装了台E3 1230v3的机子, Rift竟然说达不到要求, 明明比i5强好么…虽然不影响体验, 但也不用一直在Home界面提醒我啊-_-\n\n从连线的便利程度来看Rift > PSVR > Vive. Rift加上两个Camera就三根线, PSVR还要拖个分线盒再接电视机. Vive比较特殊, Lighthouse带来大范围定位能力的同时, 对安装的空间提出了很高的要求. 如果无法在天花板上安装, 就需要弄两个三角架来固定那两个传感器. 再说了, 谁家有那么大面积的空间啊, 为了买Vive, 换套房? 虽然HTC表示也会有一些不需要那么大空间的游戏, 但是买来用不了的功能总觉得亏了.\n\nPSVR最便宜, $399, 另外还需要PS4+Camera+PS Move, 整套下来只是相当于Rift和Vive的PC主机的价格 \n\n Vive跟Rift比的话, 看起来Vive更贵, 但是Rift还没有包含Touch控制器, 所以现在也不好说谁更贵, 何况Rift还送了三个游戏. 不管怎么说, 买这俩都要另配一台6000块以上的电脑主机, Vive还要再配个耳机, 甚至是房子.\n\nOculus打造了自己的一个新平台, Vive一边跟Steam合作, 一边却又自己搞了个市场, 不知道怎么想的. 这两个都是在PC平台上使用的, 不知道未来会不会对非平台商店下载的内容做出限制, 这也是很多宅男比较关注的. \n\n PSVR这边就比较矛盾了, 一方面受限于PS4的机能, 画面做不了非常精美(何况又加了个分屏功能, 就这点GPU能力还要渲染两个不同的画面). 另一方面, PS强大的开发者关系能够吸引更多有实力的工作室对其进行内容制作, 加上硬件体验的一致性, 很可能在游戏体验上会更好. 这其实就有点像主机党和Steam党之争, 没法说谁好谁坏.\n\n总的来说, Rift/Vive/PSVR算是第一批”合格的”面向消费者的硬件, 虽然不是完美形态, 但这代表了一个开始. 从整个GDC的展位和讲座占比来看, VR已经是一股不可阻挡的潮流, 也许普通人并没有意识到, 但是科幻片中的未来已经离我们不远了.", "link": "http://blog.csdn.net/xoyojank/article/details/50927572", "publishDate": "2016-03-18 23:46", "title": "\r\n        Oculus Rift, HTC Vive, SONY PSVR的全面对比            \r\n        "}
{"readCount": "20102", "article": "Hadoop的高吞吐，海量数据处理的能力使得人们可以方便地处理海量数据。但是，Hadoop的缺点也和它的优点同样鲜明——延迟大，响应缓慢，运维复杂。\n\n有需求也就有创造，在Hadoop基本奠定了大数据霸主地位的时候，很多的开源项目都是以弥补Hadoop的实时性为目标而被创造出来。而在这个节骨眼上Storm横空出世了。\n\nStorm带着流式计算的标签华丽丽滴出场了，看看它的一些卖点：\n\nStorm是一个免费开源、分布式、高容错的实时计算系统。Storm令持续不断的流计算变得容易，弥补了Hadoop批处理所不能满足的实时要求。Storm经常用于在实时分析、在线机器学习、持续计算、分布式远程调用和ETL等领域。Storm的部署管理非常简单，而且，在同类的流式计算工具，Storm的性能也是非常出众的。\n\nStorm主要分为两种组件Nimbus和Supervisor。这两种组件都是快速失败的，没有状态。任务状态和心跳信息等都保存在Zookeeper上的，提交的代码资源都在本地机器的硬盘上。\n\n下图是一个Topology设计的逻辑图的例子。\n\n下图是Storm的数据交互图。可以看出两个模块Nimbus和Supervisor之间没有直接交互。状态都是保存在Zookeeper上。Worker之间通过ZeroMQ传送数据。\n\n虽然，有些地方做得还是不太好，例如，底层使用的ZeroMQ不能控制内存使用(下个release版本，引入了新的消息机制使用netty代替ZeroMQ），多语言支持更多是噱头，Nimbus还不支持HA。但是，就像当年的Hadoop那样，很多公司选择它是因为它是唯一的选择。而这些先期使用者，反过来促进了Storm的发展。\n\n我们只需要实现每个分析的过程，而Storm帮我们把消息的传送和接受都完成了。更加激动人心的是，你只需要增加某个Bolt的并行度就能够解决掉某个结点上的性能瓶颈。       在流式处理领域里，Storm的直接对手是S4。不过，S4冷淡的社区、半成品的代码，在实际商用方面输给Storm不止一条街。 如果把范围扩大到实时处理，Storm就一点都不寂寞了。 ：Facebook使用puma和Hbase相结合来处理实时数据,使批处理 计算平台具备一定实时能力。 不过这不算是一个开源的产品。只是内部使用。 ：尝试为Hadoop环境添加一个实时的组件HStreaming能让一个Hadoop平台在几天内转为一个实时系统。分商业版和免费版。也许HStreaming可以借Hadoop的东风，撼动Storm。 ：作为UC Berkeley云计算software stack的一部分，Spark Streaming是建立在Spark上的应用框架，利用Spark的底层框架作为其执行基础，并在其上构建了DStream的行为抽象。利用DStream所提供的api，用户可以在数据流上实时进行count，join，aggregate等操作。       当然，Storm也有Yarn-Storm项目，能让Storm运行在Hadoop2.0的Yarn框架上，可以让Hadoop的MapReduce和Storm共享资源。\n\n知乎上有一个挺好的问答： 问：实时处理系统（类似s4, storm）对比直接用MQ来做好处在哪里？  答：好处是它帮你做了： 1) 集群控制。2) 任务分配。3) 任务分发 4) 监控 等等。\n\n需要知道Storm不是一个完整的解决方案。使用Storm你需要加入消息队列做数据入口，考虑如何在流中保存状态，考虑怎样将大问题用分布式去解决。解决这些问题的成本可能比增加一个服务器的成本还高。但是，一旦下定决定使用了Storm并解决了那些恼人的细节，你就能享受到Storm给你带来的简单，可拓展等优势了。", "link": "http://blog.csdn.net/fanyun_01/article/details/50921678", "publishDate": "2016-03-18 11:14", "title": "\r\n        浅谈Storm流式处理框架            \r\n        "}
{"readCount": "7324", "article": "在日常开发中我们常常会用到类似微信或者QQ的底部导航。实现这样的效果有多种，今天就为大家介绍一种实现简单，可控性好的底部导航的实现方法。\n\n从上面的代码中可以看出，这种实现方式非常的简洁，可控性也非常好。之前看过的别人的实现方式都比较繁琐。所以推荐大家使用这种方式。当然，每个人都有不同看法，不同的实现方式，适合自己的才是最好的。", "link": "http://blog.csdn.net/loveyaozu/article/details/51149467", "publishDate": "2016-04-14 10:54", "title": "\r\n        Android之RadioGroup+ViewPager制作的底部导航栏            \r\n        "}
{"readCount": "16565", "article": "好久没有写博客了，瞬间感觉好多学了的东西不进行一个自我的总结与消化总归变不成自己的。通过博客可能还可以找到一些当初在学习的时候没有想到的问题。想了半天，从大二上学期自学Android以来还没有对Android从启动到程序运行期间进行一个完整的归纳，刚好最近又学到了一些新东西，那就以这篇博客为媒介，总结一下从Android启动到程序运行期间发生的所有事吧。包括什么ClassLoader, JVM,IPC, 消息处理机制要是总结到了就顺带BB一下。但是这里就不包含很多细节了，比如为什么PMS内部为什么要这么构造，好处是什么，如果我来设计的话我会怎么设计啊这种暂时就不总结了，因为我觉得以我现在的水平还有学习精力来说把这些细节都一个个的弄清楚有点没抓住重点。现阶段还是先能够了解整个流程，有个大局观才是最重要的。至于以后如果有需要或者是有精力的时候再一个个的突破。\n\n在正式开始之前还是忍不住想要BB一下最近参加的京东笔试，被坑得有点憋屈。憋屈啥勒，被编译器坑了。这次京东的笔试说实话感觉真的好简单，真的没有什么技术上的难点，但是尼玛编程题把我坑了。提前一个小时把代码在本地编译器上编译完成并通过，当时心里还有些小激动，一提交，在线编译器说得不到指定结果，尼玛，顿时整个人都斯巴达了。最开始的时候还以为是自己本身代码的Bug，后来顺着思路又理了几遍，完全没问题啊，又自己创了几个新的输入也都能够运行，返回正常结果。整个人都是崩溃的，在这上面花了20多分钟时候不经意间瞥了一下左边的样例输入和输出，哦豁，这下全懂了。 \n\n 因为我没有很多这种参加在线笔试的经验，也没在网上怎么刷题，所以在样例输入和输出那里掺杂了一些自己想当然的想法。 \n\n 题目要求的样例输入是一直输入，有两种情况，一种情况返回No,一种情况返回Yes并返回对应的结果。是要求连续输入的，也就是你在输入的时候我至少要用一个数组或者是List、Map来保存你的输入。当检测到输入为空也就是直接按了回车的同时就开始运行，然后再一次性的打印出结果。我不知道啊，第一次看这种样例输入输出，一看以为只要能返回就好了，然后就是分开做的，输入错的就返回No，输入对的就返回Yes和结果，并不能够一起输入及返回。而这个时候时间又过了好多了，改代码的话整个代码的架构都要变，时间上完全来不及。这笔试要是编程题错了那估计是没戏了。 \n\n 这其实也怪自己吧，怨不得别的，只好等下次了，只是这次的题真的简单，错过了好可惜，毕竟还是非常想进京东锻炼锻炼的，就算进不了去体验京东的面试，知道哪里有不足也是好的。\n\n上面BB了这么多，也是超过了我的预料，这里就正式开始这篇博客了。\n\n首先，我们知道，Android是基于Linux的一个操作系统，它可以分为五层，下面是它的层次架构图，可以记一下，因为后面应该会总结到SystemServer这些Application Framework层的东西 \n\n \n\n Android的五层架构从上到下依次是应用层，应用框架层，库层，运行时层以及Linux内核层。\n\n而在Linux中，它的启动可以归为一下几个流程： \n\n Boot Loader-》初始化内核-》。。。。。。 \n\n 当初始化内核之后，就会启动一个相当重要的祖先进程，也就是init进程，在Linux中所有的进程都是由init进程直接或间接fork出来的。\n\n而对于Android来说，前面的流程都是一样的，而当init进程创建之后，会fork出一个Zygote进程，这个进程是所有Java进程的父进程。我们知道，Linux是基于C的，而Android是基于Java的（当然底层也是C）。所以这里就会fork出一个Zygote Java进程用来fork出其他的进程。【断点1】\n\n总结到了这里就提一下之后会谈到的几个非常重要的对象以及一个很重要的概念。\n\nAndroid系统中的客户端和服务器的概念 \n\n 在Android系统中其实也存在着服务器和客户端的概念，服务器端指的就是所有App共用的系统服务，比如上面的AMS，PackageManagerService等等，这些系统服务是被所有的App共用的，当某个App想要实现某个操作的时候，就会通知这些系统服务。\n\n当Zygote被初始化的时候，会fork出System Server进程，这个进程在整个的Android进程中是非常重要的一个，地位和Zygote等同，它是属于Application Framework层的，Android中的所有服务，例如AMS, WindowsManager, PackageManagerService等等都是由这个SystemServer fork出来的。所以它的地位可见一斑。\n\n而当System Server进程开启的时候，就会初始化AMS，同时，会加载本地系统的服务库，创建系统上下文，创建ActivityThread及开启各种服务等等。而在这之后，就会开启系统的Launcher程序，完成系统界面的加载与显示。【断点2】\n\nContext是一个抽象类，下面是它的注释信息，摘自源码。\n\n从上面的这段话可以简单理解一下，Context是一个关于应用程序环境的全局变量接口，通过它可以允许去获得资源或者类，例如启动Activity,广播，intent等等。\n\n我的理解：Context的具体实现是Application, Activity,Service，通过Context能够有权限去做一些事情，其实我觉得就是一个运行环境的问题。\n\n需要注意的地方 \n\n Android开发中由于很多地方都包含了Context的使用，因此就必须要注意到内存泄露或者是一些可能会引起的问题。\n\n例如在Toast中，它的Context就最好设置为Application Context，因为如果Toast在显示东西的时候Activity关闭了，但是由于Toast仍然持有Activity的引用，那么这个Activity就不会被回收掉，也就造成了内存泄露。\n\n上面举例的时候举到了Toast，其实Toast也是很有意思的一个东西，它的show方法其实并不是显示一个东西这么简单。 \n\n Toast实际上是一个队列，会通过show方法把新的任务加入到队列当中去，列队中只要存在消息就会弹出来使用，而队列的长度据说默认是40个（这是网上搜出来的，我在源码中没找到对应的设置，感觉也没啥必要就没找了）。 \n\n 所以这里就要注意一下show这个操作了，它并不是显示内容，而是把内容入队列。\n\n对于Handler来说，如果我们直接在AndroidStudio中创建一个非静态内部类Handler，那么Handler这一大片的区域会被AS标记为黄色，这个应该很多人都遇到过吧。实际上是因为这样设置会造成内存泄露，因为每一个非静态内部类都会持有一个外部类的引用，那么这里也就产生了一个内存泄露的可能点，如果当Activity被销毁时没有与Handler解除，那么Handler仍然会持有对该Activity的引用，那么就造成了内存泄露。\n\n解决方案 \n\n 使用static修饰Handler，这样也就成了一个静态内部类，那么就不会持有对外部类的引用了。而这个时候就可以在Handler中创建一个WeakReference（弱引用）来持有外部的对象。只要外部解除了与该引用的绑定，那么垃圾回收器就会在发现该弱引用的时候立刻回收掉它。\n\n关于垃圾回收的相关总结看我之前的博客，传送门：JVM原理及底层探索\n\n上面扯到了弱引用，就再BB一下四种引用方式吧。\n\n类加载器按层次从顶层到下依次为Boorsrtap ClassLoader（启动类加载器）,Extension ClassLoader（拓展类加载器），ApplicationClassLoader（应用程序类加载器）\n\n这里就需要介绍一下双亲委派模式了： \n\n 双亲委派模式的意思就是：除了启动类加载器之外，其余的加载器都需要指定一个父类的加载器，当需要加载的时候会先让父类去试着加载，如果父类无法加载也就是找不到这个类的话就会让子类去加载\n\n比如类A和类B都要加载system类，如果不是委托的话，类A就会加载一份，B也会加载一份，那么就会出现两份SYstem字节码 \n\n 如果使用委托机制，会递归的向父类查找，也就是首选用Bootstrap尝试加载，如果找不到再向下，如果A用这个已经加载了的话会直接返回内存中的system而不需要重新加载。那么就只会存在一份\n\n对于Java来说，类是需要使用到时才会加载，这里也就出现了一个延迟加载的效果。而在延迟加载的时候，会默认保持同步。这也就产生了一种单例模式的方式，具体的看我之前的博客：设计模式_单例模式\n\n我觉得在android所有的创建单例模式方法中里延迟加载方式是最好吧，虽然枚举比延迟加载更好，effiective java中也很推荐，但是并不怎么适用于Android，Android里枚举的消耗是static的两倍，延迟加载的话只要我们在使用延迟加载方式时做好反序列化的返回值readResolve()准备就好了。\n\n上面BB了太多其他的，现在有点缓不过来，下次自己看自己博客的时候会不会都被自己的思路带得乱七八糟的。\n\n上面的时候我们就已经完成了整个Android系统的开机以及初始化。接下来就可以B一下从点击APP图标开始到APP内部程序运行起来的流程了。\n\n当我们点击屏幕时，触摸屏的两层电极会连接在一起，也就产生了一个电压（具体的我忘了，书上有，图找不到了），当产生电压的时候，就可以通过对应的驱动把当前按压点的XY坐标传给上层，这里也就是操作系统。操作系统在获取到XY值的时候，就会对按压点的范围进行一个判断，如果确定按压点处于一个APP图标或者是Button等等的范围中时，操作系统也就会认为用户当前已经点击了这个东西，启动对应的监听。\n\n而当系统判断我们点击的是APP图标时，该App就由Launcher开始启动了【断点3】\n\nLauncher是一个继承自Activity，同时实现了点击事件，长按事件等等的一个应用程序。\n\n当我们点击一个APP的图标时，会调用Launcher内部的startActivitySafely()方法，而这个方法则会进行两件事，一个是启动目标activity，另一个功能就是捕获异常ActivityNotFoundException，也就是常见的“找不到activity,是否已经在androidmenifest文件中注册？”。而在startActivity方法中，经过一系列的转换最终会调用到startActivityForResult这个方法。\n\n所以实际上，我对整个Android的界面是这样理解的： \n\n 当系统完成初始化以及各种服务的创建之后，就会启动Launcher这个应用程序（它也是继承自Activity的，包含自己对应的xml布局文件），然后再把各种图标按照一个正常APP布局的方式放在上面，当我们点击APP图标时，也就相当于在Launcher这个APP应用程序中通过startActivity（在底层最后会转为startActivityForResult）来启动这个APP。简单的讲，我觉得就是一个主要的APP（Launcher）里面启动了其他的功能APP，例如QQ、微信这些。【个人理解，如果以后发现不对再修改】\n\n当我们手指按下时，Android是如何处理点击事件的呢？如何确定是让哪一个控件来处理呢？ \n\n 简单一句话：层层传递-冒泡的方式处理 \n\n 举个例子：现在公司来了个小项目，老板一看分配给经理做，经理一看分配给小组长，小组长一看好简单，分配给组员。如果在这个传递过程中（也就是还为分配到最底部时），某一层觉得我来负责这个比较好的话就会拦截掉这个消息，然后把它处理了，下面的就收不到有消息的这个通知。如果一直到了底层的话，组员如果能完成，就完成它。如果不能完成，那么就报告给组长，说组长我做不来，边学边做要影响进度。组长一看我也做不来，就给经理，经理一看我也不会，就给老板。这样也就一层层的传递了。 \n\n 总结一下就是消息从上到下依次传递，如果在传递的过程中被拦截了就停止下传。如果没有被拦截，就一直传递到底部，如果底部不能够消耗该消息，那么就又一层层的返回来，返给上层，直到被消耗或者是到达最顶层。\n\n第一个方法负责事件的分发，它的返回值就是表示是否消耗当前事件。 \n\n 第二个方法是用于判断是否拦截该消息，如果当前View拦截了某个时间，那么在同一个事件序列中，此方法不会被再次调用。返回结果表示是否拦截当前事件 \n\n 第三个方法就是处理事件。返回结果表示是否消耗当前事件，如果不小号，则在同一时间序列中，当前View无法再次接收到事件。\n\n对于一个根ViewGroup来说，点击事件产生后，首先会传递给它，调用它的dispath方法。如果这个ViewGroup的onIntercept方法返回true就表示它要拦截当前事件，false就表示不拦截，这个时候事件就会继续传递给子元素，接着调用子元素的dispath方法，直到被处理。\n\n顺带总结一下滑动冲突的解决吧 \n\n View的滑动冲突一般可以分为三种：\n\n比如说一个常见的，外部一个ListView，里面一个ScrollView。这个时候该怎么解决呢？其实这里想到了ViewPager，它里面实际上是解决了滑动冲突的，可以借鉴一下它的。\n\n滑动处理规则 \n\n 一般来说，我们可以根据用户手指滑动的方向以及角度来判断用户是要朝着哪个方向去滑动。而很多时候还可以根据项目的需求来指定一套合适的滑动方案。\n\n外部拦截法 \n\n 这种方法就是指所有的点击时间都经过父容器的拦截处理，如果父容器需要此时间就拦截，如果不需要此事件就不拦截。通过重写父容器的onInterceptTouchEvent方法：\n\n这里有一点需要注意，ACTION_DOWN事件父类容器就必须返回false，因为如果父类容器拦截了的话，后面的Move等所有事件都会直接由父类容器处理，就无法传给子元素了。UP事件也要返回false，因为它本身来说没有太多的意义，但是对于子元素就不同了，如果拦截了，那么子元素的onClick事件就无法触发。\n\n内部拦截法 \n\n 这种方法指的是父容器不拦截任何时间，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交给父容器进行处理。它需要配合requestDisallowInterceptTouchEvent方法才能正常工作。我们需要重写子元素的dispatch方法\n\n这种方法的话父类容器需要默认拦截除了ACTION_DOWN以外的其他时间，这样当子元素调用request方法的时候父元素才能继续拦截所需的事件。\n\n其他的 \n\n 如果觉得上面两个方式太复杂，看晕了，其实也可以自己根据项目的实际需要来指定自己的策略实现。例如根据你手指按的点的位置来判断你当前触碰的是哪个控件，以此来猜测用户是否是要对这个控件进行操作。如果点击的是空白的地方，就操作外部控件即可。\n\n【等有时间了就把ViewPager的处理总结一下，挺重要的】\n\nAndroid的消息机制主要是指Handler的运行机制，Handler的运行需要底层的MessageQueue和Looper的支撑\n\n虽然MessageQueue叫做消息队列，但是实际上它内部的存储结构是单链表的方式。由于Message只是一个消息的存储单元，它不能去处理消息，这个时候Looper就弥补了这个功能，Looper会以无限循环的形式去查找是否有新消息，如果有的话就处理消息，否则就一直等待（机制等会介绍）。而对于Looper来说，存在着另外的一个很重要的概念，就是ThreadLocal。\n\nThreadLocal它并不是一个线程，而是一个可以在每个线程中存储数据的数据存储类，通过它可以在指定的线程中存储数据，数据存储之后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到该线程的数据。 \n\n 举个例子，多个线程通过同一个ThreadLocal获取到的东西是不一样的，就算有的时候出现的结果是一样的（偶然性，两个线程里分别存了两份相同的东西），但他们获取的本质是不同的。\n\n那为什么有这种区别呢？为什么要这样设计呢？ \n\n 先来研究一下为什么会出现这个结果。 \n\n 在ThreadLocal中存在着两个很重要的方法，get和set方法，一个读取一个设置。\n\n摘自源码 \n\n 首先研究它的get方法吧，从注释上可以看出，get方法会返回一个当前线程的变量值，如果数组不存在就会创建一个新的。 \n\n 这里有几个很重要的词，就是“当前线程”和“数组”。 \n\n 这里提到的数组对于每个线程来说都是不同的，values.table，而values是通过当前线程获取到的一个Values对象，因此这个数组是每个线程唯一的，不能共用，而下面的几句话也更直接了，获取一个索引，再返回通过这个索引找到数组中对应的值。这也就解释了为什么多个线程通过同一个ThreadLocal返回的是不同的东西。\n\n那这里为什么要这么设置呢？翻了一下书，搜了一下资料：\n\n上面提到了Handler/Looper/Message Queue，它们实际上是一个整体，只不过我们在开发中接触更多的是Handler而已，Handler的主要作用是将一个任务切换到某个指定的线程中去执行，而Android之所以提供这个机制是因为Android规定UI只能在主线程中进程，如果在子线程中访问UI就会抛出异常。\n\n为什么Android不允许在子线程访问UI \n\n 其实这一点不仅仅是对于Android,对于其他的所有图形界面现在都采用的是单线程模式。 \n\n 因为对于一个多线程来说，如果子线程更改了UI，那么它的相关操作就必须对其他子线程可见，也就是Java并发中很重要的一个概念，线程可见性，Happen-before原则【下篇博客总结一下自己对Java并发的理解吧，挺重要的，总结完后再把传送门贴过来】而一般来说，对于这种并发访问，一般都是采用加锁的机制，但是加锁的机制存在很明显的问题：让UI访问间的逻辑变得复杂，同时效率也会降低。甚至有的时候还会造成死锁的情况，这个时候就麻烦了。 \n\n 而至于究竟能不能够实现这种UI界面的多线程呢？SUN公司的某个大牛（忘了是谁，很久之前看的，好像是前副总裁）说：“行肯定是没问题，但是非常考技术，因为必须要考虑到很多种情况，这个时候就需要技术专家来设计。而这种设计出来的东西对于广大普通程序员来说又是异常头疼的，就算是实现了多线程，普通人用起来也是怨声载道的。所以建议还是单线程”。\n\n举个常见的死锁例子：进程A中包含资源A,进程B中包含资源B，A的下一步需要资源B，B的下一步需要资源A，所以它们就互相等待对方占有的资源释放，所以也就产生了一个循环等待死锁。\n\nMessageQueue主要包含两个操作：插入和读取，读取操作本身会伴随着删除操作，插入和读取对应的方法分别为enqueueMessage和next，其中enqueueMessage的作用是往消息队列中插入一条消息，而next的作用是从消息队列中取出一条消息并将其从消息队列中移除。这也就是为什么使用的是一个单链表的数据结构来维护消息列表，因为它在插入和删除上比较有优势（把下一个连接的点切换一下就完成了）。\n\n而对于MessageQueue的插入操作来说，没什么可以看的，也就这样吧，主要需要注意的是它的读取方法next。\n\n源码有点长，总结一下就是： \n\n next方法它是一个死循环，如果消息队列中没有消息，那么next方法就会一直阻塞在这里，当有新的消息来的时候，next方法就会返回这条信息并将其从单链表中移除。\n\n而这个时候勒Looper就等着的，它也是一直循环循环，不停地从MessageQueue中查看是否有新消息，如果有新消息就会立刻处理，否则就会一直阻塞在那里。而对于Looper来说，它是只能创建一个的，这个要归功与它的prepare方法。\n\n从这里我们就可以看出该prepare方法会首先检测是否已经存在looper了，如果不存在，就创建一个新的；如果存在，就抛出异常。 \n\n 而之后使用Looper.loop()就可以开启消息循环了。\n\n从这里面我们可以看到它也是个死循环，会不停的调用queue.next()方法来获取信息，如果没有，就return,如果有就处理。\n\n注意 \n\n 当然了，这里有一个很重要的点，一般可能会忘，那就是在子线程中如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来终止消息循环，否则这个子线程就会一直处于等待状态，而如果退出Looper之后，这个线程就会立刻终止，所以建议不需要使用的时候终止Looper。\n\nHandler \n\n 上面总结了Looper和MessageQueue，这里就对Handler进行一个总结吧。它的工作主要包含消息的发送和接受过程，消息的发送可以通过post的一系列方法以及send的一系列方法来实现，post的一系列方法最终是通过send的一系列方法来实现的。 \n\n 实际上它发送消息的过程仅仅是向消息队列中插入了一条消息，MessageQueue的next方法就会返回这条消息给Looper，Looper在收到消息之后就会开始处理了。最后由Looper交给Handler处理（handleMessage()方法）。\n\n上面总结完了Android的消息处理机制，那么就顺带总结一下IPC通信吧，毕竟上面提到过那么多次Binder和Socket。\n\n资料：为什么Android要采用Binder作为IPC机制？ \n\n 知乎上面的回答相当的好，这个博主对系统底层也是颇有钻研，学习。\n\n这里就结合上面的知乎回答以及加上《Linux程序设计》还有一本Linux内核剖析（书名忘了但是讲得真的非常好），掺杂一些个人的理解。\n\n进程的定义 \n\n UNIX标准把进程定义为：“一个其中运行着一个或多个进程的地址控件和这些线程所需要的系统资源”。目前，可以简单的把进程看做正在运行的程序。\n\n进程都会被分配一个唯一的数字编号，我们成为PID（也就是进程标识符），它通常是一个取值范围从2到32768的正整数。当进程被启动时，系统将按顺序选择下一个未被使用的数字作为PID，当数字已经回绕一圈时，新的PID重新从2开始，数字1一般是为init保留的。在进程中，存在一个自己的栈空间，用于保存函数中的局部变量和控制函数的调用与返回。进程还有自己的环境空间，包含专门为这个进程建立的环境变量，同时还必须要维护自己的程序计数器，这个计数器用来记录它执行到的位置，即在执行线程中的位置。 \n\n 在Linux中可以通过system函数来启动一个进程\n\n守护进程 \n\n 这里就需要提到一个守护进程了，这个在所有的底层中经常都会被提到。 \n\n 在linux或者unix操作系统中在系统引导的时候会开启很多服务，这些服务就叫做守护进程。为了增加灵活性，root可以选择系统开启的模式，这些模式叫做运行级别，每一种运行级别以一定的方式配置系统。 守护进程是脱离于终端并且在后台运行的进程。守护进程脱离于终端是为了避免进程在执行过程中的信息在任何终端上显示并且进程也不会被任何终端所产生的终端信息所打断。 \n\n 守护进程常常在系统引导装入时启动，在系统关闭时终止。如果想要某个进程不因为用户或终端或其他的变化而受到影响，那么就必须把这个进程变成一个守护进程\n\n防止手机服务后台被杀死 \n\n 是不是在手机的设置界面看当前正在运行的服务时会发现有的APP不止存在一个服务？有的APP后台存在两个，有的存在三个？有的流氓软件也会这么设置，这样的话就可以一直运行在后台，用户你关也关不了（倒不是说所有这么设置的都是流氓软件，因为有的软件需要保持一个长期的后台在线，这是由功能决定的）。\n\n这里有两种方法（可能还有更多，这里只总结我了解的）：\n\nIPC通信 \n\n 上面总结了进程的相关基础，这里就开始总结一下进程间通信（IPC \n\n ）的问题了。 \n\n 现在Linux现有的所有IPC方式：\n\n到了这里，就有了问题，为什么在Linux已经存在这么多优良的IPC方案时，Android还要采取一种新的Binder机制呢？ \n\n 猜测：我觉得Android采用这种新的方式（当然也大面积的同时使用Linux的IPC通信方式），最多两个原因：\n\n刚才谈到Binder的时候提了一下效率的问题，那这里就不得不讲到反射了。\n\n反射它允许一个类在运行过程中获得任意类的任意方法，这个是Java语言的一个很重要的特性。它方便了程序员的编写，但是降低了效率。\n\n实际上，对于只要不是特别大的项目（非Android），反射对于效率的影响微乎其微，而与之对比的开发成本来说就更划算了。 \n\n 但是，Android是一个用于手机的，它的硬件设施有限，我们必须要考虑到它的这个因素，用户体验是最重要的。以前看到过国外的一项统计。在一个APP中的Splash中使用了反射，结果运行时间增加了一秒，这个已经算是很严重的效率影响了。\n\n为什么反射影响效率呢 \n\n 这里就需要提到一个东西，JIT编译器。JIT编译器它可以把字节码文件转换为机器码，这个是可以直接让处理器使用的，经过它处理的字节码效率提升非常大，但是它有一个缺点，就是把字节码转换成机器码的过程很慢，有的时候甚至还超过了不转换的代码效率（转换之后存在一个复用的问题，对于转换了的机器码，使用的次数越多就越值的）。因此，在JVM虚拟机中，也就产生了一个机制，把常用的、使用频率高的字节码通过JIT编译器转换，而频率低的就不管它。而反射的话则是直接越过了JIT编译器，不管是常用的还是非常用的字节码一律没有经过JIT编译器的转化，所以效率就会低。 \n\n 而在Android里面，5.0之前使用的是Davlik虚拟机，它就是上面的机制，而在Android5.0之后Google使用了一个全新的ART虚拟机全面代替Davlik虚拟机。 \n\n ART虚拟机会在程序安装时直接把所有的字节码全部转化为机器码，虽然这样会导致安装时间边长，但是程序运行的效率提升非常大。 \n\n 【疑问：那在Android5.0之后的系统上，反射会不会没影响了？由于现在做项目的时候更多考虑的是向下兼容，单独考虑5.0的情况还没有，等以后有需求或者是有机会的时候再深入了解一下，以后更新】\n\n刚才总结了Android的消息处理机制和IPC通信，那么我们主线程的消息处理机制是什么时候开始的呢？因为我们知道在主线程中我们是不需要手动调用Looper.prepare()和Looper.loop()的。\n\nAndroid的主线程就是ActivityThread，主线程的入口方法是main方法，在main方法中系统会通过Looper.prepareMainLooper()来创建主线程的Looper以及MessageQueue，并通过Looper.loop来开启消息循环，所以这一步实际上是系统已经为我们做了，我们就不再需要自己来做。 \n\n ActivityThread通过AppplicationThread和AMS进行进程件通信，AMS以进程间通信的方式完成ActivityThread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向Handler发送消息，Handler收到消息后会将ApplicationThread中的逻辑切换到主线程中去执行，这个过程就是主线程的消息循环模型。\n\n上面总结到了APP开始运行，依次调用onCreate/onStart/onResume等方法，那么在onCreate方法中我们经常使用的setContentView和findViewById做了什么事呢？\n\n首先，就考虑到第一个问题，也就是setContentView这个东西做了什么事，这里就要对你当前继承的Activity分类了，如果是继承的Activity，那么setContentView源码是这样的：\n\n这里面存在着3个重载函数，而不管你调用哪一个，最后都会调用到initWindowDecorActionBar()这个方法。 \n\n 而对于新的一个AppcompatActivity，这个Activity里面包含了一些新特性，现在我做的项目里基本都是使用AppcompatActivity代替掉原来的Activity，当然也并不是一定的，还是要根据项目的实际情况来选择。 \n\n 在AppcompatActivity中，setContentView是这样的：\n\n一样的3个重载函数，只是里面没有了上面的那个init方法，取而代之的是一个getDelegate().setContentView，这个delegate从字面上可以了解到它是一个委托的对象，源码是这样的：\n\n而在AppCompatDelegate.Create方法中，则会返回一个很有意思的东西：\n\n这里会根据SDK的等级来返回不同的东西，这样的话就不深究了，底层的话我撇了一下，应该原理和Activity是一样的，可能存在一些区别。这里就用Activity来谈谈它的setContentView方法做了什么事。\n\n这里就介绍了它的功能，它会按照一个布局资源去设置Activity的内容，而这个布局资源将会被引入然后添加所有顶级的Views到这个Activity当中。 \n\n 这是个啥意思勒。 \n\n 下面从网上扒了一张图： \n\n \n\n 这里是整个Activity的层级，最外面一层是我们的Activity，它包含里面的所有东西。 \n\n 再上一层是一个PhoneWindow，这个PhoneWindow是由Window类派生出来的，每一个PhoneWindow中都含有一个DecorView对象，Window是一个抽象类。 \n\n 再上面一层就是一个DecorView，我理解这个DecorView就是一个ViewGroup，就是装View的。 \n\n 而在DecoreView中，最上面的View就是我们的TitleActionBar，下面就是我们要设置的content。所以在上面的initWindowDecorActionBar就能猜到是什么意思了吧。\n\n而在initWindowDecorActionBar方法中，有一段代码：\n\n注意上面的window.getDecoreView（）方法的注释，该方法会设置一些window的标志位，而当这个方法执行完之后，就再也不能更改了，这也就是为什么很多第三方SDK设置window的标志位时一定要求要在setContentView方法前调用。\n\nfindViewById根据继承的Activity类型的不同也存在着区别，老规矩，还是以Activity的来。\n\n从源码来看，findViewById也是经过了一层层的调用，它的功能如同它上面的注释一样，通过一个view的id属性查找view，这里也可以看到一个熟悉的getWindow方法，说明findViewById()实际上Activity把它也是交给了自己的window来做\n\n而在这里面，又调用了getDecorView的findViewById（）方法，这也相当于是一个层层传递的过程，因为DecorView我理解为就是一个ViewGroup，而当运行getDecorView().findViewById()方法时，就会运行View里面的findViewById方法。它会使用这个被给予的id匹配子View的Id，如果匹配，就返回这个View，完成View的绑定\n\n最后总结一下（Activity中），findViewById的过程是这样的： \n\n Activity -> Window -> DecorView -> View", "link": "http://blog.csdn.net/jonstank2013/article/details/51118563", "publishDate": "2016-04-12 00:10", "title": "\r\n        "}
{"readCount": "269", "article": "要在/usr/linux中查找所有的*.h，并在这些文件中查找“SYSCALL_VECTOR\"，最后打印出所有包含\"SYSCALL_VECTOR\"的文件名，有以下几种方法实现\n\n find /usr/linux -name \"*.h\" | xargs -n50 grep SYSCALL_VECTOR\n\n grep SYSCALL_VECTOR /usr/linux/*.h | cut -d’:’ -f1 | uniq > filename\n\n find /usr/linux -name \"*.h\" -exec grep \"SYSCALL_VECTOR\" {} \\; -print\n\n我用find / -name filename| rm -rf，不成功，请问为什么不成功？\n\n find / -name filename -exec rm -rf {} \\;\n\n find . -name filename |rm -rf试一下{} 表示你找出来的结果。\n\n \\; 则相当于“宪法”，没什么说头，就是这么规定的，在 -exec 后面需要一个表示该命令终结的的符号。可以在 man find 中找到答案。\n\n 要让rm识别find的结果，如下：\n\n find / -name filename |xargs rm -rf\n\n 之所以find . -name filename |rm -rf不通过，是因为rm命令不接受从标准输入传过来的指令\n\n 查找含特定字符串的文件\n\n 例如查找当前目录下含有\"the string you want find…\"字符串的文件：\n\n $find . -type f -exec grep “the string you want find…” {} ; -print\n\nfind 的perm问题\n\n 请问一下以下命令什么意思？关键是那个数字前的-，其他都还知道\n\n find -name \".*\" -perm -007\n\n 我知道\n\n find -name \".*\" -perm 755\n\n 这个是用来查找权限位为755的隐藏文件\n\n 噢，对了还有，我上边的命令都省略了find的pathname参数 find默认是查找当前工作目录的吗？\n\n 如果我用 -ok 替代 -exec, 那么还需要加上 {} \\; 吗？\n\n 这个已经清楚，仍然需要，因为 -ok 只是 -exec 的提示模式，它只是多了一个确认操作的步骤,刚才没有读懂那几句E文的意思 呵呵 不好意思\n\n -007是指查找所有用户都可读、写、执行的文件，要小心呀~~~\n\n 解释解释？\n\n find -name \".*\" -perm -007 和 find -name \".*\" -perm 777 有区别吗？\n\n -007是怎么来得呢？\n\n 不过有一个问题\n\n 我用 find . -perm -100 会列出当前目录 . , 这是为什么呢？\n\n下面引用由explover在 2002/10/01 06:15am 发表的内容：\n\n -007是指查找所有用户都可读、写、执行的文件，要小心呀~~~\n\n -007是查找含其它用户(不同组,非属主)可读,写,执行的文件.并不一定要同组可读写,-是指最少权限为007.\n\n 下面引用由一颗小白菜在 2002/10/01 10:16am 发表的内容：\n\n OK了， 呵呵\n\n 不过有一个问题\n\n 我用 find . -perm -100 会列出当前目录 . , 这是为什么呢？\n\n 这种方法不会准确的找出目录的. -100是指权限至少是属主可运行.\n\n 在unix系统下,你可以拥有对目录文件的执行权你才可以进入一个目录.这便是目录文件被列出的原因.\n\n find . -perm -001 -print找到往往是目录文件.\n\n 我的意思当然不是使用这种方法来找目录，只不过不明白其中的 -100 意义了\n\n 那以此类推，是不是 -010是指权限至少是owner同组可执行的吗？也就是说其实这里的010和-是分开的，-表示一个至少的意思，而且010才是真正用来描述权限位的？\n\n 这样子就明白了 谢谢你噢\n\n将find出来的东西拷到另一个地方?\n\n find *.c -exec cp ‘{}’ /tmp ‘;’\n\n 如果有特殊文件，可以用cpio，也可以用这样的语法：\n\n find dir -name filename -print | cpio -pdv newdir\n\n如何用find查找某一天更改的文件？\n\n 可以使用这一行命令来实现：\n\n A=`find ~ -print` | ls -l –full-time $A 2>/dev/null | grep \"Jun 27\" | grep 1998\n\n使用find 命令查找某个时间段的shell怎么写。比如11点到12点的。thanks\n\n 创建一个脚本judgetime，内容如下：\n\n ls -l $*|awk ‘{split($8,hour,\":\");if((hour[1]>23 || hour[1] < 1)&&hour[1]<24)print}’\n\n 到要查找的目录下，运行\n\n find ./ -name \"*\" -exec judgetime {} \\;\n\n 注意时间格式为２４小时制。\n\n thank you ，如果我要精确到分钟呢\n\n touch -t 04241112 starttemp #精确到12分钟\n\n touch -t 04241220 endtemp #截止到12点20\n\n find [dir] -newer starttemp -a ! -newer endtemp -exec ls -l {} \\;\n\n ｎｅｗｅｒ？\n\n 那昨天１２：１０文件如何呢？\n\n 每天执行的时候，用当天的日期和时间戳替换一下不就行了吗？\n\n 我不知道他是不是把所有的11：00~12：00的都找出来，是不是只执行一次还是每天都执行？\n\n 这种情况俺猜想是自己的东西放在哪忘了，只记得当时是深夜了。\n\n 有道理！\n\n 不愧是斑竹！\n\n 不光知道怎么解决问题，还知道在什么情况下出现这类问题，佩服佩服！\n\n 问题又出现了。创建这个文件的时候。本来应该是时间的一栏现在写上了2002，而不是12：00.\n\n 等到12：00过了吧！\n\n删除指定日期的文件\n\n find ./ -name 文件名 -exec rm -f {} \\;\n\n 例：删除当前30天内没用过的文件,用如下命令：\n\n find / -atime +30 -exec rm -f {} \\;\n\n 我自己试着写了一小段SHELL,也用ll ,grep, rm 几个命令，用起来还差强人意。\n\n 对过滤出来的文件名列表中用了一个FOR语句，再执行rm 。现在我想把这段SHELL 扩展一下让它每天定时运行将 n 天前的文件删掉，有没有人能给我一些提示，谢谢！\n\n 还有个问题，对于前面那位朋友提到的\"find / -atime +30 -exec rm -f {} \\;\n\n \"方法，我很早就试过几次，不过好像都不太对，参数 -atime n 是查找n天前被访问过的文件，我不明白的是这里的时间参照点是什么，以及这个n天是怎么计算的。\n\n 问 题二、对于\"ll |cut -f 1\" 这个命令我是不是用错了，我只想取出 ll 中列出的文件名，但用cut -f 命令做不到 ，我只好换用 ll |cut -c 59- 这种方式得到我要的文件名，but it’s a pool idear ！我也试过用awk ，好像也不对，看看大家可不可以给我一些小小的提醒，TKS SO MUCH\n\n 问题三、如何改变 I结点 的日期格式 我现在的系统显示的格式是：\n\n -rw-r—– 1 msahz01 users 2253 2002年2月 2日 poheader.i\n\n 我想把这换成\n\n -rw-rw-rw- 1 house users 2193 Apr 19 2001 hkdisp.p\n\n 如何才能做到这点？\n\n awk 应该可以\n\n ll | awk ‘{print $9}’\n\n 删除多少天之前的文件\n\n find /yourpath -mtime +31 -exec rm {} \\;\n\n find /yourpath -mtime +366 -exec rm {} \\;\n\n请问 -ctime 和 -mtime 有什么关系 ?\n\n 如果父目录的 ctime 改变, 那它下面的文件的 ctime 就会自动都改了吗 ?\n\n -ctime 和 -mtime ,-atime 这些信息是存在哪儿呢 ?\n\n我用 -mtime -1 找到了新建或改的文件.\n\n 但怎样才能找到一天内 mv 来的文件呢( 它们的时间是原有的时间,早于一天 ) ?\n\n用-newer选项啊。\n\n 你可以先touch一个你想要的时间的文件如下：\n\n $ touch -t 08190800 test\n\n $ ls -l test\n\n -rw-r–r– 1 dba other 0 Aug 19 08:00 test\n\n 然后\n\n $ find . -newer test -print\n\n .\n\n ./.sh_history\n\n $ ls -l .sh_history\n\n -rw——- 1 dba other 154 Aug 20 17:39 .sh_history\n\n用touch可以写出你想要的任何时间的文件，然后用-newer ,! -newer选项即可成功。\n\n1.ctime含inode信息修改的时间.mtime只指文件内容建立或修改的时间.\n\n 2 不会.\n\n 3.这些信息应该是存在文件系统的超级块里.\n\n我查了书 -ctime 是指 inode 的改变(或称文件的状态改变).\n\n 请问 inode 存了哪些信息 ?\n\n 做了些小测试,-mtime 改, -ctime 一定也改.\n\n 改文件名, -ctime 也会改.\n\n 谁能回答 i-node 存了哪些东西 ?\n\n班主,我不能 access /usr/include/sys/inode.h .\n\n 摘书如下:\n\n Directories contain directory entries. Each entry contains a file or subdirectory name and an index node reference number (i-node number). To increase speed and enhance use of disk space, the data in a file is stored at various locations in the computer’s memory. The i-node contains the addresses used to locate all the scattered blocks of data associated with a file. The i-node also records other information about the file including time of modification and access, access modes, number of links, file owner, and file type.\n\n 可我发现 -atime 改了, -ctime 还没改. why ?\n\n ( 我先 cat 一个 ASCII 文件,再用 -atime -1 有它用 -ctime -1 居然没有它.)\n\n 着岂不跟 inode 信息改变, ctime 就改矛盾吗?\n\n我不同意你贴出来的那段文章,正如我提到的那样,atime,ctime,mtime是放到超级块里,在sco unix下是一种叫stat的结构.(stat_32),不同的系统文件系统可能不同.\n\n sco 下inode的结构如下:\n\n所以,访问一个文件不能改变inode信息.\n\n 使用chown, chgrp, chmod命令可以很好的比较mtime和ctime\n\n chown改变一个文件的属主,用ctime可以找到,用mtime便找不到.\n\n 试试看.\n\n多谢斑竹! 我是在 Solaris 上面试的.我是对 -ctime 不明白.\n\n 试的结果如下:\n\n 修改文件,-mtime 改了, -ctime 也会改.\n\n 访问文件,-atime 改了, -ctime 没变.\n\n chown, chgrp, chmod,mv, 都会使 -ctime 改变,但不影响 -atime 和 -mtime.\n\n touch 可以改 -mtime and/or -atime,但 touch -a 只改访问时间时,-ctime也改了.\n\n touch -m 改修改时间时,-ctime当然也改了.\n\n 好象还有别的很多东西可以令 -ctime 改变, 搞不清楚.\n\n 有什么方法可以显示 -mtime,atime,ctime 吗?\n\n 可以用 -ctime 来实现对目录的增量文件进行备份或 transfer 吗 ?\n\n 多谢!\n\n没有什么工具显示,(可能是俺不知道)\n\n 把下面程序里的st_mtime换成st_ctime,或st_atime便可以得到你要的了.\n\n #include\n\n int\n\n main (int argc, char **argv)\n\n {\n\n struct stat buf;\n\n char date[80];\n\n char fname[80];\n\n printf(\"Enter filename (with full path) to check mtime : \");\n\n scanf(\"%s\",fname);\n\n stat(fname, &buf);\n\n printf (\"mtime (in sec) of %s = %ld\n\n\", fname, buf.st_mtime);\n\n strcpy(date, ctime((time_t *)&(buf.st_mtime)));\n\n printf (\"mtime (in date) of %s = %s\n\n\", fname, date);\n\n }\n\n至于文件备份,有什么不可以的么?\n\nmtime ls -l 最近修改文件内容的时间\n\n atime ls -lu 最近访问文件的时间\n\n ctime ls -li 最近文件有所改变的状态 ,如文件修改,属性\\属主 改变 ,节点 ,链接变化等 ,应该是不拘泥只是时间前后的改变\n\n俺看了ls的帮助,以为只是按ctime或atime排序,显示的时间还是mtime.\n\n仔细比较了一下,ayhan说的是对的.谢谢ayhan.\n\n多谢 ahyan 提示 ! 我在 Solaris 上试过如下:\n\n mtime 用 ls -l 看到\n\n atime 用 ls -lu 看到\n\n ctime 用 ls -lc 看到. (ls -li 只有 inode number)\n\n 摘书如下:\n\n -c Uses time of last modification of the i-node (file\n\n created, mode changed, and so forth) for sorting (-t)\n\n or printing (-l or -n).\n\n -u Uses time of last access instead of last modification\n\n for sorting (with the -t option) or printing (with the\n\n -l option).\n\n -i For each file, prints the i-node number in the first\n\n column of the report.", "link": "http://blog.csdn.net/sjz4860402/article/details/20901577", "publishDate": "2014-03-10 09:53", "title": "\r\n        Linux中find常见用法示例            \r\n        "}
{"readCount": "272", "article": "下面是一些关于apt-get的参数和作用的说明：\n\n常用的APT命令参数：(<package>,就表示包的名字，用<>括起来方便看)", "link": "http://blog.csdn.net/sjz4860402/article/details/20903085", "publishDate": "2014-03-10 10:13", "title": "\r\n        Linux之apt-get            \r\n        "}
{"readCount": "250", "article": "应用组件 ( 客户端 ) 可以调用 bindService() 绑定到一个 service ． Android 系统之后调用 service 的 onBind() 方法，它返回一个用来与 service 交互的 IBinder ．\\\n\n绑定是异步的． bindService() 会立即返回，它不会返回 IBinder 给客户端．要接收 IBinder ，客户端必须创建一个 ServiceConnection 的实例并传给 bindService() ． ServiceConnection 包含一个回调方法，系统调用这个方法来传递要返回的 IBinder ．\n\n注：只有 activities,services, 和 contentproviders 可以绑定到一个 service— 你不能从一个 broadcastreceiver 绑定到 service ．\n\n\n\n 所以，从你的客户端绑定到一个 service ，你必须：\n\n系统调用这个来传送在 service 的 onBind() 中返回的 IBinder ． Android 系统在同 service 的连接意外丢失时调用这个．比如当 service 崩溃了或被强杀了．当客户端解除绑定时，这个方法不会被调用． ３当系统调用你的 onServiceConnected() 方法时，你就可以使用接口定义的方法们开始调用 service 了． 当你的客户端被销毁，它将从 service 解除绑定，但是你必须总是在你完成与 service 的交互时或当你的 activity 暂停于是 service 在不被使用时可以关闭此两种情况下解除绑定． ( 下面会讨论更多在适当的时候绑定和解除绑定的问题． )\n\n使用这个 ServiceConnection ，客户端可以绑定到一个 service ，通过把它传给 bindService() ．例如：\n\n下面是一些关于绑定到 service 的重要事项：\n\n\n\n 注：你一般不应该在你的 activity 的 onResume() 和 onPause() 中绑定和解除绑定到 service ，因为这些回调方法 , 出现在每个生命期变化中，并且你需要使发生在这些变化中的处理最小化．还有，如果你应用中的多个 activity 绑定到同一个 service ，并且有一个变化发生在其中两个 activity 之间， service 可能在当前 activity 解除绑定 (pause 中 ) 和下一个绑定前 (rusume 中 ) 被销毁又重建．\n\n当一个 service 的所有客户端都解除绑定， Android 系统就销毁它 ( 除非它是从 onStartCommand() 启动 ) ．如果你的 service 是一个纯 boundservice ，你不需管理它的生命期 — Android 系统会为你管理它．\n\n然而，如果你选择了实现 onStartCommand() 回调方法，那么你必须明确地停止 service ，因为 service 现在被认为是＂开始的＂．在此情况下， service 会一直运行，直到 service 使用 stopSelf() 停止它自己或另外的组件调用了 stopService() 停止了它，不管是否有客户端绑定了它．\n\n另外，如果你的 service 已经启动并且接受绑定，那么当系统调用你的 onUnbind() 方法，你可以选择返回 true 表示 你想在客户端下一次绑定到 service 时接受一个对 onRebind() 的调用 ( 而不是一个对 onBind() 的调用 ) ． onRebind() 返回 void ，但是客户端依然会在它的 onServiceConnected() 回调中接收到 IBinder ．下图演示了这种生命其的逻辑：", "link": "http://blog.csdn.net/sjz4860402/article/details/21231089", "publishDate": "2014-03-14 11:49", "title": "\r\n        Android里Service的bindService()和startService()混合使用深入分析            \r\n        "}
{"readCount": "215", "article": "在系统中的Activity被一个Activity栈所管理。当一个新的Activity启动时，将被放置到栈顶，成为运行中的Activity，前一个Activity保留在栈中，不再放到前台，直到新的Activity退出为止。\n\n下面的图显示了Activity的重要状态转换，矩形框表明Activity在状态转换之间的回调接口，开发人员可以重载实现以便执行相关代码，带有颜色的椭圆形表明Activity所处的状态。\n\n在上图中，Activity有三个关键的循环：\n\n整个的生命周期，从onCreate(Bundle)开始到onDestroy()结束。Activity在onCreate()设置所有的“全局”状态，在onDestory()释放所有的资源。例如：某个Activity有一个在后台运行的线程，用于从网络下载数据，则该Activity可以在onCreate()中创建线程,在onDestory()中停止线程。 可见的生命周期，从onStart()开始到onStop()结束。在这段时间，可以看到Activity在屏幕上，尽管有可能不在前台，不能和用户交互。在这两个接口之间，需要保持显示给用户的UI数据和资源等，例如：可以在onStart中注册一个IntentReceiver来监听数据变化导致UI的变动，当不再需要显示时候，可以在onStop()中注销它。onStart()，onStop()都可以被多次调用，因为Activity随时可以在可见和隐藏之间转换。 前台的生命周期，从onResume()开始到onPause()结束。在这段时间里，该Activity处于所有 Activity的最前面，和用户进行交互。Activity可以经常性地在resumed和paused状态之间切换，例如：当设备准备休眠时，当一个 Activity处理结果被分发时，当一个新的Intent被分发时。所以在这些接口方法中的代码应该属于非常轻量级的 。\n\n下面的 Activity 方法定义了 activity 完整的生命周期。他们全都是 hook 方法,你可以重载这些方法从而使 activity 在状态改变时执行你所期望的操作。所有activity 都应该实现自己的 onCreate(Bundle)方法来进行初始化设置;大部分还应该实现 onPause()方法提交数据的修改并且准备终止与用户的交互。尽管我们计划在系统中添加更多的工具来管理应用,现在大多 activity 仍需要实现 onFreeze()并且在 onCreate(Bundle)中执行对应的状态恢复。其他的方法可以在需要时进行实现,当实现这些方法的时候需要注意的是一定要调用父类中的对应方法\n\n 测试生命周期的小例子:\n\n\n\n首先我们看到的最上面的画面是最重要的,并且也是焦点所在。此时可以通过函数onWindowFocusChanged()来判度。此时activity在栈顶。\n\n 在onCreate()-->onContentChanged()-->onStart的过程中还要涉及到一些内部方法的调用,我们来看一下:\n\n onWindowAttributesChanged(WindowManager.LayoutParams params)           当当前窗口属性更改时被调用。\n\n public void onContentChanged()                   当屏幕的目录视图改变(因调用 Window.setContentView 或Window.addContentView))时此钩子被调用。\n\n protected void onApplyThemeResource(Resources.Theme theme, int resid, boolean  first)\n\n 由setTheme(int) 和 getTheme()调用于应用一个主题资源到当前Theme对象。 可以覆盖更改默认的(简单)的行为。这种方法不会被称为多线程。\n\n 我们分情况讨论一下:\n\n (1)只有一个activity的时候:\n\n 流程如下: onCreate()-->onStart()-->onResume() 现在就是用户看到的界面如果,\n\n按下back键,activity的生命周期将会结束。流程:onPause()-->onStop()-->onDestroy();\n\n 如果按下Home键,首先会保存当前activity的实例状态。OnSaveInstanceState(), 然后转入后台处理,onPause(),最后onStop();当前activity界面状态不可见。\n\n (2)如果有多个activity,并且在启动第二个activity后,调用finish()函数。当从第一个activity跳转到第二个activity的时候,当第二个\n\n activity正要显示出来的时候,第一个activity会执行onPause()方法,转入后台。同时第二个activity执行onCreate()-->onStart()-->onResume().显示出界面。\n\n第一个activity继续执行onStop()-->onDestory()方法。第一个activity生命周期结束。同样,多个activity在彼此调用后,都是这样的流程。\n\n (3)如果有多个activity,并且在启动第二个activity后,没有调用finish()函数。\n\n 流程如下: onCreate()-->onStart()-->onResume() 现在就是用户看到的界面。如果,按下back键,activity的生命周期将会结束。流程:onPause()-->onStop()-->onDestroy();\n\n 如果按下Home键,首先会保存当前activity的实例状态。OnSaveInstanceState(), 然后转入后台处理,onPause(),最后onStop()。\n\n怎样保存Activity的状态:\n\n 当一个 Activity 被 kill 之前,它可以调用 onSaveInstanceState()来保存当前 activity的状态信息。用来保存状态信息的 Bundle 会同时传给两个 method,即\n\n onRestoreInstanceState() and onCreate().\n\n public void onSaveInstanceState(Bundle outState) {\n\n outState.putBoolean(\"Boolean\", true);\n\n outState.putDouble(\"Double\", 1.9);\n\n outState.putInt(\"Int\", 1);\n\n outState.putString(\"String\", \"Welcome back to Android\");\n\n // etc.\n\n 这样,在activity转换的时候我们可以把我们要保存的数据值通过Bundle来保存到onCreate()中,等待下一次的初始化。同样在onRestoreInstanceState()中接受到要保存的信息:\n\n public void onRestoreInstanceState(Bundle savedInstanceState) {\n\n super.onRestoreInstanceState(savedInstanceState);\n\n boolean myBoolean = savedInstanceState.getBoolean(\"Boolean\");\n\n double myDouble = savedInstanceState.getDouble(\"Double\");\n\n int myInt = savedInstanceState.getInt(\"Int\");\n\n String myString = savedInstanceState.getString(\"String\");\n\n }\n\n \n\n\n\n多个 activity 之间传输数据的主要方法\n\n (1)bundle+Intent\n\n 举例如下:\n\n 我们可以在比如按钮事件中加入以下代码来实现 activity 的跳转和数据传入\n\n Intent intent = new Intent();\n\n intent.setClass(A.this,B.class);\n\n Bundle bundle = new Bundle();\n\n bundle.putDouble(\"height\",height);\n\n bundle.putString(\"sex\",sex);\n\n intent.putExtras(bundle);\n\n startActivity(intent);\n\n同时在 B 的 activity 中,我们必须要接受数据,并本地化这些数据。\n\nBundle bunde = this.getIntent().getExtras();\n\n String sex = bunde.getString(\"sex\");\n\n double height = bunde.getDouble(\"height\");\n\n 现在 activity 之间的数据传递已经完成,我们可以在 B 中使用 A 传来的这些数据。如果想从 B 中返回要得到的数据可以使用 startActivityForResult()方法。\n\n 好,我们现在来看一下是怎样传输的,其中都包含了什么?首先我们定义了 Bundle 的实例,作为存储数据的对象,利用 put 来把要传输的数据放入 bundle 这个实例中,我们来看一下效果\n\n Bundle[{sex=M, height=172.0}]\n\n 这就是在传输过程中 Bundle 实例中的内容,利用 get 方法来获取到其中的内容。\n\n 注意类型的匹配。\n\n \n\n", "link": "http://blog.csdn.net/sjz4860402/article/details/22497331", "publishDate": "2014-03-29 16:01", "title": "\r\n        Android生命周期和状态            \r\n        "}
{"readCount": "283", "article": "Service是android 系统中的四大组件之一（Activity、Service、BroadcastReceiver、ContentProvider），它跟Activity的级别差不多，但不能自己运行只能后台运行，并且可以和其他组件进行交互。\n\n1：本地服务， Local Service 用于应用程序内部。在外部可以调用Context.startService()启动，调用Context.stopService()结束。在内部可以调用Service.stopSelf() 或 Service.stopSelfResult()来自己停止。无论调用了多少次startService()，都只需调用一次stopService()来停止。\n\n2：远程服务， Remote Service 用于android系统内部的应用程序之间。可以定义接口并把接口暴露出来，以便其他应用进行操作。客户端建立到服务对象的连接，并通过那个连接来调用服务。调用Context.bindService()方法建立连接，并启动，以调用 Context.unbindService()关闭连接。多个客户端可以绑定至同一个服务。如果服务此时还没有加载，bindService()会先加载它。提供给可被其他应用复用，比如定义一个天气预报服务，提供与其他应用调用即可。\n\n那么先来看Service的生命周期吧：如图：\n\n//当绑定成功时调用，这个调用都是系统回调的。\n\n//用bindService启动的方式必须要判断当前service是否已开启，否则解除绑定会报错。\n\n//的参数service就是在这里返回的\n\n//通过此内部类返回service对象，也就是通常说的向外部提供接口。\n\n//当绑定成功时调用，这个调用都是系统回调的。\n\n\n\n 看看上面的第二个方法，因为参数中有IBinder这东西，这是一个接口，而Binder实现了这个接口，所以我们的service中必须要提供Binder的子类对象，\n\n \n\n 要不然这个回调的方法就不走了，所以我们在service中创建继承Binder的内部类，然后把这个内部类的对象返回。onBind()干的这事。\n\n//的参数service就是在这里返回的\n\n这样在上面Activity 中的onServiceConnected（）中我们就得到了service对象，在里面就可以用service中的东西了。\n\n用这个绑定service的方式，我们可以在两个应用之间互相访问，AILD进程间的通信也是基于这样的原理，只不过多了一个aidl文件和一些其他的方法而已。最后，要注意一点。\n\n以上只是个人理解，如果有偏差，欢迎指出，互相交流，我也是个新手～～～～", "link": "http://blog.csdn.net/sjz4860402/article/details/22605679", "publishDate": "2014-03-30 20:35", "title": "\r\n        Service生命周期及bindService详细说明            \r\n        "}
{"readCount": "238", "article": "安装JDK6本身并不复杂，只是目前较新版本的Ubuntu已经不支持直接通过apt-get安装了。因此，需要从Oracle官方网站下载安装包进行安装。\n\n其实，目前Oracle已经发布了JDK7。安装JDK6的原因是TI的android devkit 3.0.0在编译rootfs时，必须指定使用JDK6。木有办法，只能搞JDK6了。\n\nJDK6的bin文件中有许多可执行命令，根据需要，可以选择安装至/usr/bin目录下，比如，我安装了java/javac/javaws/jar四个命令。具体执行如下命令：", "link": "http://blog.csdn.net/sjz4860402/article/details/22609387", "publishDate": "2014-03-30 21:27", "title": "\r\n        在Ubuntu上安装JDK6            \r\n        "}
{"readCount": "229", "article": "在shell终端下进入jdk-6u14-linux-i586.bin文件所在目录，执行命令 ./jdk-6u14-linux-i586.bin 这时会出现一段协议，连继敲回车，当询问是否同意的时候，输入yes，回车。之后会在当前目录下生成一个jdk1.6.0_14目录，你可以将它复制到 任何一个目录下。1. PATH环境变量。作用是指定命令搜索路径，在shell下面执行命令时，它会到PATH变量所指定的路径中查找看是否能找到相应的命令程序。我们需要把 jdk安装目录下的bin目录增加到现有的PATH变量中，bin目录中包含经常要用到的可执行文件如javac/java/javadoc等待，设置好 PATH变量后，就可以在任何目录下执行javac/java等工具了。2. CLASSPATH环境变量。作用是指定类搜索路径，要使用已经编写好的类，前提当然是能够找到它们了，JVM就是通过CLASSPTH来寻找类的。我们 需要把jdk安装目录下的lib子目录中的dt.jar和tools.jar设置到CLASSPATH中，当然，当前目录“.”也必须加入到该变量中。3. JAVA_HOME环境变量。它指向jdk的安装目录，Eclipse/NetBeans/Tomcat等软件就是通过搜索JAVA_HOME变量来找到并使用安装好的jdk。1. 修改/etc/profile文件如果你的计算机仅仅作为开发使用时推荐使用这种方法，因为所有用户的shell都有权使用这些环境变量，可能会给系统带来安全性问题。·用文本编辑器打开/etc/profile·在profile文件末尾加入：export JAVA_HOME=/usr/share/jdk1.6.0_14export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar·重新登录·注解a. 你要将 /usr/share/jdk1.6.0_14改为你的jdk安装目录b. linux下用冒号“:”来分隔路径c. $PATH / $CLASSPATH / $JAVA_HOME 是用来引用原来的环境变量的值在设置环境变量时特别要注意不能把原来的值给覆盖掉了，这是一种常见的错误。d. CLASSPATH中当前目录“.”不能丢,把当前目录丢掉也是常见的错误。e. export是把这三个变量导出为全局变量。f. 大小写必须严格区分。这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别，如果你需要给某个用户权限使用这些环境变量，你只需要修改其个人用户主目录下的.bash_profile文件就可以了。·用文本编辑器打开用户目录下的.bash_profile文件·在.bash_profile文件末尾加入：export JAVA_HOME=/usr/share/jdk1.6.0_14export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar·重新登录3. 直接在shell下设置变量不赞成使用这种方法，因为换个shell，你的设置就无效了，因此这种方法仅仅是临时使用，以后要使用的时候又要重新设置，比较麻烦。只需在shell终端执行下列命令：export JAVA_HOME=/usr/share/jdk1.6.0_14export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar1. 用文本编辑器新建一个Test.java文件，在其中输入以下代码并保存：public class test {public static void main(String args[]) {System.out.println(\"A new jdk test !\");2. 编译：在shell终端执行命令 javac Test.java3. 运行：在shell终端执行命令 java Test当shell下出现“A new jdk test !”字样则jdk运行正常。·找到jdk安装目录的_uninst子目录·在shell终端执行命令./uninstall.sh即可卸载jdk。", "link": "http://blog.csdn.net/sjz4860402/article/details/22609491", "publishDate": "2014-03-30 21:29", "title": "\r\n        ubuntu下java环境变量配置 （window上也差不多）.            \r\n        "}
{"readCount": "179", "article": "先看Application Fundamentals上的一段话：\n\n从这句话可以知道，当某个activity变得“容易”被系统销毁时，该activity的onSaveInstanceState就会被执行，除非该activity是被用户主动销毁的，例如当用户按BACK键的时候。\n\n注意上面的双引号，何为“容易”？言下之意就是该activity还没有被销毁，而仅仅是一种可能性。这种可能性有哪些？通过重写一个activity的所有生命周期的onXXX方法，包括onSaveInstanceState和onRestoreInstanceState方法，我们可以清楚地知道当某个activity（假定为activity A）显示在当前task的最上层时，其onSaveInstanceState方法会在什么时候被执行，有这么几种情况：\n\n这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，故系统会调用onSaveInstanceState，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则\n\n在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState一定会被执行\n\n总而言之，onSaveInstanceState的调用遵循一个重要原则，即当系统“未经你许可”时销毁了你的activity，则onSaveInstanceState会被系统调用，这是系统的责任，因为它必须要提供一个机会让你保存你的数据（当然你不保存那就随便你了）。\n\n\n\n 至于onRestoreInstanceState方法，需要注意的是，onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用的，（本人注：我昨晚调试时就发现原来不一定成对被调用的！）\n\nonRestoreInstanceState被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行\n\n\n\n 另外，onRestoreInstanceState的bundle参数也会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原。\n\n至于这两个函数的使用，给出示范代码（留意自定义代码在调用super的前或后）：", "link": "http://blog.csdn.net/sjz4860402/article/details/23184221", "publishDate": "2014-04-08 14:52", "title": "\r\n        onSaveInstanceState和onRestoreInstanceState触发的时机            \r\n        "}
{"readCount": "336", "article": "getCellLocation（） 返回的单元格位置的装置 ACCESS_COARSE_LOCATION或ACCESS_FINE_LOCATIONgetDeviceId（） 返回的IMEI / MEID的设备。 如果该设备是GSM设备 然后IMEI号将被退回，如果该设备是一个CDMA设备然后MEID 将被退回 READ_PHONE_STATEgetLine1Number（） 返回设备的电话号码（MSISDN号码） READ_PHONE_STATEgetNetworkOperatorName（） 返回注册的网络运营商的名字getNetworkOperator（） 返回的MCC +跨国公司的注册网络运营商 。中国为460;电信03，移动02，联通GSM 01。所有移动卡返回是46002getNetworkCountryIso（） 返回注册的网络运营商的国家代码getSimCountryIso（） 返回SIM卡运营商的国家代码 READ_PHONE_STATEgetSimOperator（） 返回SIM卡运营商的单个核细胞数+冶 READ_PHONE_STATEgetSimOperatorName（） 返回SIM卡运营商的名字 READ_PHONE_STATEgetSimSerialNumber（） 返回SIM卡的序列号 READ_PHONE_STATEgetNetworkType（） 返回网络设备可用的类型。 这将是 下列其中一个值：TelephonyManager.NETWORK_TYPE_UNKNOWN TelephonyManager.NETWORK_TYPE_GPRS TelephonyManager.NETWORK_TYPE_EDGE TelephonyManager.NETWORK_TYPE_UMTS READ_PHONE_STATE getPhoneType（） 返回设备的类型。 这将是以下值之一： TelephonyManager.PHONE_TYPE_NONE TelephonyManager.PHONE_TYPE_GSM TelephonyManager.PHONE_TYPE_CDMA READ_PHONE_STATE getSubscriberId（） 返回用户识别码（的IMSI）的设备 READ_PHONE_STATEgetNeighboringCellInfo（） 返回NeighboringCellInfo类代表名单 相邻小区的信息，如果可用，否则将 返回null ACCESS_COARSE_UPDATES\n\ngetLine1Number（）只有部分SIM才能得到手机号码，这个是因为移动运营商没有把手机号码的数据写入到sim卡中.移动神州行,联通的卡是可以取到的.动感地带的取不到.如果我们要区分SIM卡的话，可以用SIM卡序列号区分：getSimSerialNumber（）。", "link": "http://blog.csdn.net/sjz4860402/article/details/23539503", "publishDate": "2014-04-12 16:50", "title": "\r\n        Android如何获取SIM卡信息            \r\n        "}
{"readCount": "358", "article": "颜色和不透明度 (alpha) 值以十六进制表示法表示。任何一种颜色的值范围都是 0 到 255（00 到 ff）。对于 alpha，00 表示完全透明，ff 表示完全不透明。表达式顺序是“aabbggrr”，其中“aa=alpha”（00 到 ff）；“bb=blue”（00 到 ff）；“gg=green”（00 到 ff)；“rr=red”（00 到 ff）。例如，如果您希望对某叠加层应用不透明度为 50% 的蓝色，则应指定以下值：7fff0000\n\n只要在配置文件内activity属性配置内加上\n\n \n\n android:theme=\"@android:style/Theme.Translucent\" \n\n \n\n 就好了。\n\n \n\n 这样就调用了android的透明样式！", "link": "http://blog.csdn.net/sjz4860402/article/details/23453257", "publishDate": "2014-04-11 16:35", "title": "\r\n        android设置背景色为透明,Button控件透明            \r\n        "}
{"readCount": "20005", "article": "这是系列文章中的一篇，阅读本文前请先阅读《Windows下Qt 5.2 for Android开发入门》，以便确保开发环境和作者一致。\n\n部分文章被转发/转载却没有注明出处，特此声明：版权所有 foruok ，如需转载敬请注明出处(http://blog.csdn.net/foruok)。\n\n我将从实践出发，带领大家一步一步完成在 Android 上的第一个 Qt 应用： Hello Qt on Android 。应用本身非常简单（仅仅是在屏幕上显示一个字符串 \"Hello Qt on Android\" ），这也是每种编程语言的入门教程中 Hello World 程序的共性。\n\n下面我将和大家一起来探索使用 Qt Creator 3.0 创建、管理、编译、部署 Qt on Android 应用的整个过程。每一个步骤都配以我精心挑选并编排整理的截图，力求初学者可以按图索骥、顺畅地走下去，完成自己在 Android 平台上的第一次观光旅行。\n\n\n\n打开 Qt Creator ，点击文 \"件(F)\" 菜单，在弹出的菜单列表中选择 \"新建文件或项目(N)\" 。如下图所示：\n\n\n\n如上操作后， Qt Creator 会弹出新建工程界面，让我们选择工程模板。如下面的所示：\n\n\n\n这里我们选择 \"应用程序\" 项目， \"Qt Widgets Application\" 模板。可以看到最右侧的实时提示，支持的平台中有 Android(蓝线所示)，看到这点，说明前面的开发环境搭建是正确的。\n\n    点击 \"选择(C)...\" 按钮，新建工程向导会指引我们进入下一环节 \"项目介绍和位置\" 。参考下图：\n\n\n\n我已经做了标识，编号为 1 的文本框，你可以填写项目的名字，这里是 \"HelloQtAndroid\" ；编号为 2 的 \"浏览...\" 按钮允许你选择工程的存储路径，我准备把工程放在 \"D:\\projects\\blogs\\qt\" 目录下面。请对照下图检查你的配置：\n\n\n\n点击 \"下一步\" 按钮，跟随向导进入构建套件选择(\"Kit Selection\")环节。\n\n    我选择了两个套件，\"Android for armeabi (GCC 4.7, Qt 5.2.0)\" 和 \"Desktop Qt 5.2.0 MinGW 32bit\"，分别对应下图中的标号为 1 和 2 的区域。请对照下图检查你的配置。\n\n\n\n点击 \"下一步\" 按钮，跟随向导进入 \"类信息\" 配置环节。下图是默认的界面：\n\n\n\n上图中标号为 1 的下拉框，可以选择待创建的 Widget 的基类，默认是 QMainWindow ，我这里选择 QWidget。标号为 2 的复选框，如果选中则会生成一个 .ui 文件，可以通过 Qt SDK 中的界面设计师来编辑界面，为了简单直接，我们去掉了选中，不使用 .ui 文件，全部使用代码完成界面构建。\n\n    请参考下图检查你的配置：\n\n\n\n点击 \"下一步\" 按钮，跟随向导进入 \"项目管理\" 环节。在这里你可以选择是否将工程加入版本控制系统（如 svn 之类），还可以看到即将添加到我们的 \"Hello Qt on Android\" 工程中的文件。如下图所示：\n\n\n\n终于看到 \"完成(F)\" 按钮了，赶紧点击它！看下图，我们将进入日后使用 Qt Creator 这个近乎完美的 IDE 编程时使用频度最高、相依相伴时间最久的界面。\n\n\n\n如上图所示，这就是我们日后天天要面对、不断打交道的界面。我会选择几个最常用的功能简明扼要的介绍它的用法。\n\n    左边栏，标号为 1 的标签，是 \"编辑\" 标签，选中它，会进入编辑模式，就是上面的样子。\n\n    标号为 2 的标签，是 \"项目\" 标签，选中它，会打开项目选项配置界面。该界面功能丰富到有些繁杂，后面我们会多花些时间来一一介绍我们的 \"Hello Qt on Android\" 工程必须要用的选项。\n\n    标号为 3 的是 \"构建版本\" 按钮， 点击它，会弹出一个快捷界面，允许我们快速选择不同构建版本（如 Android 的 Release 构建， Desktop 的 Debug 构建等等）。点击 \"项目\" 标签所进入的配置界面中也可以完成构建版本选择。\n\n    标号为 4 的是 \"运行\" 按钮，点击它， Qt Creator 会执行编译、链接、打包等等工作，直到目标程序运行起来或者出错停止。\n\n    \"运行\" 按钮下面依次是 \"开始调试\" 、 \"构建项目\" 按钮，鼠标悬停在它们上面就可以看到提示，其用途不言自明。\n\n    标号为 5 的那一横排标签，是 Qt Creator 的输出窗口，点击任一标签，都会向上伸展出一个窗口显示与标签名字对应的信息。\n\n    问题标签对应的窗口显示构建问题，找到问题后双击就会跳转到对应的代码行或编译输出窗口（部分链接错误）。\n\n    编译输出标签对应的窗口会把编译、链接、打包、部署过程中的信息都显示出来，这是我们从外面观察 Qt Creator 工作过程的极佳途径，善加使用必将获益良多。\n\n    应用程序输出标签对应的窗口会显示应用程序使用标准输出打印的信息，APK 运行后， logcat 的日志也会显示在这里。\n\n    其它标签不再细说，开发过程中使用几次就熟悉了。\n\n    标号为 6 的区域，就是代码编辑区。\n\n    标号为 7 的区域，是侧边栏、项目管理区域，这里允许开发者以项目、类视图、大纲、文件系统、类型层次、打开文档等等方式来管理项目。\n\n\n\n介绍完了我们的好伙伴——项目管理与代码编辑界面，接下来我们继续完成 \"Hello Qt on Android\" 的项目配置。点击前面介绍的标号为 2 的项目标签，会看到下面的项目选项配置界面：\n\n\n\n我们的新建工程，默认选中了 \"Desktop Qt 5.2.0 MinGW 32bit\" 这个套件。请注意上图左下蓝线标出的按钮，前面提到，它是构建版本选择按钮，现在显示的是电脑图标配Debug字样。\n\n点击标号为 1 的区域中的构建按钮（蓝色圆圈所在），切换到 \"Android for armeabi\" 套件，进行构建相关的配置。如下图：\n\n\n\n构建配置选项繁多，对于我们的第一个应用，只要关注途中标识出的 1 和 2 两个功能怎么使用即可。\n\n    标号为 1 的按钮，点击可以切换到\"运行\"选项配置，马上就能看到。\n\n    标号为 2 的组合框，可以选择构建版本（一般是 Debug / Release 两个）。它完成和左边栏下蓝色圆圈标识的构建版本按钮一样的功能。我们这里选择 \"Release\" 构建。\n\n    注意蓝色圆圈标识区域，随着我们选中 \"Android for armeabi\" 套件和 \"Release\" 构建，它从电脑图标变成了安卓小机器人配 \"Release\" 字样的按钮。\n\n好啦，现在让我们点击标号为 1 的\"运行\"按钮，进行运行选项配置。对目前这个项目来说，运行配置远比构建配置复杂，请擦亮眼睛，用心体会。\n\n\n\n希望你没被吓到，我在上图中作了 9 处标识，比之前的编辑界面（ 7 个标识）还多。让我们化繁为简，一个一个来看。\n\n    标号为 1 的下拉框，可以选择应用针对的目标 SDK 版本，这里默认是 android-17。我得说（ 先请大神 BogDan Vatra 见谅 ） Qt Creator 的这种显示不够完美，如果鼠标悬停在下拉框上时悬浮窗提示一下会更好。\n\n    我这里简要说明一下 Qt Creator 中的这个配置选项。实际上它对应 Android APK 的主配置文件 AndroidManifest.xml 中的  android:targetSdkVersion 配置项。这个配置项允许你指定你的应用针对的Android API Level ，而吊诡的是，它使用 sdkVersion 来作为标签，容易引起混淆。实际上，现在我们可以简单地把 sdkVersion 和 API Level 理解为同一个东西，细微差别以后再说。\n\n    为了让大家对 Android API Level 有个概念，我截取了 Google Android 在线手册（请访问页面\" http://developer.android.com/guide/topics/manifest/uses-sdk-element.html\" ）中的一幅图放在下面：\n\n\n\n标号为 2 的\"对包签名\"复选框，选中时 Qt Creator 会自动对 APK 进行签名。而一旦你选中了它，就需要提供一个密钥文件( keystore )供 Qt Creator 使用。 如果没有，则点击标号为 3 的 \"Create\" 按钮， Qt Creator 会帮你创建一个；如果有，可以点击 \"Browse\" 选择。\n\n    标号为 4 的单选框，是 Qt 库布署策略中的一个，用 Ministro 服务安装 Qt 。我们推荐使用这个，具体原因会在\" Qt 库的部署策略\"一节详细介绍。另外一个可用的策略是把 Qt 库打包到你的 APK 中。\n\n    标号为 5 的复选框，选中时 Qt Creator 会在打包完成后打开包所在的目录，方便开发者访问生成的 APK 。\n\n    标号为 6 的浮现选，对应日志输出选项。\n\n    标号为 7 的按钮， \"Create AndroidManifest.xml\" ，如按钮名所示，帮助你创建并配置 APK 的主配置文件 AndroidManifest.xml 。如果你不点这个按钮呢， Qt Creator 会使用默认的选项帮你创建一个默认的配置文件。建议创建并配置它，否则你的 APK 包名什么的都会让你觉得怪怪的有点不舒服。\n\n    标号为 8 的按钮，\"Install Ministro from APK\"，则是 Qt Creator 提供给我们的一个贴心服务，允许我们把下载到本地的 Ministro APK 安装到 Android 设备上。顺便说下，我在完成 \"Hello Qt on Android\" 项目时就遇到了无法安装 Ministro 服务的问题，我的 XT882 电信定制版手机，根本访问不到 Google Play。 \n\n    标号为 9 的区域有两个按钮，允许我们添加依赖库。现在的工程用不到，以后再说。\n\n    啊，天，终于说完了，你睡着了嘛，醒醒，我们继续往下看。\n\n\n\n让我们回到签名选项（别忘了，标号 2 ），选中它，然后点击标号为 3 的 \"Create\" 按钮，创建密钥文件和证书。你会看到下面的界面（空空如也，没错，是初始界面嘛）：\n\n\n\n如上图所示，有很多选项，照着填写就行，错了会有提示。我配置好后截了图，在下面，请参照着检查你的配置：\n\n\n\n点击\"保存\"按钮，会弹出文件选择对话框，让你选择密钥文件的保存位置，你也可以修改它的名字。下面是我的配置截图，供参考：\n\n\n\n点击——，哦，等下，先记住你刚才起的文件名和保存的位置（在市场中更新 APK 必须要使用和之前发布版本相同的签名），后面还要用到，然后再点击\"保存\"按钮，我们会回到运行配置界面。如下图所示：\n\n\n\n可以对照初始的运行配置截图，我把修改过的选项用蓝色横线标注出来了。\n\n\n\n接下来是我们的另一个重头戏，创建 AndroidManifest.xml 文件。\n\n   好啦，下面是创建向导，允许你选择保存位置，先别动它，使用默认值（工程目录下的 android 子文件夹，回头你可以到这个位置观光一下，AndroidManifest.xml 还有你应用的图标都放在这里）就行。\n\n\n\n直接点击\"完成(F)\"按钮，你会看到 Qt Creator 提供的供你编辑 AndroidManifest.xml 文件的图形化界面（当然你也可以在 Qt Creator 中查看 XML 并手动修改它）。看图：\n\n\n\n这是个中等复杂度的界面，我做了 6 处标识，下面一一说明。\n\n    标号为 1 的编辑框，填写你的包名。如你所见，默认值是 org.qtproject.example ，看起来不那么正式。\n\n    标号为 2 的微调按钮，允许你更改应用的版本号。\n\n    标号为 3 的区域，调整最低 API Level 和 目标 API Level。\n\n    标号为 4 的区域，让你设定你的 APK 图标，有高、中、低三个尺寸（一般对应 72x72 、 48x48 、 32x32）。\n\n    标号为 5 的下拉组合框，列出了所有支持的权限，你可以考虑你的 APK 需要什么权限，选中它，点击标号为 6 的 \"Add\" 按钮就可以在 AndroidManifest.xml 中添加一个权限。当然你也可以点击 \"Remove\" 按钮来取笑一个不必要的权限。\n\n    关于 APK 的权限，这里不细说，会在\"AndroidManifest.xml 介绍\"一节中详细说明。对 HelloQtOnAndroid ，我保持 Qt Creator 设置的默认权限。\n\n    下面是我的配置截图，改动的部分用蓝线标注出来了，请参照检查你的配置：\n\n\n\nQt Creator 提供的图形化 Android Manifest 编辑界面，只支持了主要几个选项，如果你想细细调整体验掌控全局的感觉，请点击上图蓝色方框处的\"XML Source\"按钮，手动编辑 xml 文件。如下图所示：\n\n\n\n和编辑 C++ 代码一样，可以在标号为 1 的编辑区来编辑 XML 文件。\n\n    谢天谢地，一百里路我们走了九十里啦，接下来就会惊吓、惊喜不断。\n\n\n\n虽然你已经准备好迎接惊喜，我们还是得按捺一下心情，把代码稍稍修改几行。回到编辑界面，确保你左侧项目管理窗口选中\"项目\"方式，展开源文件夹，双击其下的 widget.cpp ，在右侧编辑区添加一行代码：\n\n\n\n好啦好啦，九十九里路啦，咫尺之遥，请点击左边栏的\"运行\"按钮（你是否还记得）， Qt Creator 会让你选择目标设备（如果环境配置正确，连接了手机或者创建了AVD），建议直接真机运行（你没有 Android 手机吗？），如下图所示：\n\n\n\n看见了吗？选中我的老古董手机，摩托罗拉 XT882 ，Android 版本是 2.3.6 ，点击\"确定\"按钮，活动一下，静待奇迹出现。\n\n    哦，吓我一跳，我看见了这个界面：\n\n\n\n忘了吗，我们前面在运行配置中勾选了\"Open package location after build\"选项。如果你要在市场中发布你的应用，请注意选择（图中蓝框所示）签过名的版本。\n\n    等一下，现在该看手机了。我看到了这个界面：\n\n\n\n你是否还记得，我们选择的 Qt 库布署策略——\"使用Ministro 服务安装 Qt 库\"？\n\n    现在要操作手机，摸下\"确定\"按钮，会尝试安装 Ministro 服务。惊吓来了，我看到手机屏幕上华丽丽地闪过一个 Toast 提示“安装 Ministro 失败”，然后就是下面的图：\n\n\n\n看样子它是到我手机上默认的安智市场中去找 Ministro 了，没找到。按返回键吧，哦，天，停在了黑屏界面，没有任何反应……好吧，请猛击手机的返回键或者小房子(主页)键。哦，桌面出来了，谢谢。至于为什么 Ministro 安装失败会出现黑屏，请阅读后续章节。\n\n    现在我们需要回头来调整运行配置，换一个 Qt 库布署策略——\"在 APK 中捆绑 Qt 库\"。\n\n    再次运行，再次看到 \"package location\" 文件夹界面……，好吧，看手机，惊喜终于来了：\n\n\n\n现在，终于可以停下来喘口气了，我们的第一个 Qt on Android 的应用 \"HelloQtOnAndroid\"终于在真机上跑起来了。\n\n    如果你是第一次使用 Qt on Android，跟随我的指南走下来，是什么感觉？反正我第一次把 \"Hello Qt On Android \" 跑通时，还是非常振奋的，激动了大半天。毕竟， Qt 作为在移动互联网时代，是唯一可以与 Android 、 iOS 并提的跨平台应用开发框架……；毕竟，作为 C/C++ 程序猿，我们可以为 Windows 桌面、 Linux 桌面 、 Android 手机/平板、iOS、MAC OS X 、 Tizen 、 Meego 、 Windows Mobile 、 Embedded Linux 、 Symbian等等平台开发软件而不需要切换开发框架和工具，是多么令人舒心、自豪的事儿；毕竟……\n\n　　　\n\n    好了，第一次 Qt on Android 应用的旅程到此为此。敬请期待后续文章。\n\n我翻译的大神 BogDan Vatra 的 Qt on Android 系列文章：\n\n我的关于 Qt on Android 的系列文章：", "link": "http://blog.csdn.net/foruok/article/details/23528293", "publishDate": "2014-04-12 14:57", "title": "\r\n        Qt on Android：图文详解Hello World全过程            \r\n        "}
{"readCount": "237", "article": "ViewPager在设计的时候有一个预加载的机制，也就是如果你处于当前这个page界面时,会预先加载下一个page。但是有的时候设计到网络请求，就需要取消掉这个预加载。 \n\n setOffscreenPageLimit()这一个方法是设置预加载的个数，默认为1，但是当你设置为0的时候也会强行将它设置为1。\n\n所以说，第一种取消预加载的方法就出来了，那就是需要更改这个DEFAULT_OFFSCREEN_PAGES = 0,但是需要更改jar包，特别麻烦，所以接下来就用一下第二种方法\n\n从官方的API文档来看，Fragment中有一个方法，这个方法是执行在onCreateView()方法之前的，叫做setUserVisibleHint()。用来告诉系统这个UI是否可见。\n\n所以第二种方法就是重写这个setUserVisibleHint \n\n 首先，创建一个父类，以后的Fragment都继承自MyFragment,在其中定义一个抽象方法，在子类中实现延迟加载的逻辑。\n\n下面的就是在子类中如何实现延迟加载，同时还引入了布局的复用，因为每次切换都会产生View的重绘，浪费资源", "link": "http://blog.csdn.net/jonstank2013/article/details/50225429", "publishDate": "2015-12-08 22:26", "title": "\r\n        ViewPager 取消预加载            \r\n        "}
{"readCount": "1525", "article": "最近在群里发现总有人问一些关于Android Studio的问题，Android Studio是Google新出的一款IDE工具，它是基于Intellij IDEA开发的，AS开发Android很方便，那么今天就说一下怎么将Github的项目导入Android Studio中而不报错，完美运行。Github上的项目大部分是基于Gradle编译的，而gradle在线下载是下不了的，除非你翻墙，买了自己的vpn，就不需要以下的操作了，可以直接忽略过，直接导入github项目，然后Fix Project坐等就ok。如果你没有vpn，没有翻墙，那么下面请看好我是怎么导入一个github项目的。\n\n首先我在github上下载一个项目，就以RippleEffect\n\n为例吧，首先我先下载这个压缩包，或者你也可以直接在AS中checkout该项目。\n\n我们可以看到github上下载的项目中是有library的，我们自己新建的是没有，这个library是和eclipse中的library一样的，依赖库。\n\nbuild:gradle:1.3.0而我们下载的项目的版本是1.2.3\n\n把下载的github的项目中的build.gradle改成我们的版本\n\n项目的gradle版本是2.2.1，而我们的本地gradle版本是2.4，改成我们本地的\n\n本地的sdk编译版本是23，buildtools版本是23.0.1\n\n注释掉，compilesdkversion,buildtoolsversion也改成我们本地用的，当然在AS中改也是可以的\n\n完美运行，是不是很简单？因为AS刚出来没多久，现在大部分人还都再用eclipse，而google到年底就不再支持eclipse的adt了，也有好多小伙伴正在转AS，但是AS上的gradle编译有很多错误，但是没关系，一个一个问题解决就ok了，其实也没多难，要是大家还遇到别的错误的时候可以给我留言，我每天都会看的，会主动帮助大家解决问题的。", "link": "http://blog.csdn.net/lyhhj/article/details/48789705", "publishDate": "2015-09-28 21:03", "title": "\r\n        Android Studio导入github项目详解            \r\n        "}
{"readCount": "6641", "article": "相对于Win32来说, NaCl相当于另一个平台, 一些操作系统相关的API需要移植. 除此之外, 参考 Technical Overview , 还有一些其它的限制:\n\n这些限制都是为了保证安全性(想想ActiveX为什么失败了)和跨平台(Win/Linux/OSX使用同一个版本)\n\n可以说, 有了PPAPI插件的帮助, 整个移植过程相当的平滑, 可以一步一步进行, 比起什么android/linux/osx平台的移植工作方便太多了.\n\n接下来就是考虑3D游戏相关的移植工作了, 上面提到的很多技术限制也会引起一些传统结构的调整", "link": "http://blog.csdn.net/xoyojank/article/details/8147011", "publishDate": "2012-11-05 00:12", "title": "\r\n        从Native到Web(二), NaCl学习笔记: 技术限制&Win32移植过程            \r\n        "}
{"readCount": "531", "article": "", "link": "http://blog.csdn.net/fanyun_01/article/details/50600507", "publishDate": "2016-01-28 14:36", "title": "\r\n        大数据            \r\n        "}
{"readCount": "30", "article": "RemoteViews从字面上看是一种远程视图。RemoteViews具有View的结构，既然是远程View，那么它就可以在其他进程中显示。由于它可以跨进程显示，所以为了能够更新他的界面，RemoteViews提供一组基础的操作用于跨进程更新它的UI。RemoteViews在Android日常开发中最常见的使用场景有两种：通知栏的通知和桌面小部件。通知栏通知大家应该都不陌生，因为这还经常用到的，notification主要是通过NotificationManager的notify方法来实现，它除了默认的效果外，开发人员还可以根据自己的需求自定义UI布局。桌面小部件是通过AppWidgetProvider来实现的，其实AppWidgetProvider是一个广播。通知栏通知和小部件的开发过程中经常会用到RemoteViews。它们在更新UI的时候无法像Activity和Fragment那样直接更新，前面讲过，因为它是跨进程的view，更确切一点来说的话，它是运行在SystemServer进程中。为了能够跨进程更新界面，RemoteViews提供了一些列可以跨进程更新UI的方法，内部有一些列的set方法，这些方法都是View的子集。\n\n①首先看一下原生的的notification", "link": "http://blog.csdn.net/loveyaozu/article/details/51178707", "publishDate": "2016-04-18 12:47", "title": "\r\n        Android之利用RemoteViews自定义Notification            \r\n        "}
{"readCount": "13080", "article": "你是不是还有很多类似的疑问一直没有解决？没关系，这篇文章将结合源码以及大量的优秀文章，站在巨人的肩膀上，更加通俗的来试着解释一些问题。但是毕竟源码繁多、经验有限，文中不免会出现一些纰漏甚至是错误，还恳请大家指出，互相学习。\n\n这篇文章我决定采用一问一答的方式进行。\n\n其实在这之前，我试过把每个流程的代码调用过程，用粘贴源代码的方式写在文章里，但是写完一部分之后，发现由于代码量太大，整篇文章和老太太的裹脚布一样——又臭又长，虽然每个重要的操作可以显示出详细调用过程，但是太关注于细节反而导致从整体上不能很好的把握。所以在原来的基础之上进行了修改，对关键的几个步骤进行重点介绍，力求语言简洁，重点突出，从而让大家在更高的层次上对framework层有个认识，然后结合后面我给出的参考资料，大家就可以更加快速，更加高效的了解这一块的整体架构。\n\n我们下面的文章将围绕着这几个类进行介绍。可能你第一次看的时候，印象不深，不过没关系，当你跟随者我读完这篇文章的时候，我会在最后再次列出这些对象的功能，相信那时候你会对这些类更加的熟悉和深刻。\n\n首先，你觉得这个单词眼熟不？当你的程序Crash的时候，打印的红色log下面通常带有这一个单词。\n\nzygote意为“受精卵“。Android是基于Linux系统的，而在Linux中，所有的进程都是由init进程直接或者是间接fork出来的，zygote进程也不例外。\n\n在Android系统里面，zygote是一个进程的名字。Android是基于Linux System的，当你的手机开机的时候，Linux的内核加载完成之后就会启动一个叫“init“的进程。在Linux System里面，所有的进程都是由init进程fork出来的，我们的zygote进程也不例外。\n\n所以当系统里面的第一个zygote进程运行之后，在这之后再开启App，就相当于开启一个新的进程。而为了实现资源共用和更快的启动速度，Android系统开启新进程的方式，是通过fork第一个zygote进程实现的。所以说，除了第一个zygote进程，其他应用所在的进程都是zygote的子进程，这下你明白为什么这个进程叫“受精卵”了吧？因为就像是一个受精卵一样，它能快速的分裂，并且产生遗传物质一样的细胞！\n\n首先我要告诉你的是，SystemServer也是一个进程，而且是由zygote进程fork出来的。\n\n知道了SystemServer的本质，我们对它就不算太陌生了，这个进程是Android Framework里面两大非常重要的进程之一——另外一个进程就是上面的zygote进程。\n\n为什么说SystemServer非常重要呢？因为系统里面重要的服务都是在这个进程里面开启的，比如 \n\n ActivityManagerService、PackageManagerService、WindowManagerService等等，看着是不是都挺眼熟的？\n\nActivityManagerService进行初始化的时机很明确，就是在SystemServer进程开启的时候，就会初始化ActivityManagerService。从下面的代码中可以看到\n\n经过上面这些步骤，我们的ActivityManagerService对象已经创建好了，并且完成了成员变量初始化。而且在这之前，调用createSystemContext()创建系统上下文的时候，也已经完成了mSystemContext和ActivityThread的创建。注意，这是系统进程开启时的流程，在这之后，会开启系统的Launcher程序，完成系统界面的加载与显示。\n\n你是否会好奇，我为什么说AMS是服务端对象？下面我给你介绍下Android系统里面的服务器和客户端的概念。\n\n其实服务器客户端的概念不仅仅存在于Web开发中，在Android的框架设计中，使用的也是这一种模式。服务器端指的就是所有App共用的系统服务，比如我们这里提到的ActivityManagerService，和前面提到的PackageManagerService、WindowManagerService等等，这些基础的系统服务是被所有的App公用的，当某个App想实现某个操作的时候，要告诉这些系统服务，比如你想打开一个App，那么我们知道了包名和MainActivity类名之后就可以打开\n\n但是，我们的App通过调用startActivity()并不能直接打开另外一个App，这个方法会通过一系列的调用，最后还是告诉AMS说：“我要打开这个App，我知道他的住址和名字，你帮我打开吧！”所以是AMS来通知zygote进程来fork一个新进程，来开启我们的目标App的。这就像是浏览器想要打开一个超链接一样，浏览器把网页地址发送给服务器，然后还是服务器把需要的资源文件发送给客户端的。\n\n知道了Android Framework的客户端服务器架构之后，我们还需要了解一件事情，那就是我们的App和AMS(SystemServer进程)还有zygote进程分属于三个独立的进程，他们之间如何通信呢？\n\n那么AMS有什么用呢？在前面我们知道了，如果想打开一个App的话，需要AMS去通知zygote进程，除此之外，其实所有的Activity的开启、暂停、关闭都需要AMS来控制，所以我们说，AMS负责系统中所有Activity的生命周期。\n\n在Android系统中，任何一个Activity的启动都是由AMS和应用程序进程（主要是ActivityThread）相互配合来完成的。AMS服务统一调度系统中所有进程的Activity启动，而每个Activity的启动过程则由其所属的进程具体来完成。\n\n这样说你可能还是觉得比较抽象，没关系，下面有一部分是专门来介绍AMS与ActivityThread如何一起合作控制Activity的生命周期的。\n\n当我们点击手机桌面上的图标的时候，App就由Launcher开始启动了。但是，你有没有思考过Launcher到底是一个什么东西？\n\nLauncher本质上也是一个应用程序，和我们的App一样，也是继承自Activity\n\nLauncher实现了点击、长按等回调接口，来接收用户的输入。既然是普通的App，那么我们的开发经验在这里就仍然适用，比如，我们点击图标的时候，是怎么开启的应用呢？如果让你，你怎么做这个功能呢？捕捉图标点击事件，然后startActivity()发送对应的Intent请求呗！是的，Launcher也是这么做的，就是这么easy！\n\n那么到底是处理的哪个对象的点击事件呢？既然Launcher是App，并且有界面，那么肯定有布局文件呀，是的，我找到了布局文件launcher.xml\n\n为了方便查看，我删除了很多代码，从上面这些我们应该可以看出一些东西来：Launcher大量使用标签来实现界面的复用，而且定义了很多的自定义控件实现界面效果，dock_divider从布局的参数声明上可以猜出，是底部操作栏和上面图标布局的分割线，而paged_view_indicator则是页面指示器，和App首次进入的引导页下面的界面引导是一样的道理。当然，我们最关心的是Workspace这个布局，因为注释里面说在这里面包含了5个屏幕的单元格，想必你也猜到了，这个就是在首页存放我们图标的那五个界面(不同的ROM会做不同的DIY，数量不固定)。\n\n里面就一个CellLayout，也是一个自定义布局，那么我们就可以猜到了，既然可以存放图标，那么这个自定义的布局很有可能是继承自ViewGroup或者是其子类，实际上，CellLayout确实是继承自ViewGroup。在CellLayout里面，只放了一个子View，那就是ShortcutAndWidgetContainer。从名字也可以看出来，ShortcutAndWidgetContainer这个类就是用来存放快捷图标和Widget小部件的，那么里面放的是什么对象呢？\n\n在桌面上的图标，使用的是BubbleTextView对象，这个对象在TextView的基础之上，添加了一些特效，比如你长按移动图标的时候，图标位置会出现一个背景(不同版本的效果不同)，所以我们找到BubbleTextView对象的点击事件，就可以找到Launcher如何开启一个App了。\n\n除了在桌面上有图标之外，在程序列表中点击图标，也可以开启对应的程序。这里的图标使用的不是BubbleTextView对象，而是PagedViewIcon对象，我们如果找到它的点击事件，就也可以找到Launcher如何开启一个App。\n\n其实说这么多，和今天的主题隔着十万八千里，上面这些东西，你有兴趣就看，没兴趣就直接跳过，不知道不影响这篇文章阅读。\n\nBubbleTextView的点击事件在哪里呢？我来告诉你：在Launcher.onClick(View v)里面。\n\n从上面的代码我们可以看到，在桌面上点击快捷图标的时候，会调用\n\n那么从程序列表界面，点击图标的时候会发生什么呢？实际上，程序列表界面使用的是AppsCustomizePagedView对象，所以我在这个类里面找到了onClick(View v)。\n\n和上面一样！这叫什么？这叫殊途同归！\n\n所以咱们现在又明白了一件事情：不管从哪里点击图标，调用的都是Launcher.startActivitySafely()。\n\n这里会调用Activity.startActivity(intent, opts.toBundle())，这个方法熟悉吗？这就是我们经常用到的Activity.startActivity(Intent)的重载函数。而且由于设置了\n\n所以我们现在明确了，Launcher中开启一个App，其实和我们在Activity中直接startActivity()基本一样，都是调用了Activity.startActivityForResult()。\n\n还记得前面说过的Instrumentation对象吗？每个Activity都持有Instrumentation对象的一个引用，但是整个进程只会存在一个Instrumentation对象。当startActivityForResult()调用之后，实际上还是调用了mInstrumentation.execStartActivity()\n\n所以当我们在程序中调用startActivity()的 时候，实际上调用的是Instrumentation的相关的方法。\n\n我们可以看到，这个类里面的方法大多数和Application和Activity有关，是的，这个类就是完成对Application和Activity初始化和生命周期的工具类。比如说，我单独挑一个callActivityOnCreate()让你看看\n\n对activity.performCreate(icicle);这一行代码熟悉吗？这一行里面就调用了传说中的Activity的入口函数onCreate()，不信？接着往下看\n\n没骗你吧，onCreate在这里调用了吧。但是有一件事情必须说清楚，那就是这个Instrumentation类这么重要，为啥我在开发的过程中，没有发现他的踪迹呢？\n\n是的，Instrumentation这个类很重要，对Activity生命周期方法的调用根本就离不开他，他可以说是一个大管家，但是，这个大管家比较害羞，是一个女的，管内不管外，是老板娘~\n\n那么你可能要问了，老板是谁呀？ \n\n 老板当然是大名鼎鼎的ActivityThread了！\n\nActivityThread你都没听说过？那你肯定听说过传说中的UI线程吧？是的，这就是UI线程。我们前面说过，App和AMS是通过Binder传递信息的，那么ActivityThread就是专门与AMS的外交工作的。\n\nAMS说：“ActivityThread，你给我暂停一个Activity！” \n\n ActivityThread就说：“没问题！”然后转身和Instrumentation说：“老婆，AMS让暂停一个Activity，我这里忙着呢，你快去帮我把这事办了把~” \n\n 于是，Instrumentation就去把事儿搞定了。\n\n所以说，AMS是董事会，负责指挥和调度的，ActivityThread是老板，虽然说家里的事自己说了算，但是需要听从AMS的指挥，而Instrumentation则是老板娘，负责家里的大事小事，但是一般不抛头露面，听一家之主ActivityThread的安排。\n\n前面我们说到，在调用startActivity()的时候，实际上调用的是\n\n但是到这里还没完呢！里面又调用了下面的方法\n\n这里的ActivityManagerNative.getDefault返回的就是ActivityManagerService的远程接口，即ActivityManagerProxy。\n\n再看ActivityManagerProxy.startActivity()，在这里面做的事情就是IPC通信，利用Binder对象，调用transact()，把所有需要的参数封装成Parcel对象，向AMS发送数据进行通信。\n\nBinder本质上只是一种底层通信方式，和具体服务没有关系。为了提供具体服务，Server必须提供一套接口函数以便Client通过远程访问使用各种服务。这时通常采用Proxy设计模式：将接口函数定义在一个抽象类中，Server和Client都会以该抽象类为基类实现所有接口函数，所不同的是Server端是真正的功能实现，而Client端是对这些函数远程调用请求的包装。\n\n为了更方便的说明客户端和服务器之间的Binder通信，下面以ActivityManagerServices和他在客户端的代理类ActivityManagerProxy为例。\n\n虽然都实现了同一个接口，但是代理对象ActivityManagerProxy并不会对这些方法进行真正地实现，ActivityManagerProxy只是通过这种方式对方法的参数进行打包(因为都实现了相同接口，所以可以保证同一个方法有相同的参数，即对要传输给服务器的数据进行打包)，真正实现的是ActivityManagerService。\n\n但是这个地方并不是直接由客户端传递给服务器，而是通过Binder驱动进行中转。其实我对Binder驱动并不熟悉，我们就把他当做一个中转站就OK，客户端调用ActivityManagerProxy接口里面的方法，把数据传送给Binder驱动，然后Binder驱动就会把这些东西转发给服务器的ActivityManagerServices，由ActivityManagerServices去真正的实施具体的操作。\n\n但是Binder只能传递数据，并不知道是要调用ActivityManagerServices的哪个方法，所以在数据中会添加方法的唯一标识码，比如前面的startActivity()方法：\n\n上面的START_ACTIVITY_TRANSACTION就是方法标示，data是要传输给Binder驱动的数据，reply则接受操作的返回值。\n\n而且由于继承了同样的公共接口类，ActivityManagerProxy提供了与ActivityManagerService一样的函数原型，使用户感觉不出Server是运行在本地还是远端，从而可以更加方便的调用这些重要的系统服务。\n\n但是！这里Binder通信是单方向的，即从ActivityManagerProxy指向ActivityManagerService的，如果AMS想要通知ActivityThread做一些事情，应该咋办呢？\n\n还是通过Binder通信，不过是换了另外一对，换成了ApplicationThread和ApplicationThreadProxy。\n\n他们也都实现了相同的接口IApplicationThread\n\n剩下的就不必多说了吧，和前面一样。\n\nOK，至此，点击桌面图标调用startActivity()，终于把数据和要开启Activity的请求发送到了AMS了。说了这么多，其实这些都在一瞬间完成了，下面咱们研究下AMS到底做了什么。\n\n注：前方有高能的方法调用链，如果你现在累了，请先喝杯咖啡或者是上趟厕所休息下\n\n在这里又出现了一个新对象ActivityStackSupervisor，通过这个类可以实现对ActivityStack的部分操作。\n\n调用startActivityUncheckedLocked(),此时要启动的Activity已经通过检验，被认为是一个正当的启动请求。\n\n终于，在这里调用到了ActivityStack的startActivityLocked(ActivityRecord r, boolean newTask,boolean doResume, boolean keepCurTransition, Bundle options)。\n\nActivityRecord代表的就是要开启的Activity对象，里面分装了很多信息，比如所在的ActivityTask等，如果这是首次打开应用，那么这个Activity会被放到ActivityTask的栈顶，\n\n靠！这来回折腾什么呢！从ActivityStackSupervisor到ActivityStack，又调回ActivityStackSupervisor，这到底是在折腾什么玩意啊！！！\n\n淡定…淡定…我知道你也在心里骂娘，世界如此美妙，你却如此暴躁，这样不好，不好…\n\n我…已无力吐槽了，又调回ActivityStack去了…\n\n在这个方法里，prev.app为记录启动Lancher进程的ProcessRecord，prev.app.thread为Lancher进程的远程调用接口IApplicationThead，所以可以调用prev.app.thread.schedulePauseActivity，到Lancher进程暂停指定Activity。\n\n在Lancher进程中消息传递，调用ActivityThread.handlePauseActivity()，最终调用ActivityThread.performPauseActivity()暂停指定Activity。接着通过前面所说的Binder通信，通知AMS已经完成暂停的操作。\n\n上面这些调用过程非常复杂，源码中各种条件判断让人眼花缭乱，所以说如果你没记住也没关系，你只要记住这个流程，理解了Android在控制Activity生命周期时是如何操作，以及是通过哪几个关键的类进行操作的就可以了，以后遇到相关的问题之道从哪块下手即可，这些过程我虽然也是撸了一遍，但还是记不清。\n\n这是因为startActivity()是这样实现的\n\n你不可能从onActivityResult()里面收到任何回调。而这个问题是相当难以被发现的，就是因为这个坑，我工作一年多来第一次加班到9点 (ˇˍˇ）\n\n是在ActivityThread初始化的时候，就已经创建消息循环了，所以在主线程里面创建Handler不需要指定Looper，而如果在其他线程使用Handler，则需要单独使用Looper.prepare()和Looper.loop()创建消息循环。\n\n也是在ActivityThread.main()的时候，再具体点呢，就是在thread.attach(false)的时候。\n\n看你的表情，不信是吧！凯子哥带你溜溜~\n\nthread是IApplicationThread，实际上就是ApplicationThread在服务端的代理类ApplicationThreadProxy，然后又通过IPC就会调用到ApplicationThread的对应方法\n\n我们需要关注的其实就是最后的sendMessage()，里面有函数的编号H.BIND_APPLICATION，然后这个Messge会被H这个Handler处理\n\n最后就在下面这个方法中，完成了实例化，拨那个企鹅通过mInstrumentation.callApplicationOnCreate实现了onCreate()的调用。\n\n而且通过反射拿到Application对象之后，直接调用attach()，所以attach()调用是在onCreate()之前的。\n\n下面的这些文章都是这方面比较精品的，希望你抽出时间研究，这可能需要花费很长时间，但是如果你想进阶为中高级开发者，这一步是必须的。\n\nOK，到这里，这篇文章算是告一段落了，我们再回头看看一开始的几个问题，你还困惑吗？\n\n再回过头来看看这些类，你还迷惑吗？\n\n如果你还感到迷惑的话，就把这篇文章多读几遍吧，信息量可能比较多，需要慢慢消化~", "link": "http://blog.csdn.net/zhaokaiqiang1992/article/details/49428287", "publishDate": "2015-10-27 10:14", "title": "\r\n        【凯子哥带你学Framework】Activity启动过程全解析            \r\n        "}
{"readCount": "253", "article": "Android中的组件需要用一个int类型的值来表示，这个值也就是组件标签中的id属性值。id属性只能接受资源类型的值，也就是必须以@开头的值，例如，@id/abc、@+id/xyz等。\n\n 如果在@后面使用“+”，表示当修改完某个布局文件并保存后，系统会自动在R.java文件中生成相应的int类型变量。变量名就是“/”后面的值，例如，@+id/xyz会在R.java文件中生成int xyz = value，其中value是一个十六进制的数。如果xyz在R.java中已经存在同名的变量，就不再生成新的变量，而该组件会使用这个已存在的变量的值。\n\n 也就是说，如果使用@+id/name形式，当R.java中存在名为name变量时，则该组件会使用该变量的值作为标识。如果不存在该变量，则添加一个新的变量，并为该变量赋相应的值（不会重复）。\n\n     既然组件的id属性是一个资源id就可以，那么自然可以设置任何已经存在的资源id值，例如，@drawable/icon、@string/ok、@+string/you等。当然，也可以设置android系统中已存在的资源id，例如，楼主提出的@id/android:list，那么这个android是什么意思呢，实际上，这个android就是系统的R类（在R.java文件中）所在的package。我们可以在Java代码编辑区输入android.R.id.，就会列出相应的资源id，例如，也可以设置id属性值为@id/android:message。\n\n <ListView android:id=\"@+id/android:message\"\n\n    android:layout_width=\"wrap_content\"\n\n       android:layout_height=\"wrap_content\"/>\n\n 还有另外一种方法查看系统中定义的id，进入<android sdk安装目录>\\platforms\\android-1.5\\data\\res\\values目录，找到ids.xml文件，打开后，内容如下：\n\n <?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n <resources>\n\n <item type=\"id\" name=\"price_edit\">false</item>\n\n <item type=\"id\" name=\"amount_edit\">false</item>\n\n </resources>\n\n \n\n 若在ids.xml中定义了ID，则在layout中可如下定义@id/price_edit，否则@+id/price_edit", "link": "http://blog.csdn.net/sjz4860402/article/details/20900159", "publishDate": "2014-03-10 09:25", "title": "\r\n        @+id/和android:id和＠id/的区别？            \r\n        "}
{"readCount": "16567", "article": "好久没有写博客了，瞬间感觉好多学了的东西不进行一个自我的总结与消化总归变不成自己的。通过博客可能还可以找到一些当初在学习的时候没有想到的问题。想了半天，从大二上学期自学Android以来还没有对Android从启动到程序运行期间进行一个完整的归纳，刚好最近又学到了一些新东西，那就以这篇博客为媒介，总结一下从Android启动到程序运行期间发生的所有事吧。包括什么ClassLoader, JVM,IPC, 消息处理机制要是总结到了就顺带BB一下。但是这里就不包含很多细节了，比如为什么PMS内部为什么要这么构造，好处是什么，如果我来设计的话我会怎么设计啊这种暂时就不总结了，因为我觉得以我现在的水平还有学习精力来说把这些细节都一个个的弄清楚有点没抓住重点。现阶段还是先能够了解整个流程，有个大局观才是最重要的。至于以后如果有需要或者是有精力的时候再一个个的突破。\n\n在正式开始之前还是忍不住想要BB一下最近参加的京东笔试，被坑得有点憋屈。憋屈啥勒，被编译器坑了。这次京东的笔试说实话感觉真的好简单，真的没有什么技术上的难点，但是尼玛编程题把我坑了。提前一个小时把代码在本地编译器上编译完成并通过，当时心里还有些小激动，一提交，在线编译器说得不到指定结果，尼玛，顿时整个人都斯巴达了。最开始的时候还以为是自己本身代码的Bug，后来顺着思路又理了几遍，完全没问题啊，又自己创了几个新的输入也都能够运行，返回正常结果。整个人都是崩溃的，在这上面花了20多分钟时候不经意间瞥了一下左边的样例输入和输出，哦豁，这下全懂了。 \n\n 因为我没有很多这种参加在线笔试的经验，也没在网上怎么刷题，所以在样例输入和输出那里掺杂了一些自己想当然的想法。 \n\n 题目要求的样例输入是一直输入，有两种情况，一种情况返回No,一种情况返回Yes并返回对应的结果。是要求连续输入的，也就是你在输入的时候我至少要用一个数组或者是List、Map来保存你的输入。当检测到输入为空也就是直接按了回车的同时就开始运行，然后再一次性的打印出结果。我不知道啊，第一次看这种样例输入输出，一看以为只要能返回就好了，然后就是分开做的，输入错的就返回No，输入对的就返回Yes和结果，并不能够一起输入及返回。而这个时候时间又过了好多了，改代码的话整个代码的架构都要变，时间上完全来不及。这笔试要是编程题错了那估计是没戏了。 \n\n 这其实也怪自己吧，怨不得别的，只好等下次了，只是这次的题真的简单，错过了好可惜，毕竟还是非常想进京东锻炼锻炼的，就算进不了去体验京东的面试，知道哪里有不足也是好的。\n\n上面BB了这么多，也是超过了我的预料，这里就正式开始这篇博客了。\n\n首先，我们知道，Android是基于Linux的一个操作系统，它可以分为五层，下面是它的层次架构图，可以记一下，因为后面应该会总结到SystemServer这些Application Framework层的东西 \n\n \n\n Android的五层架构从上到下依次是应用层，应用框架层，库层，运行时层以及Linux内核层。\n\n而在Linux中，它的启动可以归为一下几个流程： \n\n Boot Loader-》初始化内核-》。。。。。。 \n\n 当初始化内核之后，就会启动一个相当重要的祖先进程，也就是init进程，在Linux中所有的进程都是由init进程直接或间接fork出来的。\n\n而对于Android来说，前面的流程都是一样的，而当init进程创建之后，会fork出一个Zygote进程，这个进程是所有Java进程的父进程。我们知道，Linux是基于C的，而Android是基于Java的（当然底层也是C）。所以这里就会fork出一个Zygote Java进程用来fork出其他的进程。【断点1】\n\n总结到了这里就提一下之后会谈到的几个非常重要的对象以及一个很重要的概念。\n\nAndroid系统中的客户端和服务器的概念 \n\n 在Android系统中其实也存在着服务器和客户端的概念，服务器端指的就是所有App共用的系统服务，比如上面的AMS，PackageManagerService等等，这些系统服务是被所有的App共用的，当某个App想要实现某个操作的时候，就会通知这些系统服务。\n\n当Zygote被初始化的时候，会fork出System Server进程，这个进程在整个的Android进程中是非常重要的一个，地位和Zygote等同，它是属于Application Framework层的，Android中的所有服务，例如AMS, WindowsManager, PackageManagerService等等都是由这个SystemServer fork出来的。所以它的地位可见一斑。\n\n而当System Server进程开启的时候，就会初始化AMS，同时，会加载本地系统的服务库，创建系统上下文，创建ActivityThread及开启各种服务等等。而在这之后，就会开启系统的Launcher程序，完成系统界面的加载与显示。【断点2】\n\nContext是一个抽象类，下面是它的注释信息，摘自源码。\n\n从上面的这段话可以简单理解一下，Context是一个关于应用程序环境的全局变量接口，通过它可以允许去获得资源或者类，例如启动Activity,广播，intent等等。\n\n我的理解：Context的具体实现是Application, Activity,Service，通过Context能够有权限去做一些事情，其实我觉得就是一个运行环境的问题。\n\n需要注意的地方 \n\n Android开发中由于很多地方都包含了Context的使用，因此就必须要注意到内存泄露或者是一些可能会引起的问题。\n\n例如在Toast中，它的Context就最好设置为Application Context，因为如果Toast在显示东西的时候Activity关闭了，但是由于Toast仍然持有Activity的引用，那么这个Activity就不会被回收掉，也就造成了内存泄露。\n\n上面举例的时候举到了Toast，其实Toast也是很有意思的一个东西，它的show方法其实并不是显示一个东西这么简单。 \n\n Toast实际上是一个队列，会通过show方法把新的任务加入到队列当中去，列队中只要存在消息就会弹出来使用，而队列的长度据说默认是40个（这是网上搜出来的，我在源码中没找到对应的设置，感觉也没啥必要就没找了）。 \n\n 所以这里就要注意一下show这个操作了，它并不是显示内容，而是把内容入队列。\n\n对于Handler来说，如果我们直接在AndroidStudio中创建一个非静态内部类Handler，那么Handler这一大片的区域会被AS标记为黄色，这个应该很多人都遇到过吧。实际上是因为这样设置会造成内存泄露，因为每一个非静态内部类都会持有一个外部类的引用，那么这里也就产生了一个内存泄露的可能点，如果当Activity被销毁时没有与Handler解除，那么Handler仍然会持有对该Activity的引用，那么就造成了内存泄露。\n\n解决方案 \n\n 使用static修饰Handler，这样也就成了一个静态内部类，那么就不会持有对外部类的引用了。而这个时候就可以在Handler中创建一个WeakReference（弱引用）来持有外部的对象。只要外部解除了与该引用的绑定，那么垃圾回收器就会在发现该弱引用的时候立刻回收掉它。\n\n关于垃圾回收的相关总结看我之前的博客，传送门：JVM原理及底层探索\n\n上面扯到了弱引用，就再BB一下四种引用方式吧。\n\n类加载器按层次从顶层到下依次为Boorsrtap ClassLoader（启动类加载器）,Extension ClassLoader（拓展类加载器），ApplicationClassLoader（应用程序类加载器）\n\n这里就需要介绍一下双亲委派模式了： \n\n 双亲委派模式的意思就是：除了启动类加载器之外，其余的加载器都需要指定一个父类的加载器，当需要加载的时候会先让父类去试着加载，如果父类无法加载也就是找不到这个类的话就会让子类去加载\n\n比如类A和类B都要加载system类，如果不是委托的话，类A就会加载一份，B也会加载一份，那么就会出现两份SYstem字节码 \n\n 如果使用委托机制，会递归的向父类查找，也就是首选用Bootstrap尝试加载，如果找不到再向下，如果A用这个已经加载了的话会直接返回内存中的system而不需要重新加载。那么就只会存在一份\n\n对于Java来说，类是需要使用到时才会加载，这里也就出现了一个延迟加载的效果。而在延迟加载的时候，会默认保持同步。这也就产生了一种单例模式的方式，具体的看我之前的博客：设计模式_单例模式\n\n我觉得在android所有的创建单例模式方法中里延迟加载方式是最好吧，虽然枚举比延迟加载更好，effiective java中也很推荐，但是并不怎么适用于Android，Android里枚举的消耗是static的两倍，延迟加载的话只要我们在使用延迟加载方式时做好反序列化的返回值readResolve()准备就好了。\n\n上面BB了太多其他的，现在有点缓不过来，下次自己看自己博客的时候会不会都被自己的思路带得乱七八糟的。\n\n上面的时候我们就已经完成了整个Android系统的开机以及初始化。接下来就可以B一下从点击APP图标开始到APP内部程序运行起来的流程了。\n\n当我们点击屏幕时，触摸屏的两层电极会连接在一起，也就产生了一个电压（具体的我忘了，书上有，图找不到了），当产生电压的时候，就可以通过对应的驱动把当前按压点的XY坐标传给上层，这里也就是操作系统。操作系统在获取到XY值的时候，就会对按压点的范围进行一个判断，如果确定按压点处于一个APP图标或者是Button等等的范围中时，操作系统也就会认为用户当前已经点击了这个东西，启动对应的监听。\n\n而当系统判断我们点击的是APP图标时，该App就由Launcher开始启动了【断点3】\n\nLauncher是一个继承自Activity，同时实现了点击事件，长按事件等等的一个应用程序。\n\n当我们点击一个APP的图标时，会调用Launcher内部的startActivitySafely()方法，而这个方法则会进行两件事，一个是启动目标activity，另一个功能就是捕获异常ActivityNotFoundException，也就是常见的“找不到activity,是否已经在androidmenifest文件中注册？”。而在startActivity方法中，经过一系列的转换最终会调用到startActivityForResult这个方法。\n\n所以实际上，我对整个Android的界面是这样理解的： \n\n 当系统完成初始化以及各种服务的创建之后，就会启动Launcher这个应用程序（它也是继承自Activity的，包含自己对应的xml布局文件），然后再把各种图标按照一个正常APP布局的方式放在上面，当我们点击APP图标时，也就相当于在Launcher这个APP应用程序中通过startActivity（在底层最后会转为startActivityForResult）来启动这个APP。简单的讲，我觉得就是一个主要的APP（Launcher）里面启动了其他的功能APP，例如QQ、微信这些。【个人理解，如果以后发现不对再修改】\n\n当我们手指按下时，Android是如何处理点击事件的呢？如何确定是让哪一个控件来处理呢？ \n\n 简单一句话：层层传递-冒泡的方式处理 \n\n 举个例子：现在公司来了个小项目，老板一看分配给经理做，经理一看分配给小组长，小组长一看好简单，分配给组员。如果在这个传递过程中（也就是还为分配到最底部时），某一层觉得我来负责这个比较好的话就会拦截掉这个消息，然后把它处理了，下面的就收不到有消息的这个通知。如果一直到了底层的话，组员如果能完成，就完成它。如果不能完成，那么就报告给组长，说组长我做不来，边学边做要影响进度。组长一看我也做不来，就给经理，经理一看我也不会，就给老板。这样也就一层层的传递了。 \n\n 总结一下就是消息从上到下依次传递，如果在传递的过程中被拦截了就停止下传。如果没有被拦截，就一直传递到底部，如果底部不能够消耗该消息，那么就又一层层的返回来，返给上层，直到被消耗或者是到达最顶层。\n\n第一个方法负责事件的分发，它的返回值就是表示是否消耗当前事件。 \n\n 第二个方法是用于判断是否拦截该消息，如果当前View拦截了某个时间，那么在同一个事件序列中，此方法不会被再次调用。返回结果表示是否拦截当前事件 \n\n 第三个方法就是处理事件。返回结果表示是否消耗当前事件，如果不小号，则在同一时间序列中，当前View无法再次接收到事件。\n\n对于一个根ViewGroup来说，点击事件产生后，首先会传递给它，调用它的dispath方法。如果这个ViewGroup的onIntercept方法返回true就表示它要拦截当前事件，false就表示不拦截，这个时候事件就会继续传递给子元素，接着调用子元素的dispath方法，直到被处理。\n\n顺带总结一下滑动冲突的解决吧 \n\n View的滑动冲突一般可以分为三种：\n\n比如说一个常见的，外部一个ListView，里面一个ScrollView。这个时候该怎么解决呢？其实这里想到了ViewPager，它里面实际上是解决了滑动冲突的，可以借鉴一下它的。\n\n滑动处理规则 \n\n 一般来说，我们可以根据用户手指滑动的方向以及角度来判断用户是要朝着哪个方向去滑动。而很多时候还可以根据项目的需求来指定一套合适的滑动方案。\n\n外部拦截法 \n\n 这种方法就是指所有的点击时间都经过父容器的拦截处理，如果父容器需要此时间就拦截，如果不需要此事件就不拦截。通过重写父容器的onInterceptTouchEvent方法：\n\n这里有一点需要注意，ACTION_DOWN事件父类容器就必须返回false，因为如果父类容器拦截了的话，后面的Move等所有事件都会直接由父类容器处理，就无法传给子元素了。UP事件也要返回false，因为它本身来说没有太多的意义，但是对于子元素就不同了，如果拦截了，那么子元素的onClick事件就无法触发。\n\n内部拦截法 \n\n 这种方法指的是父容器不拦截任何时间，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交给父容器进行处理。它需要配合requestDisallowInterceptTouchEvent方法才能正常工作。我们需要重写子元素的dispatch方法\n\n这种方法的话父类容器需要默认拦截除了ACTION_DOWN以外的其他时间，这样当子元素调用request方法的时候父元素才能继续拦截所需的事件。\n\n其他的 \n\n 如果觉得上面两个方式太复杂，看晕了，其实也可以自己根据项目的实际需要来指定自己的策略实现。例如根据你手指按的点的位置来判断你当前触碰的是哪个控件，以此来猜测用户是否是要对这个控件进行操作。如果点击的是空白的地方，就操作外部控件即可。\n\n【等有时间了就把ViewPager的处理总结一下，挺重要的】\n\nAndroid的消息机制主要是指Handler的运行机制，Handler的运行需要底层的MessageQueue和Looper的支撑\n\n虽然MessageQueue叫做消息队列，但是实际上它内部的存储结构是单链表的方式。由于Message只是一个消息的存储单元，它不能去处理消息，这个时候Looper就弥补了这个功能，Looper会以无限循环的形式去查找是否有新消息，如果有的话就处理消息，否则就一直等待（机制等会介绍）。而对于Looper来说，存在着另外的一个很重要的概念，就是ThreadLocal。\n\nThreadLocal它并不是一个线程，而是一个可以在每个线程中存储数据的数据存储类，通过它可以在指定的线程中存储数据，数据存储之后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到该线程的数据。 \n\n 举个例子，多个线程通过同一个ThreadLocal获取到的东西是不一样的，就算有的时候出现的结果是一样的（偶然性，两个线程里分别存了两份相同的东西），但他们获取的本质是不同的。\n\n那为什么有这种区别呢？为什么要这样设计呢？ \n\n 先来研究一下为什么会出现这个结果。 \n\n 在ThreadLocal中存在着两个很重要的方法，get和set方法，一个读取一个设置。\n\n摘自源码 \n\n 首先研究它的get方法吧，从注释上可以看出，get方法会返回一个当前线程的变量值，如果数组不存在就会创建一个新的。 \n\n 这里有几个很重要的词，就是“当前线程”和“数组”。 \n\n 这里提到的数组对于每个线程来说都是不同的，values.table，而values是通过当前线程获取到的一个Values对象，因此这个数组是每个线程唯一的，不能共用，而下面的几句话也更直接了，获取一个索引，再返回通过这个索引找到数组中对应的值。这也就解释了为什么多个线程通过同一个ThreadLocal返回的是不同的东西。\n\n那这里为什么要这么设置呢？翻了一下书，搜了一下资料：\n\n上面提到了Handler/Looper/Message Queue，它们实际上是一个整体，只不过我们在开发中接触更多的是Handler而已，Handler的主要作用是将一个任务切换到某个指定的线程中去执行，而Android之所以提供这个机制是因为Android规定UI只能在主线程中进程，如果在子线程中访问UI就会抛出异常。\n\n为什么Android不允许在子线程访问UI \n\n 其实这一点不仅仅是对于Android,对于其他的所有图形界面现在都采用的是单线程模式。 \n\n 因为对于一个多线程来说，如果子线程更改了UI，那么它的相关操作就必须对其他子线程可见，也就是Java并发中很重要的一个概念，线程可见性，Happen-before原则【下篇博客总结一下自己对Java并发的理解吧，挺重要的，总结完后再把传送门贴过来】而一般来说，对于这种并发访问，一般都是采用加锁的机制，但是加锁的机制存在很明显的问题：让UI访问间的逻辑变得复杂，同时效率也会降低。甚至有的时候还会造成死锁的情况，这个时候就麻烦了。 \n\n 而至于究竟能不能够实现这种UI界面的多线程呢？SUN公司的某个大牛（忘了是谁，很久之前看的，好像是前副总裁）说：“行肯定是没问题，但是非常考技术，因为必须要考虑到很多种情况，这个时候就需要技术专家来设计。而这种设计出来的东西对于广大普通程序员来说又是异常头疼的，就算是实现了多线程，普通人用起来也是怨声载道的。所以建议还是单线程”。\n\n举个常见的死锁例子：进程A中包含资源A,进程B中包含资源B，A的下一步需要资源B，B的下一步需要资源A，所以它们就互相等待对方占有的资源释放，所以也就产生了一个循环等待死锁。\n\nMessageQueue主要包含两个操作：插入和读取，读取操作本身会伴随着删除操作，插入和读取对应的方法分别为enqueueMessage和next，其中enqueueMessage的作用是往消息队列中插入一条消息，而next的作用是从消息队列中取出一条消息并将其从消息队列中移除。这也就是为什么使用的是一个单链表的数据结构来维护消息列表，因为它在插入和删除上比较有优势（把下一个连接的点切换一下就完成了）。\n\n而对于MessageQueue的插入操作来说，没什么可以看的，也就这样吧，主要需要注意的是它的读取方法next。\n\n源码有点长，总结一下就是： \n\n next方法它是一个死循环，如果消息队列中没有消息，那么next方法就会一直阻塞在这里，当有新的消息来的时候，next方法就会返回这条信息并将其从单链表中移除。\n\n而这个时候勒Looper就等着的，它也是一直循环循环，不停地从MessageQueue中查看是否有新消息，如果有新消息就会立刻处理，否则就会一直阻塞在那里。而对于Looper来说，它是只能创建一个的，这个要归功与它的prepare方法。\n\n从这里我们就可以看出该prepare方法会首先检测是否已经存在looper了，如果不存在，就创建一个新的；如果存在，就抛出异常。 \n\n 而之后使用Looper.loop()就可以开启消息循环了。\n\n从这里面我们可以看到它也是个死循环，会不停的调用queue.next()方法来获取信息，如果没有，就return,如果有就处理。\n\n注意 \n\n 当然了，这里有一个很重要的点，一般可能会忘，那就是在子线程中如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来终止消息循环，否则这个子线程就会一直处于等待状态，而如果退出Looper之后，这个线程就会立刻终止，所以建议不需要使用的时候终止Looper。\n\nHandler \n\n 上面总结了Looper和MessageQueue，这里就对Handler进行一个总结吧。它的工作主要包含消息的发送和接受过程，消息的发送可以通过post的一系列方法以及send的一系列方法来实现，post的一系列方法最终是通过send的一系列方法来实现的。 \n\n 实际上它发送消息的过程仅仅是向消息队列中插入了一条消息，MessageQueue的next方法就会返回这条消息给Looper，Looper在收到消息之后就会开始处理了。最后由Looper交给Handler处理（handleMessage()方法）。\n\n上面总结完了Android的消息处理机制，那么就顺带总结一下IPC通信吧，毕竟上面提到过那么多次Binder和Socket。\n\n资料：为什么Android要采用Binder作为IPC机制？ \n\n 知乎上面的回答相当的好，这个博主对系统底层也是颇有钻研，学习。\n\n这里就结合上面的知乎回答以及加上《Linux程序设计》还有一本Linux内核剖析（书名忘了但是讲得真的非常好），掺杂一些个人的理解。\n\n进程的定义 \n\n UNIX标准把进程定义为：“一个其中运行着一个或多个进程的地址控件和这些线程所需要的系统资源”。目前，可以简单的把进程看做正在运行的程序。\n\n进程都会被分配一个唯一的数字编号，我们成为PID（也就是进程标识符），它通常是一个取值范围从2到32768的正整数。当进程被启动时，系统将按顺序选择下一个未被使用的数字作为PID，当数字已经回绕一圈时，新的PID重新从2开始，数字1一般是为init保留的。在进程中，存在一个自己的栈空间，用于保存函数中的局部变量和控制函数的调用与返回。进程还有自己的环境空间，包含专门为这个进程建立的环境变量，同时还必须要维护自己的程序计数器，这个计数器用来记录它执行到的位置，即在执行线程中的位置。 \n\n 在Linux中可以通过system函数来启动一个进程\n\n守护进程 \n\n 这里就需要提到一个守护进程了，这个在所有的底层中经常都会被提到。 \n\n 在linux或者unix操作系统中在系统引导的时候会开启很多服务，这些服务就叫做守护进程。为了增加灵活性，root可以选择系统开启的模式，这些模式叫做运行级别，每一种运行级别以一定的方式配置系统。 守护进程是脱离于终端并且在后台运行的进程。守护进程脱离于终端是为了避免进程在执行过程中的信息在任何终端上显示并且进程也不会被任何终端所产生的终端信息所打断。 \n\n 守护进程常常在系统引导装入时启动，在系统关闭时终止。如果想要某个进程不因为用户或终端或其他的变化而受到影响，那么就必须把这个进程变成一个守护进程\n\n防止手机服务后台被杀死 \n\n 是不是在手机的设置界面看当前正在运行的服务时会发现有的APP不止存在一个服务？有的APP后台存在两个，有的存在三个？有的流氓软件也会这么设置，这样的话就可以一直运行在后台，用户你关也关不了（倒不是说所有这么设置的都是流氓软件，因为有的软件需要保持一个长期的后台在线，这是由功能决定的）。\n\n这里有两种方法（可能还有更多，这里只总结我了解的）：\n\nIPC通信 \n\n 上面总结了进程的相关基础，这里就开始总结一下进程间通信（IPC \n\n ）的问题了。 \n\n 现在Linux现有的所有IPC方式：\n\n到了这里，就有了问题，为什么在Linux已经存在这么多优良的IPC方案时，Android还要采取一种新的Binder机制呢？ \n\n 猜测：我觉得Android采用这种新的方式（当然也大面积的同时使用Linux的IPC通信方式），最多两个原因：\n\n刚才谈到Binder的时候提了一下效率的问题，那这里就不得不讲到反射了。\n\n反射它允许一个类在运行过程中获得任意类的任意方法，这个是Java语言的一个很重要的特性。它方便了程序员的编写，但是降低了效率。\n\n实际上，对于只要不是特别大的项目（非Android），反射对于效率的影响微乎其微，而与之对比的开发成本来说就更划算了。 \n\n 但是，Android是一个用于手机的，它的硬件设施有限，我们必须要考虑到它的这个因素，用户体验是最重要的。以前看到过国外的一项统计。在一个APP中的Splash中使用了反射，结果运行时间增加了一秒，这个已经算是很严重的效率影响了。\n\n为什么反射影响效率呢 \n\n 这里就需要提到一个东西，JIT编译器。JIT编译器它可以把字节码文件转换为机器码，这个是可以直接让处理器使用的，经过它处理的字节码效率提升非常大，但是它有一个缺点，就是把字节码转换成机器码的过程很慢，有的时候甚至还超过了不转换的代码效率（转换之后存在一个复用的问题，对于转换了的机器码，使用的次数越多就越值的）。因此，在JVM虚拟机中，也就产生了一个机制，把常用的、使用频率高的字节码通过JIT编译器转换，而频率低的就不管它。而反射的话则是直接越过了JIT编译器，不管是常用的还是非常用的字节码一律没有经过JIT编译器的转化，所以效率就会低。 \n\n 而在Android里面，5.0之前使用的是Davlik虚拟机，它就是上面的机制，而在Android5.0之后Google使用了一个全新的ART虚拟机全面代替Davlik虚拟机。 \n\n ART虚拟机会在程序安装时直接把所有的字节码全部转化为机器码，虽然这样会导致安装时间边长，但是程序运行的效率提升非常大。 \n\n 【疑问：那在Android5.0之后的系统上，反射会不会没影响了？由于现在做项目的时候更多考虑的是向下兼容，单独考虑5.0的情况还没有，等以后有需求或者是有机会的时候再深入了解一下，以后更新】\n\n刚才总结了Android的消息处理机制和IPC通信，那么我们主线程的消息处理机制是什么时候开始的呢？因为我们知道在主线程中我们是不需要手动调用Looper.prepare()和Looper.loop()的。\n\nAndroid的主线程就是ActivityThread，主线程的入口方法是main方法，在main方法中系统会通过Looper.prepareMainLooper()来创建主线程的Looper以及MessageQueue，并通过Looper.loop来开启消息循环，所以这一步实际上是系统已经为我们做了，我们就不再需要自己来做。 \n\n ActivityThread通过AppplicationThread和AMS进行进程件通信，AMS以进程间通信的方式完成ActivityThread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向Handler发送消息，Handler收到消息后会将ApplicationThread中的逻辑切换到主线程中去执行，这个过程就是主线程的消息循环模型。\n\n上面总结到了APP开始运行，依次调用onCreate/onStart/onResume等方法，那么在onCreate方法中我们经常使用的setContentView和findViewById做了什么事呢？\n\n首先，就考虑到第一个问题，也就是setContentView这个东西做了什么事，这里就要对你当前继承的Activity分类了，如果是继承的Activity，那么setContentView源码是这样的：\n\n这里面存在着3个重载函数，而不管你调用哪一个，最后都会调用到initWindowDecorActionBar()这个方法。 \n\n 而对于新的一个AppcompatActivity，这个Activity里面包含了一些新特性，现在我做的项目里基本都是使用AppcompatActivity代替掉原来的Activity，当然也并不是一定的，还是要根据项目的实际情况来选择。 \n\n 在AppcompatActivity中，setContentView是这样的：\n\n一样的3个重载函数，只是里面没有了上面的那个init方法，取而代之的是一个getDelegate().setContentView，这个delegate从字面上可以了解到它是一个委托的对象，源码是这样的：\n\n而在AppCompatDelegate.Create方法中，则会返回一个很有意思的东西：\n\n这里会根据SDK的等级来返回不同的东西，这样的话就不深究了，底层的话我撇了一下，应该原理和Activity是一样的，可能存在一些区别。这里就用Activity来谈谈它的setContentView方法做了什么事。\n\n这里就介绍了它的功能，它会按照一个布局资源去设置Activity的内容，而这个布局资源将会被引入然后添加所有顶级的Views到这个Activity当中。 \n\n 这是个啥意思勒。 \n\n 下面从网上扒了一张图： \n\n \n\n 这里是整个Activity的层级，最外面一层是我们的Activity，它包含里面的所有东西。 \n\n 再上一层是一个PhoneWindow，这个PhoneWindow是由Window类派生出来的，每一个PhoneWindow中都含有一个DecorView对象，Window是一个抽象类。 \n\n 再上面一层就是一个DecorView，我理解这个DecorView就是一个ViewGroup，就是装View的。 \n\n 而在DecoreView中，最上面的View就是我们的TitleActionBar，下面就是我们要设置的content。所以在上面的initWindowDecorActionBar就能猜到是什么意思了吧。\n\n而在initWindowDecorActionBar方法中，有一段代码：\n\n注意上面的window.getDecoreView（）方法的注释，该方法会设置一些window的标志位，而当这个方法执行完之后，就再也不能更改了，这也就是为什么很多第三方SDK设置window的标志位时一定要求要在setContentView方法前调用。\n\nfindViewById根据继承的Activity类型的不同也存在着区别，老规矩，还是以Activity的来。\n\n从源码来看，findViewById也是经过了一层层的调用，它的功能如同它上面的注释一样，通过一个view的id属性查找view，这里也可以看到一个熟悉的getWindow方法，说明findViewById()实际上Activity把它也是交给了自己的window来做\n\n而在这里面，又调用了getDecorView的findViewById（）方法，这也相当于是一个层层传递的过程，因为DecorView我理解为就是一个ViewGroup，而当运行getDecorView().findViewById()方法时，就会运行View里面的findViewById方法。它会使用这个被给予的id匹配子View的Id，如果匹配，就返回这个View，完成View的绑定\n\n最后总结一下（Activity中），findViewById的过程是这样的： \n\n Activity -> Window -> DecorView -> View", "link": "http://blog.csdn.net/JonsTank2013/article/details/51118563", "publishDate": "2016-04-12 00:10", "title": "\r\n        "}
{"readCount": "29105", "article": "应用组件(客户端)可以调用bindService()绑定到一个service．Android系统之后调用service的onBind()方法，它返回一个用来与service交互的IBinder\n\n绑定是异步的．bindService()会立即返回，它不会返回IBinder给客户端．要接收IBinder，客户端必须创建一个ServiceConnection的实例并传\n\n给bindService()．ServiceConnection包含一个回调方法，系统调用这个方法来传递要返回的IBinder．\n\n注：只有activities,services,和contentproviders可以绑定到一个service—你不能从一个broadcastreceiver绑定到service．\n\n所以，从你的客户端绑定到一个service，你必须：\n\n系统调用这个来传送在service的onBind()中返回的IBinder． Android系统在同service的连接意外丢失时调用这个．比如当service崩溃了或被强杀了．当客户端解除绑定时，这个方法不会被调用． ３当系统调用你的onServiceConnected()方法时，你就可以使用接口定义的方法们开始调用service了． 　　当你的客户端被销毁，它将从service解除绑定，但是你必须总是在你完成与service的交互时或当你的activity暂停于是service在不被使用时可以关闭此两种情况下解 除绑定．(下面会讨论更多在适当的时候绑定和解除绑定的问题． 使用这个ServiceConnection，客户端可以绑定到一个service，通过把它传给bindService()．例如：\n\n下面是一些关于绑定到service的重要事项：\n\n当一个service的所有客户端都解除绑定，Android系统就销毁它(除非它是从onStartCommand()启动)．如果你的service是一个纯boundservice，你不需管理它的生命\n\n期—Android系统会为你管理它．。\n\n然而，如果你选择了实现onStartCommand()回调方法，那么你必须明确地停止service，因为service现在被认为是＂开始的＂．在此情况下，service会一直运行，直\n\n到service使用stopSelf()停止它自己或另外的组件调用了stopService()停止了它，不管是否有客户端绑定了它．\n\n另外，如果你的service已经启动并且接受绑定，那么当系统调用你的onUnbind()方法，你可以选择返回true表示你想在客户端下一次绑定到service时接受一个\n\n对onRebind()的调用(而不是一个对onBind()的调用)．onRebind()返回void，但是客户端依然会在它的onServiceConnected()回调中接收到IBinder．下图演示了这种生命其的\n\n混合使用的时候总结的，欢迎大家来一起讨论！", "link": "http://blog.csdn.net/yuzhiboyi/article/details/7558176", "publishDate": "2012-05-11 17:29", "title": "\r\n        Android里Service的bindService()和startService()混合使用深入分析            \r\n        "}
{"readCount": "178", "article": "注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加\n\n运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当       ），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。\n\n运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当\n\n运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当\n\n注：使用运算词的几个查询结果行必须是一致的。\n\n左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。\n\n右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。\n\n全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。\n\n一张表，一旦分组完成后，查询后只能得到组相关的信息。\n\n在SQLServer中分组时：不能以text,ntext,image类型的字段作为分组依据\n\n在selecte统计函数中的字段，不能和普通的字段放在一起；\n\n后不能直接跟一个变量，所以在实际应用中只有这样的进行特殊的处理。Rid为一个标识列，如果 后还有具体的字段，这样做是非常有好处的。因为这样可以避免 的字段如果是逻辑索引的，查询的结果后实际表中的不一致（逻辑索引中的数据有可能和数据表中的不一致，而查询时如果处在索引则首先查询索引）\n\n15、说明：选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.)\n\n16、说明：包括所有在 TableA 中但不在 TableB和TableC 中的行并消除所有重复行而派生出一个结果表\n\n评价： 这种操作牵连大量的数据的移动，这种做法不适合大容量但数据操作\n\n3),例如：在一个外部表中导入数据，由于某些原因第一次只导入了一部分，但很难判断具体位置，这样只有在下一次全部导入，这样也就产生好多重复的字段，怎样删除重复字段\n\n24、说明：选择从10到15的记录\n\n1、1=1，1=2的使用，在SQL语句组合时用的较多\n\n4、转移数据库给新用户以已存在用户权限\n\n有如下表，要求就裱中所有沒有及格的成績，在每次增長0.1的基礎上，使他們剛好及格:\n\n例如1：一张表有一万多条记录，表的第一个字段 RecID 是自增长字段， 写一个SQL语句，找出表的第31到第40个记录。\n\nA则在数据表中查找，这样由于索引中的顺序有可能和数据表中的不一致，这样就导致查询到的不是本来的欲得到的数据。\n\n11：查看与某一个表相关的视图、存储过程、函数\n\n14：查询某一个表的字段和数据类型\n\n1,datalength(Char_expr) 返回字符串包含字符数,但不包含后面的空格\n\n(expression,start,length) 取子串，字符串的下标是从“1”，start为起始位置，length为字符串长度，实际应用中以len(expression)取得其长度\n\n( check_expression , replacement_value )如果check_expression為空，則返回replacement_value的值，不為空，就返回check_expression字符操作类\n\n使返回的结果中不包含有关受 Transact-SQL 语句影响的行数的信息。如果存储过程中包含的一些语句并不返回许多实际的数据，则该设置由于大量减少了网络流量，因此可显著提高性能。   NOCOUNT 设置是在执行或运行时设置，而不是在分析时设置。\n\n后最多可以跟多少张表或视图：256\n\n在SQL中，一个字段的最大容量是8000，而对于nvarchar(4000),由于nvarchar是Unicode码。\n\n1.发布服务器,订阅服务器都创建一个同名的windows用户,并设置相同的密码,做为发布快照文件夹的有效访问用户\n\n2.在发布服务器上,新建一个共享目录,做为发布的快照文件的存放目录,操作:\n\n5.在发布服务器和订阅服务器上互相注册\n\n6.对于只能用IP,不能用计算机名的,为其注册服务器别名（此步在实施中没用到）\n\n(1) 从[工具]下拉菜单的[复制]子菜单中选择[配置发布、订阅服务器和分发]出现配置发布和分发向导\n\n(2) [下一步] 选择分发服务器 可以选择把发布服务器自己作为分发服务器或者其他sql的服务器（选择自己）\n\n可以选择:是,让我设置分发数据库属性启用发布服务器或设置发布设置\n\n(7) [下一步] 选择需要发布的数据库和发布类型\n\n(4)单击[下一步]系统要求指定可以订阅该发布的数据库服务器类型,\n\nSQLSERVER允许在不同的数据库如 orACLE或ACCESS之间进行数据复制。\n\n(5)单击[下一步]系统就弹出一个定义文章的对话框也就是选择要出版的表\n\n注意: 如果前面选择了事务发布 则再这一步中只能选择带有主键的表\n\n是 我将自定义数据筛选,启用匿名订阅和或其他自定义属性\n\n1)如果选择署名订阅,则需要在发布服务器上添加订阅服务器\n\n否则在订阅服务器上请求订阅时会出现的提示:改发布不允许匿名订阅\n\n当完成出版物的创建后创建出版物的数据库也就变成了一个共享数据库\n\n然后将SQL Agent服务启动,并设置为自动启动,否则你的作业不会被执行", "link": "http://blog.csdn.net/loveyaozu/article/details/46711789", "publishDate": "2015-07-01 16:36", "title": "\r\n        MySQL            \r\n        "}
{"readCount": "189", "article": "Spring 4.0已经发布RELEASE版本，不仅支持Java8，而且向下兼容到JavaSE6/JavaEE6，并移出了相关废弃类，新添加如Java8的支持、Groovy式Bean定义DSL、对核心容器进行增强、对Web框架的增强、Websocket模块的实现、测试的增强等。其中两个我一直想要的增强就是：支持泛型依赖注入、对cglib类代理不再要求必须有空参构造器了。具体更新请参考：\n\n对于Repository，我们一般是这样实现的：首先写一个模板父类，把通用的crud等代码放在BaseRepository；然后子类继承后，只需要添加额外的实现。\n\n这个也是我之前非常想要的一个功能，这样对于那些基本的CRUD式代码，可以简化更多的代码。\n\n这样会注入：key是bean名字；value就是所有实现了BaseService的Bean，假设使用上一篇的例子，则会得到：\n\n这样会注入所有实现了BaseService的Bean；但是顺序是不确定的，如果我们想要按照某个顺序获取；在Spring4中可以使用@Order或实现Ordered接口来实现，如：\n\n这种方式在一些需要多态的场景下是非常有用的。\n\n我们可以把@Lazy放在@Autowired之上，即依赖注入也是延迟的；当我们调用userService时才会注入。即延迟依赖注入到使用时。同样适用于@Bean。\n\n@Conditional类似于 @Profile（一般用于如我们有开发环境、测试环境、正式机环境，为了方便切换不同的环境可以使用 @Profile指定各个环境的配置，然后通过某个配置来开启某一个环境，方便切换 ，但是@Conditional的优点是允许自己定义规则。可以指定在如@Component、@Bean、@Configuration等注解的类上，以绝对Bean是否创建等。首先来看看使用@Profile的用例，假设我们有个用户模块：\n\n这种方式非常简单。如果想自定义如@Profile之类的注解等，那么@Conditional就派上用场了；假设我们系统中有好多本地/远程接口，那么我们定义两个注解@Local和@Remote注解要比使用@Profile方便的多；如：\n\n首先在@Local和@Remote注解上使用@Conditional(CustomCondition.class)指定条件，然后使用@Local和@Remote注解我们的Service，这样当加载Service时，会先执行条件然后判断是否加载为Bean。@Profile就是这样实现的，其Condition是：org.springframework.context.annotation.ProfileCondition。可以去看下源码，很简单。\n\n这是一个很好的特性，使用构造器注入有很多好处，比如可以只在创建Bean时注入依赖，然后就不变了，如果使用setter注入，是允许别人改的。当然我们可以使用spring的字段级别注入。如果大家使用过如Shiro，我们可能要对Controller加代理。如果是类级别代理，此时要求Controller必须有空参构造器，有时候挺烦人的。spring如何实现的呢？其内联了objenesis类库，通过它来实现，可以去其官网看看介绍。这样就支持如下方式的构造器注入了：\n\norg.springframework.cglib.proxy.Enhancer在其github和maven仓库中的source中竟然木有，其github：https://github.com/spring-projects/spring-framework/tree/master/spring-core/src/main/java/org/springframework/cglib；难道忘了吗？\n\n从Spring4开始，Spring以Servlet3为进行开发，如果用Spring MVC 测试框架的话需要指定Servlet3兼容的jar包（因为其Mock的对象都是基于Servlet3的）。另外为了方便Rest开发，通过新的@RestController指定在控制器上，这样就不需要在每个@RequestMapping方法上加   ，支持REST客户端的异步无阻塞支持。\n\n这样当你开发Rest服务器端的时候，spring-mvc配置文件需要的代码极少，可能就仅需如下一行：\n\n非常简单，服务器端暂停10秒再返回结果（但是服务器也是非阻塞的）。具体参考我github上的代码。\n\n此处使用Future来完成非阻塞，这样的话我们也需要给它一个回调接口来拿结果； Future和Callable是一对，一个消费结果，一个产生结果。调用完模板后会立即返回，不会阻塞；有结果时会调用其回调。\n\nAsyncRestTemplate默认使用SimpleClientHttpRequestFactory，即通过java.net.HttpURLConnection实现；另外我们也可以使用apache的http components；使用template.setAsyncRequestFactory(new HttpComponentsAsyncClientHttpRequestFactory());设置即可。\n\n它设计的已经足够好，使用子元素可以配置我们需要的配置。", "link": "http://blog.csdn.net/loveyaozu/article/details/46722439", "publishDate": "2015-07-02 09:45", "title": "\r\n        spring4新特性杂谈            \r\n        "}
{"readCount": "3054", "article": "安装JDK6本身并不复杂，只是目前较新版本的Ubuntu已经不支持直接通过apt-get安装了。因此，需要从Oracle官方网站下载安装包进行安装。\n\n其实，目前Oracle已经发布了JDK7。安装JDK6的原因是TI的android devkit 3.0.0在编译rootfs时，必须指定使用JDK6。木有办法，只能搞JDK6了。\n\nJDK6的bin文件中有许多可执行命令，根据需要，可以选择安装至/usr/bin目录下，比如，我安装了java/javac/javaws/jar四个命令。具体执行如下命令：", "link": "http://blog.csdn.net/cpuabc/article/details/7862003", "publishDate": "2012-08-13 21:49", "title": "\r\n        在Ubuntu 12.04 LTS上安装JDK6            \r\n        "}
{"readCount": "195", "article": "一．对用户组和用户的操作\n\n②    命令 gpasswd为组添加用户\n\n 只有root和组管理员能够改变组的成员：\n\n 例：把 user1加入users组\n\n gpasswd –a user1 users\n\n 例：把 user1退出users组\n\n gpasswd –d user1 users\n\n1. 对用户操作\n\n 在创建用户时，需要为新建用户指定一用户组，如果不指定其用户所属的工作组，自动会生成一个与用户名同名的工作组。\n\n ① 创建用户user1的时候指定其所属工作组users，\n\n设置密码：输入 password user1指令后，会让输入新密码(New UNIX password:) 输入两次密码匹配后密码设置完成\n\n用户的缺省UID从500向后顺序增加，500以下作为系统保留账号，可以指定UID\n\n如果是在root用户下修改指定用密码只需输入：password username按提示修改即可\n\nid命令查看一个用户的UID和GID, 例：查看user4的id\n\nkill                杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程。\n\n当然，如果想解压缩，就直接替换上面的命令  tar-cvf  / tar -zcvf  / tar -jcvf 中的“c” 换成“x” 就可以了\n\n在linux下一些常用的关机/重启命令有shutdown、halt、reboot、及init，它们都可以达到重启系统的目的，但每个命令的内部工作过程是不同的。 \n\n \n\n Linux centos重启命令： \n\n \n\n 1、reboot \n\n 2、shutdown-r now 立刻重启(root用户使用) \n\n 3、shutdown-r 10 过10分钟自动重启(root用户使用) \n\n 4、shutdown-r 20:35 在时间为20:35时候重启(root用户使用) \n\n \n\n 如果是通过shutdown命令设置重启的话，可以用shutdown -c命令取消重启 \n\n \n\n Linux centos关机命令： \n\n \n\n 1、halt 立刻关机 \n\n 2、poweroff 立刻关机 \n\n 3、shutdown-h now 立刻关机(root用户使用) \n\n 4、shutdown-h 10 10分钟后自动关机 \n\n \n\n 如果是通过shutdown命令设置关机的话，可以用shutdown -c命令取消重启\n\n将一个命令的标准输出作为另一个命令的标准输入。也就是把几个命令组合起来使用，后一个命令除以前一个命令的结果。\n\n例：grep -r\"close\" /home/* | more       在home目录下所有文件中查找，包括close的文件，并分页输出。\n\nvim三种模式：命令模式、插入模式、编辑模式。使用ESC或i或：来切换模式。\n\n/apache           在文档中查找apache 按n跳到下一个，shift+n上一个\n\n第二三四个字符“rw-”表示当前所属用户的权限。   所以用数值表示为4+2=6\n\n第五六七个字符“rw-”表示当前所属组的权限。     所以用数值表示为4+2=6\n\n所以操作此文件的权限用数值表示为662\n\n例如：有一个文件filename，权限为“-rw-r----x” ,将权限值改为\"-rwxrw-r-x\"，用数值表示为765", "link": "http://blog.csdn.net/loveyaozu/article/details/46787761", "publishDate": "2015-07-07 12:04", "title": "\r\n        Linux常用命令            \r\n        "}
{"readCount": "155", "article": "在上一文中，我们说过，Activity就相当于一块块的七巧板，每个应用用这一个个七巧板组合成了美丽的图画，并用代码验证了每个Activity的生命周期。那么，每个应用又是如何将各个Activity组合起来的呢？这就是本文要讲的内容。通常情况下，一个应用有一个Task，这个Task就是为了完成某个工作的一系列Activity的集合。而这些Activity又被组织成了堆栈的形式。当一个Activity启动时，就会把它压入该Task的堆栈，而当用户在该Activity中按返回键，或者代码中finish掉时，就会将它从该Task的堆栈中弹出。如果我们没有特别的需求，我们的应用就会呈现出如下图所示的情形（好吧，我承认这个图是document里的）：\n\n然而，事实上我们的需求远没有我们想的那么简单。有时候，你可能希望在开启一个Activity时，重新开启一个Task；有时你可能希望将已经存在的一个Activity放到栈顶，而不是重新创建一个...\n\n     Android为了使我们能够打破默认的堆栈的先后出的模式，提供了两个种方式：一种是在AndroidManifest.xml定义Activity时指定它的加载模式，另一种是在用Intent开启一个Activity时，在Intent中加入标志。如果两种方式都用了，则后者的优先级更高。\n\n     两种方式的差别在于，前者在于描述自己，向别的Acttivity等声明你们如何来加载我；而后者则是动态的，指出我要求你（要启动的Activity）如何来加载。本文的重点在于研究在AndroidManifest.xml中声明加载模式。\n\nAndroid为我们定义了四种加载模式，分别是：standard、singleTop、singleTask和singleInstance。\n\n然后我们启动程序，开启Activity1，然后点击Acitivity1，启动另一个Activity1，然后再点击，再点击，再点击... 之后我们点返回键。\n\n     发生了什么事情？没错，我们按返回键返回一个又一个相同的Activity1。\n\n     standard是Activity默认的加载模式，这种方式用一个词来形容的话就是“拿来主义”。使用这种模式的Activity向所有使用它的Task声明：“我这里的这种Activity多着呢，谁需要的话我就给谁”。所以当一个Task请求加载这个Activity时，该Task直接实例化该Activity，并把它放到栈顶。\n\n     因此我们的例子就出现了这样的堆栈结构（假设我们点击了4次）：\n\n我们设想一个情形：我们要做一个图片浏览器，第一个界面是图片列表界面（假设为PictureListActivity），第二个界面是浏览该张图片（假设为PictureViewActivity）。在PictureViewActivity中可以startActivity启动浏览界面浏览上一张和下一张。\n\n     如果每一张图片的浏览启动一个PictureViewActivity（当然你可能不是采用这种方式来浏览上一张和下一张，这里只是举个例子），如果采用standard模式的话，就会出现多个PictureViewActivity在堆栈中堆叠的情形。下面介绍的singleTop便可以解决这个问题。\n\n我们将上面的例子稍加改动，AndroidManifest.xml中Acitivity1的launchMode改为singleTop，Activity1的代码修改如下：\n\n同样，我们启动程序，开启Activity1，然后点击Acitivity1，启动另一个Activity1，然后再点击，再点击，再点击... 之后我们点返回键。\n\n     结果，Activity1第一次创建时，显示一个Toast提示，onCreate被调用，当再次点击时，onCreate没有被调用相反是进入了onNewIntent函数。当按返回键时，直接退出了该应用，可见，堆栈中只存在一个Acitivity1。\n\n     可见，当activity被设置为singleTop的加载模式时，如果堆栈的顶部已经存在了该Activity，那么，它便不会重新创建，而是调用onNewIntent。如果，该Activity存在，但不是在顶部，那么该Activity依然要重新创建，请读者自行验证。\n\n     因此singleTop模式的思想便是“拒绝堆叠”！\n\n     以上说的两种加载模式，Activity均可以实例化多次，而下面讲的两个加载模式就只可以实例化一次。\n\n从代码中我们可以看出，每当两个Activity创建、销毁以及onNewIntent时，都会打印该Activity的HashCode和所在的Task id。\n\n我们的操作步骤是这样的，打开应用程序，默认启动Activity2，点击Activity2，进入Activity1，再点击Activity1进入Activity2，再点击Activity2进入Activity1，然后按返回键，直到返回到Home。\n\n晕了吧，好写个顺序来形象的表示下：Activity2->Activity1(singleTask)->Activity2->Activity1(singleTask)。^_^\n\n进入Activity2，然后到Activity1，我们看Log信息为：\n\n03-01 14:50:08.144: ERROR/Activity2(371): Activity2 onCreated! HashCode=1156067168 TaskId=7\n\n     03-01 14:50:13.923: ERROR/Activity1(371): Activity1 onCreate! HashCode=1156107384 TaskId=7\n\n     我们看到，当本应用启动singleTask的Activity（Activity1）时，Activity1并没用另外启用一个任务。而是在原来的任务中创建了它。\n\n再从Activity1进入Activity2，然后再进入Activity1，这个过程，我们再看log信息：\n\n03-01 14:53:50.823: ERROR/Activity2(371): Activity2 onCreated! HashCode=1156128904 TaskId=7\n\n     03-01 14:53:58.154: ERROR/Activity1(371): Activity1 onNewIntent! HashCode=1156107384 TaskId=7\n\n     03-01 14:53:58.394: ERROR/Activity2(371): Activity2 onDestroy! HashCode=1156128904 TaskId=7\n\n     从这个Log信息我们可以得到这个结论：当singleTask模式的Activity启动时，如果发现在某个Task中已经存在，那么它会先将该Activity（Activity1）上部的Activity（Activity2）销毁，然后调用它（Activity1）的onNewIntent函数。\n\n我们下面来研究一下当singleTask的Activity被其他应用调用时的情况。\n\n为了使Activity1能够被其他应用程序调用，我们在AndroidManifest.xml中加入action，如下：\n\n我们的操作方法是，MyActivity->Activity1->Activity2->Activity1，之后我们按Home键，然后再从Home重新进入MyActivity所在的应用。\n\n03-01 15:04:25.784: ERROR/MyActivity(429): TaskId=9\n\n     03-01 15:04:26.244: ERROR/Activity1(401): Activity1 onCreate! HashCode=1156107632 TaskId=10\n\n     从这个Log信息我们可以看出：当某个应用调用其他应用里声明的singleTask模式的Activity时，它会重新创建一个Task，然后将该Activity实例化并压入堆栈。\n\n接着我们看Activity1和Activity2的相互切换，log信息如下：\n\n03-01 15:04:47.524: ERROR/Activity2(401): Activity2 onCreated! HashCode=1156128104 TaskId=10\n\n     03-01 15:04:50.674: ERROR/Activity1(401): Activity1 onNewIntent! HashCode=1156107632 TaskId=10\n\n     03-01 15:04:50.994: ERROR/Activity2(401): Activity2 onDestroy! HashCode=1156128104 TaskId=10\n\n     和我们所期望的那样，如果Activity发现已经存在时，会销毁其上的Activity，然后调用onNewIntent。\n\n之后，我们按Home键，返回桌面，然后，再次进入该应用，我们神奇的发现，我们进入的是MyActivity界面，taskId为10的所有Activity不知了踪影！\n\n这是因为，该应用对应的task的id为9，所以，进入后之后MyActivity在该task中，所以最后显示的是MyActivity。我的以上Activity1的代码实际上是不好的习惯，因为Activity1很可能会成为一个孤岛，所以建议，如果该Activity的类型不是LAUNCHER,最好不要设为singleTask。\n\n那么singleTask的这些特性有什么用处？我们举一个例子，浏览器就是一个singleTask的例子，启动一个浏览器，在Android中是一个比较沉重的过程，它需要做很多初始化的工作，并且会有不小的内存开销。如果有多个应用都来请求打开网页，那么系统就不会不堪重负。因此，如果浏览器采用singleTask模式，如果有多个请求打开网页的请求，都会在一个Task中响应，这样就会避免以上的情况。\n\n我们现在来研究最后一个加载模式，singgleInstance，测试很简单，我们只要在singleTask测试的例子中，将Activity1的模式改为singleInstance模式即可。\n\n03-01 15:41:59.283: ERROR/Activity2(488): Activity2 onCreated! HashCode=1156067168 TaskId=12\n\n     03-01 15:42:04.103: ERROR/Activity1(488): Activity1 onCreate! HashCode=1156107520 TaskId=13\n\n     我们发现，当采用singleInstance模式时，启动时创建了一个新的Task，并将Activity1实例化加入到该Task中。\n\n03-01 15:43:52.214: ERROR/Activity2(488): Activity2 onCreated! HashCode=1156127728 TaskId=12\n\n     03-01 15:43:56.804: ERROR/Activity1(488): Activity1 onNewIntent! HashCode=1156107520 TaskId=13\n\n     我们通过该log信息可以得出结论：singleInstance的Activity（Activity1）不允许其他的Activity（Activity2）加入到自己的Task中，它是的内心容不下另一个人，它是一个孤独寂寞的人。 当Activity1发现已经存在一个Task中包含自己的实例时，它会调用自己的onNewIntent。\n\n03-01 15:50:21.134: ERROR/MyActivity(556): TaskId=16\n\n     03-01 15:50:21.484: ERROR/Activity1(534): Activity1 onCreate! HashCode=1156107344 TaskId=17\n\n     不出意料，Activity1重新创建了一个Task，并将自己的实例入栈。\n\n03-01 15:50:36.484: ERROR/Activity2(534): Activity2 onCreated! HashCode=1156128056 TaskId=18\n\n     03-01 15:50:46.114: ERROR/Activity1(534): Activity1 onNewIntent! HashCode=1156107344 TaskId=17\n\n     我们从该过程可以看出：如果从其它应用程序调用singleInstance模式的Activity（Activity1），从该Activity开启其他Activity（Activity2）时，会创建一个新的Task（task id为18的那个），实际上，如果包含该Activity（Activity2）的Task已经运行的话，他会在该运行的Task中重新创建。\n\nOK，上面啰嗦了那么多，如果这部分不是很清楚的人，可能已经头昏脑胀了。那我们总结一下吧，这总该看看了吧。\n\n“拿来主义”standard模式。哪里需要调用我我就去哪里，可以多次实例化，可以几个相同的Activity重叠。\n\n“拒绝堆叠”singleTop模式。可以多次实例化，但是不可以多个相同的Activity重叠，当堆栈的顶部为相同的Activity时，会调用onNewIntent函数。\n\n“独立门户”singleTask模式。同一个应用中调用该Activity时，如果该Activity没有被实例化，会在本应用程序的Task内实例化，如果已经实例化，会将Task中其上的Activity销毁后，调用onNewIntent；其它应用程序调用该Activity时，如果该Activity没有被实例化，会创建新的Task并实例化后入栈，如果已经实例化，会销毁其上的Activity，并调用onNewIntent。一句话，singleTask就是“独立门户”，在自己的Task里，并且启动时不允许其他Activity凌驾于自己之上。\n\n“孤独寂寞”singleInstance模式。加载该Activity时如果没有实例化，他会创建新的Task后，实例化入栈，如果已经存在，直接调用onNewIntent，该Activity的Task中不允许启动其它的Activity，任何从该Activity启动的其他Activity都将被放到其他task中，先检查是否有本应用的task，没有的话就创建。\n\n附：由于android文档中的解释不是很清楚，所以做了上述测试，结论也是根据测试得出的结论，singleTask和singInstance的任务创建还跟taskAffience有关，我们下次再研究。如果有不对的地方请大家赶快指正，以防影响他人。多谢。", "link": "http://blog.csdn.net/sjz4860402/article/details/23186655", "publishDate": "2014-04-08 15:24", "title": "\r\n        Activity的加载模式            \r\n        "}
{"readCount": "290", "article": "在Android中，TextView是我们最常用的用来显示文本的控件。\n\n一般情况下，TextView中的文本都是一个样式。那么如何对于TextView中各个部分的文本来设置字体，大小，颜色，样式，以及超级链接等属性呢？下面我们通过SpannableString的具体实例操作来演示一下。", "link": "http://blog.csdn.net/sjz4860402/article/details/23541423", "publishDate": "2014-04-12 17:10", "title": "\r\n        Android TextView中文字通过SpannableString来设置超链接、颜色、字体等属性            \r\n        "}
{"readCount": "184", "article": "在用Eclipse开发过程中，为了兼容Android2.2和4.0以上版本，我在使用Notification类时做了2个版本的代码，代码根据系统版本不同执行相应模块，结果，等我输完代码，发现系统提示了一个这么的错误。\n\n不详，可能和Run Android Lint有点关系吧。就是创建项目时，我们设置了最低版本API Level，比如我的是8，因此，Eclipse检查我调用的API后，发现版本号不能向低版本兼容，比如我用的“Notification.Builder”是Level 11 以上才有的，自然超过了8，所以提示错误。\n\n右键点击项目->Android tools ->Clear Link Markers.即可临时解决，但是如果调试用的模拟器是低版本的，则在调试完后还有这个错误。\n\n如果把manifest文件中的user-sdk的android:minSdkVersion改为报错的那个高版本就没事。比如下面：\n\n这种错误不仅发生在Level11，也同时发生于其他因为设置了最低版本，但使用了高版本API的代码中，解决方案应该相同。", "link": "http://blog.csdn.net/sjz4860402/article/details/23429301", "publishDate": "2014-04-11 10:51", "title": "\r\n        Android Call requires API level 11 (current min is 8)的解决方案            \r\n        "}
{"readCount": "5306", "article": "如果你在目标 Android 设备上运行了 Qt on Android 应用，你可能希望看到程序输出的日志信息。 Android SDK 中有 adb 工具，当你连接了目标设备，可以使用 adb logcat 查看 Android 设备上应用输出的日志。\n\n为了把日志导入 Android 系统的日志系统（一个环形内存日志系统），我写了一个辅助函数，方便大家使用。\n\n很简单，我声明了一个函数 installLogcatMessageHandler ，如果没有定义 ANDROID 宏，它就是一个空宏，什么也不干；否则就安装一个消息过滤器，接管 Qt 输出的消息，转发到 Android 的日志系统中。\n\n实现也很简单，调用 qInstallMessageHandler 把 messageOutput2Logcat 设置为 Qt 应用的默认消息处理器。 messageOutput2Logcat 函数则将 Qt 的调试消息级别映射到 Android 的日志级别上并调用 __android_log_write() 函数将日志信息写入 Android 日志系统。\n\n你可以直接使用这两个文件，加入到你的项目中即可。然后在 main() 函数前包含 qDebug2Logcat.h 头文件，在 main() 函数体第一行加入下面的代码：\n\n\n\n好了，一切就绪了。\n\n我翻译的大神 BogDan Vatra 的 Qt on Android 系列文章：\n\n我的关于 Qt on Android 的系列文章：", "link": "http://blog.csdn.net/foruok/article/details/25273151", "publishDate": "2014-05-08 08:43", "title": "\r\n        Qt on Android：将Qt调试信息输出到logcat中            \r\n        "}
{"readCount": "112", "article": "一些简单的JSON格式解析可以直接使用JSONObject和JSONArray来解析，但是面对比较复杂或者是数据量较大的JSON数据时就需要使用fastJSON和Gson来解析了，这样的效率和效果都更好\n\n这里介绍本次项目使用到的Gson解析，fastJSON类似，但是由于如果包含了fastJSON,那么在proguard混淆的时候需要在rule中包含以下内容：\n\n如果不包含的话，就会出现以下几个问题： \n\n １.　加了符号Annotation的实体属性后，一使用就崩溃 \n\n ２. 当有泛型属性时，一使用就崩溃\n\n再是解析JSONArray \n\n 需要借助TypeToken将期望解析成的数据类型传入fromJson方法\n\n上面的JSON数据总结一下，也就包含以下几个内容： \n\n 首先第一层是code, desc,content \n\n 第二层content中包含以下的内容：grade, signin, room, docs，printer \n\n 第三层docs中包含以下内容: id, docname, pagecnt, doctime \n\n 第三层printer中包含以下内容:id, address\n\n对于这种比较复杂的JSON数据格式的解析，可以分成以下几步来做：\n\n当然咯，其中还要包括各种setter和getter方法，只需要注意一点，这里的属性被声明为List是因为这个是一个JSONArray，对于JSONObject只需要直接定义", "link": "http://blog.csdn.net/jonstank2013/article/details/50208209", "publishDate": "2015-12-07 17:05", "title": "\r\n        Json数据的解析_Gson            \r\n        "}
{"readCount": "1019", "article": "好久没有写博客了，最近解决了一个令我头疼好久的问题，就是三星手机拍照图片旋转的问题，项目中有上传图片的功能，那么涉及到拍照，从相册中选择图片，别的手机都ok没有问题，唯独三星的手机拍照之后，你会很清楚的看到会把照片旋转一下，然后你根据路径找到的图片就是已经被旋转的了，解决办法终于被我找到了。我们可以根据图片的路径读取照片exif(Exchangeable Image File 可交换图像文件)信息中的旋转角度，至于这个EXIF可以看一下大牛的文章\n\n根据调试，可以清楚的发现三星手机拍照的图片的旋转角度是90度，而别的手机旋转角度是0度", "link": "http://blog.csdn.net/lyhhj/article/details/48995065", "publishDate": "2015-10-09 14:39", "title": "\r\n        Android 三星手机拍照，从图库选择照片旋转问题完美解决            \r\n        "}
{"readCount": "3814", "article": "NaCl的3D渲染API使用的GLES2.0, 这也很好理解, 因为这已经是公认的跨平台标准了. 手机, 平板, 网页, PC都可以使用.\n\n就算在Windows上, 也有一些基于DX9的GLES2.0实现, 比如ANGLE. 有时候我真在想, 像M$这种升级个操作系统版本号就淘汰一种API的做法, 还不如全都使用标准库, 这样也节省了跨平台移植的成本~所以什么DX10/DX11, 还是省省吧\n\n其实从DX9到GLES(本文提到的都是指2.0版本), 大部分只是API换了种写法, 难度不大. 之前有在手机上做过一个简单的GLES渲染器, 有一些差异总结一下吧(不限于NaCl):\n\n比较下来, 也就是Shader部分需要多操点心, 其它都还好, 甚至还强过DX9. 所以, 我有种用ANGLE代替DX9的冲动...", "link": "http://blog.csdn.net/xoyojank/article/details/8172459", "publishDate": "2012-11-12 00:41", "title": "\r\n        从Native到Web(三), NaCl学习笔记: 3D渲染(DX9迁移到GLES)            \r\n        "}
{"readCount": "313", "article": "", "link": "http://blog.csdn.net/fanyun_01/article/details/50618275", "publishDate": "2016-02-01 13:57", "title": "\r\n        机器学习流水线（Machine Learning Pipelines）            \r\n        "}
{"readCount": "31", "article": "有时候我们需要为拍出的照片或者裁剪的图片指定保存路径。那么如何为图片创建保存路径呢？方法有两种：第一种是直接创建url或者file路径。第二种是创建Uri路径。", "link": "http://blog.csdn.net/loveyaozu/article/details/51177277", "publishDate": "2016-04-18 09:45", "title": "\r\n        Android之为图片创建Uri路径            \r\n        "}
{"readCount": "4105", "article": "现在大家都知道用ViewHolder来实现listview的优化了，但是，ViewHolder到底要用什么来修饰呢？这种修饰有什么意义呢？在一个ListView里面，存在多少个VIewHolder实例呢？为什么VIewHolder能够减少findview的次数，优化效率呢？为了弄清楚这个问题，我做了以下测试，测试代码很简单，就是下面这些\n\n\n\n    我简单说一下代码是什么意思，ViewHolder有一个成员变量id，在toString()使用，用来区分不同的ViewHolder，在构造函数中，对id进行赋值，itemId是一个静态变量，每初始化一次就+1，我们可以根据构造函数的打印次数，来计算ViewHolder的实例化次数，根据toString()可以来判断到底是使用了哪一个ViewHolder。getVIew中的写法是固定的，下面是测试结果：\n\nprivate class ViewHolder修饰，界面内可见的item数量是9个，ViewHolder初始化了10次，之后开始复用ViewHolder。\n\nprivate static class ViewHolder修饰，界面内可见的item数量是9个，ViewHolder初始化了10次，之后开始复用ViewHolder。\n\nprivate final class ViewHolder修饰，界面内可见的item数量是9个，ViewHolder初始化了10次，之后开始复用ViewHolder。\n\n其实一上来我就贴一张图就ok了，因为这几种完全一样，不管用什么修饰，ViewHolder都会初始化当前界面可见item的数量+1次，和convertView的实例化次数是一样的，因此，我么不管使用什么修饰都是没问题的，也是没必要的。\n\nstatic修饰类，在这里是静态内部类，并不是说只存在一个实例，而是可以访问外部类的静态变量，final修饰类则是不让该类继承，我们这里使用final毫无根据，所以，以后写ViewHolder的时候，可以不纠结了，加什么加啊，什么都不用加！\n\n今天又请教了公司一个大神，他的回答如下：\n\n这篇文章中没有提到加载时机的问题吧。在我的理解中：静态内部类主要作用就是，内部类是否需要隔离“外部类的this对象（指针）”。内部类是有 this 指针的，可以“直接”访问外部类的 成员变量和成员函数（包括私有的成员）。而静态内部类，没有这个this指针，所以无法“直接”调用。\n\n\n\n个人的习惯，我通常会把内部静态类，作为一个单独的java文件。\n\n\n\n但是Android代码中，却经常使用的Builder，LayoutParams都是以静态内部类的方式存在啊。我们可以根据实际使用情况来效仿。\n\n\n\n另外还要提一点，内部静态类（特别是私有内部静态类），在代码混淆上效果更好。会增加反编译的难度。\n\n\n\n-------------------------------------------------------\n\n对于这篇文章，我理解。ViewHolder的构造和复用，与静不静态没关。核心是ListView（AdapterView），通过getView(int position, View convertView, ViewGroup parent) 的convertView会为开发者传入一个可以复用的对象。开发者需要利用该对象，减少应用内存的消耗。\n\n\n\n\n\n如果从减少内存消耗的角度来开。我认为ViewHolder还是应该修饰成static比较好。这样ViewHolder中可以减少MainActivity的this指针，由于减少了一个this指针的引用，也会对MainActivity的引用计数大大减少。MainActivity的this指针继承于android的Context上下文，对于Context的回收遗漏，是Android内存管理中很大的问题。我们减少了对Context的引用，可以更容易减少Context引用计数出现问题。\n\n", "link": "http://blog.csdn.net/zhaokaiqiang1992/article/details/42740991", "publishDate": "2015-01-15 15:02", "title": "\r\n        【Android开发经验】ViewHolder到底用什么修饰？static？final？static final？            \r\n        "}
{"readCount": "273", "article": "1.在程序中添加一个断点\n\n 如果所示：在Eclipse中添加了一个程序断点\n\n第一种： 在红框区域右键出现菜单后点击第一项 Toggle Breakpoint 将会在你右键代码的哪一行添加一个程序断点 (同样的操作方可取消程序断点)\n\n 第二种： 在红框区域双击鼠标左键将会在你双击代码的哪一行添加一个程序断点 (同样的操作方可取消程序断点)\n\n\n\n 第三种 ：在光标停留的地方使用快捷键 Ctrl + Shift + B 将会在光标停留的这一行添加一个程序断点 (同样的操作方可取消程序断点)\n\n\n\n\n\n 2.运行Debug 调试 让程序停留在添加的断点上\n\n如下图所示，在红框内点击下拉菜单选中需要调试的项目 则开始运行Debug调试 \n\n 如果不在下拉表中选直接点击表示Debug运行默认项目(默认项目为上一次运行的项目)\n\n Debug调试 快捷键为单击F11\n\n\n\n 分析一下如何科学的添加程序断点， 上图中我为了加断点查看生成出来随机数的值我一共添加了6个程序断点，绿框表示最为科学的断点位置 ，红框表示不科学的位置。 我们分析一下为什么， 如果switch case 中的代码片段过长 或者 case 的数量过多 如果采用红框的方式来添加程序断点，程序员须要添加很多程序断点万一有疏漏 所以会很难快速定位代码执行到了那里 ，如果使用绿框的方式添加程序断点，程序员只须要在断点出按 F6 单步跳过这一行代码就会走进正确的case中方便继续调试。\n\n\n\n Debug调试运行后，程序停在了红框处，按F6单步跳过 发现随机数为4 程序停留在了绿框中，程序员可以迅速定位random的值为4 \n\n \n\n \n\n \n\n 蓝框中的内容表示为断点的入口方法， 就好比你的断点是从那个方法进来的，学会看这个真的非常重要， 好比我现在明确知道我的一个方法在被调用的时候方法中会出现错误，但是这个方法在程序中100个地方都在调用，我可能断定实在那里调用的时候出的错误，我不可能在100个调用它的地方都加一个断点，我可以在方法中添加程序断点 然后在篮框中查看程序是从那个地方走进这个方法的，便可以快速定位问题所在。\n\n \n\n 绿框中可以查看当前方法中所有变量的值，但是如果变量非常多在这里看就比较麻烦，可以使用红框的方法查看。\n\n \n\n 红框中可以右键变量名点击咖啡框中的watch 后 在紫框中Expressions 就可以看到变量的数值了。\n\n \n\n BreakPoints 中会记录程序中添加过多少程序断点 。\n\n\n\n \n\n watch 过的变量 和我们自己加的程序断点不会被Eclipse 自动删除 除非我们手动删除否则会一直留在紫框中，这些数值会拖慢Eclipse 开发工具，如果过多的话很可能会造成 Eclipse 崩溃(有可能是Eclipse的BUG)，让开发变得非常痛苦，所以雨松MOMO在这里建议大家在每次Debug调试的时候将紫框中之前 加的程序断点 和 watch过的变量 全不手动清空，只添加这一次调试须要的断点就可以了，这样的话 Eclipse 就不会被这些拖慢进程的东西所导致崩溃。 \n\n \n\n \n\n \n\n 第一步 打开自己的手机在设置中选择应用程序 然后选择开发 然后选中USB调试。\n\n 第二步 用USB线连接手机到电脑，一般情况会自动安装驱动，如果无法安装驱动的话 就去下载一个豌豆荚 或者91助手，让它帮我们手机自动安装驱动 很方便的。\n\n 第三步 驱动安装成功后会在Device中看到真机(红框中) 绿框中为android电脑模拟器 \n\n 运行项目后弹出设备选择窗口 第一个为模拟器 第二个红框内的为我连接电脑的真机 MOTO的里程碑，选择完后点击OK 就可以通过真机来调试程序了，简单吧？是不是很给力呢呵呵。\n\n \n\n \n\n \n\n 本人做过J2ME 开发 Android开发 iPhone开发 发现J2ME 的模拟器 还有Iphone的模拟器都非常给力速度很很快(模拟器比真机快) 唯独android的模拟器 是最不给力的 (真机比模拟器快) 实在是慢的不行 连接上真机可以快一点 但是一样还是慢 尤其是Debug的时候 简直是太不给力了（发点牢骚大家别介意哦 > - <）所以有时候我在开发Android的时候不到万不得已我不去Debug 我会使用Log去打印我须要的数据 下面我教大家如何在Andoid下打印Log信息。希望大家都学会使用log. \n\n   常用的Log有5个：Log.v()Log.d()Log.i() Log.w() Log.e()。\n\n 根据首字母对应VERBOSE，DEBUG,INFO, WARN，ERROR。\n\n 以上这些Log系统都会打印出来。\n\n \n\n 打开LogCat页面发现系统打印了很多Log信息 我们不好定位出刚才自己打的Log，如图所示点击红框内的“+”符号弹出下方窗口后在Filter Name : 和 by Log Tag: (蓝框内)填写我们刚才打的LOG tag \"random\"注意这两项都必需填写 然后单击OK后 方可在绿框中看到我们刚才打的random的Log 。怎么样还是很简单的吧 呵呵。  \n\n 最后附上Eclipse 在开发中使用到的快捷键很实用噢(转载)\n\n   Ctrl+1 快速修复(最经典的快捷键,就不用多说了)\n\n Ctrl+D: 删除当前行 \n\n Ctrl+Alt+↓ 复制当前行到下一行(复制增加)\n\n Ctrl+Alt+↑ 复制当前行到上一行(复制增加)\n\n Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了)\n\n Alt+↑ 当前行和上面一行交互位置(同上)\n\n Alt+← 前一个编辑的页面\n\n Alt+→ 下一个编辑的页面(当然是针对上面那条来说了)\n\n Alt+Enter 显示当前选择资源(工程,or 文件 or文件)的属性\n\n Shift+Enter 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置,不一定是最后)\n\n Shift+Ctrl+Enter 在当前行插入空行(原理同上条)\n\n Ctrl+Q 定位到最后编辑的地方\n\n Ctrl+L 定位在某行 (对于程序超过100的人就有福音了)\n\n Ctrl+M 最大化当前的Edit或View (再按则反之)\n\n Ctrl+/ 注释当前行,再按则取消注释\n\n Ctrl+O 快速显示 OutLine\n\n Ctrl+T 快速显示当前类的继承结构\n\n Ctrl+W 关闭当前Editer\n\n Ctrl+K 参照选中的Word快速定位到下一个\n\n Ctrl+E 快速显示当前Editer的下拉列表(如果当前页面没有显示的用黑体表示)\n\n Ctrl+/(小键盘) 折叠当前类中的所有代码\n\n Ctrl+×(小键盘) 展开当前类中的所有代码\n\n Ctrl+Space 代码助手完成一些代码的插入(但一般和输入法有冲突,可以修改输入法的热键,也可以暂用Alt+/来代替)\n\n Ctrl+Shift+E 显示管理当前打开的所有的View的管理器(可以选择关闭,激活等操作)\n\n Ctrl+J 正向增量查找(按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在stutes line中显示没有找到了,查一个单词时,特别实用,这个功能Idea两年前就有了)\n\n Ctrl+Shift+J 反向增量查找(和上条相同,只不过是从后往前查)\n\n Ctrl+Shift+F4 关闭所有打开的Editer\n\n Ctrl+Shift+X 把当前选中的文本全部变味小写\n\n Ctrl+Shift+Y 把当前选中的文本全部变为小写\n\n Ctrl+Shift+F 格式化当前代码\n\n Ctrl+Shift+P 定位到对于的匹配符(譬如{}) (从前面定位后面时,光标要在匹配符里面,后面到前面,则反之)\n\n \n\n 下面的快捷键是重构里面常用的,本人就自己喜欢且常用的整理一下(注:一般重构的快捷键都是Alt+Shift开头的了)\n\n Alt+Shift+R 重命名 (是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力)\n\n Alt+Shift+M 抽取方法 (这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用)\n\n Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定)\n\n Alt+Shift+L 抽取本地变量( 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候)\n\n Alt+Shift+F 把Class中的local变量变为field变量 (比较实用的功能)\n\n Alt+Shift+I 合并变量(可能这样说有点不妥Inline)\n\n Alt+Shift+V 移动函数和变量(不怎么常用)\n\n Alt+Shift+Z 重构的后悔药(Undo)\n\n \n\n 编辑\n\n 作用域 功能 快捷键 \n\n 全局 查找并替换 Ctrl+F \n\n 文本编辑器 查找上一个 Ctrl+Shift+K \n\n 文本编辑器 查找下一个 Ctrl+K \n\n 全局 撤销 Ctrl+Z \n\n 全局 复制 Ctrl+C \n\n 全局 恢复上一个选择 Alt+Shift+↓ \n\n 全局 剪切 Ctrl+X \n\n 全局 快速修正 Ctrl1+1 \n\n 全局 内容辅助 Alt+/ \n\n 全局 全部选中 Ctrl+A \n\n 全局 删除 Delete \n\n 全局 上下文信息 Alt+？\n\n Alt+Shift+?\n\n Ctrl+Shift+Space \n\n Java编辑器 显示工具提示描述 F2 \n\n Java编辑器 选择封装元素 Alt+Shift+↑ \n\n Java编辑器 选择上一个元素 Alt+Shift+← \n\n Java编辑器 选择下一个元素 Alt+Shift+→ \n\n 文本编辑器 增量查找 Ctrl+J \n\n 文本编辑器 增量逆向查找 Ctrl+Shift+J \n\n 全局 粘贴 Ctrl+V \n\n 全局 重做 Ctrl+Y \n\n \n\n 查看\n\n 作用域 功能 快捷键 \n\n 全局 放大 Ctrl+= \n\n 全局 缩小 Ctrl+- \n\n \n\n 窗口\n\n 作用域 功能 快捷键 \n\n 全局 激活编辑器 F12 \n\n 全局 切换编辑器 Ctrl+Shift+W \n\n 全局 上一个编辑器 Ctrl+Shift+F6 \n\n 全局 上一个视图 Ctrl+Shift+F7 \n\n 全局 上一个透视图 Ctrl+Shift+F8 \n\n 全局 下一个编辑器 Ctrl+F6 \n\n 全局 下一个视图 Ctrl+F7 \n\n 全局 下一个透视图 Ctrl+F8 \n\n 文本编辑器 显示标尺上下文菜单 Ctrl+W \n\n 全局 显示视图菜单 Ctrl+F10 \n\n 全局 显示系统菜单 Alt+- \n\n \n\n 导航\n\n 作用域 功能 快捷键 \n\n Java编辑器 打开结构 Ctrl+F3 \n\n 全局 打开类型 Ctrl+Shift+T \n\n 全局 打开类型层次结构 F4 \n\n 全局 打开声明 F3 \n\n 全局 打开外部javadoc Shift+F2 \n\n 全局 打开资源 Ctrl+Shift+R \n\n 全局 后退历史记录 Alt+← \n\n 全局 前进历史记录 Alt+→ \n\n 全局 上一个 Ctrl+, \n\n 全局 下一个 Ctrl+. \n\n Java编辑器 显示大纲 Ctrl+O \n\n 全局 在层次结构中打开类型 Ctrl+Shift+H \n\n 全局 转至匹配的括号 Ctrl+Shift+P \n\n 全局 转至上一个编辑位置 Ctrl+Q \n\n Java编辑器 转至上一个成员 Ctrl+Shift+↑ \n\n Java编辑器 转至下一个成员 Ctrl+Shift+↓ \n\n 文本编辑器 转至行 Ctrl+L \n\n \n\n 搜索\n\n 作用域 功能 快捷键 \n\n 全局 出现在文件中 Ctrl+Shift+U \n\n 全局 打开搜索对话框 Ctrl+H \n\n 全局 工作区中的声明 Ctrl+G \n\n 全局 工作区中的引用 Ctrl+Shift+G \n\n \n\n 文本编辑\n\n 作用域 功能 快捷键 \n\n 文本编辑器 改写切换 Insert \n\n 文本编辑器 上滚行 Ctrl+↑ \n\n 文本编辑器 下滚行 Ctrl+↓ \n\n \n\n 文件\n\n 作用域 功能 快捷键 \n\n 全局 保存 Ctrl+X \n\n Ctrl+S \n\n 全局 打印 Ctrl+P \n\n 全局 关闭 Ctrl+F4 \n\n 全局 全部保存 Ctrl+Shift+S \n\n 全局 全部关闭 Ctrl+Shift+F4 \n\n 全局 属性 Alt+Enter \n\n 全局 新建 Ctrl+N \n\n \n\n 项目\n\n 作用域 功能 快捷键 \n\n 全局 全部构建 Ctrl+B \n\n \n\n 源代码\n\n 作用域 功能 快捷键 \n\n Java编辑器 格式化 Ctrl+Shift+F \n\n Java编辑器 取消注释 Ctrl+\\ \n\n Java编辑器 注释 Ctrl+/ \n\n Java编辑器 添加导入 Ctrl+Shift+M \n\n Java编辑器 组织导入 Ctrl+Shift+O \n\n Java编辑器 使用try/catch块来包围 未设置，太常用了，所以在这里列出,建议自己设置。\n\n 也可以使用Ctrl+1自动修正。 \n\n \n\n 运行\n\n 作用域 功能 快捷键 \n\n 全局 单步返回 F7 \n\n 全局 单步跳过 F6 \n\n 全局 单步跳入 F5 \n\n 全局 单步跳入选择 Ctrl+F5 \n\n 全局 调试上次启动 F11 \n\n 全局 继续 F8 \n\n 全局 使用过滤器单步执行 Shift+F5 \n\n 全局 添加/去除断点 Ctrl+Shift+B \n\n 全局 显示 Ctrl+D \n\n 全局 运行上次启动 Ctrl+F11 \n\n 全局 运行至行 Ctrl+R \n\n 全局 执行 Ctrl+U \n\n \n\n 重构\n\n 作用域 功能 快捷键 \n\n 全局 撤销重构 Alt+Shift+Z \n\n 全局 抽取方法 Alt+Shift+M \n\n 全局 抽取局部变量 Alt+Shift+L \n\n 全局 内联 Alt+Shift+I \n\n 全局 移动 Alt+Shift+V \n\n 全局 重命名 Alt+Shift+R \n\n 全局 重做 Alt+Shift+Y \n\n 最后还是那句老话雨松MOMO希望可以和大家一起学习与进步，热烈欢迎各类程序达人可以过来和和雨松MOMO交流Android的程序开发。 \n\n", "link": "http://blog.csdn.net/sjz4860402/article/details/20651779", "publishDate": "2014-03-06 20:53", "title": "\r\n        Android 软件开发之如何使用Eclipse Debug调试程序详解（十二）            \r\n        "}
{"readCount": "3161", "article": "SlidingMenu不需要在布局文件中进行排版，直接在需要SlidingMenu的界面进行绑定即可，代码中注释比较多，如有疑问，请留言", "link": "http://blog.csdn.net/zhaokaiqiang1992/article/details/19478159", "publishDate": "2014-02-19 10:37", "title": "\r\n        【Android界面实现】SlidingMenu实现侧滑栏效果            \r\n        "}
{"readCount": "12573", "article": "返回结果并且可能抛出异常的任务。实现者定义了一个不带任何参数的叫做\n\nCallable中的call()方法类似Runnable的run()方法，就是前者有返回值，后者没有。\n\n当将一个Callable的对象传递给ExecutorService的submit方法，则该call方法自动在一个线程上执行，并且会返回执行结果Future对象。\n\n同样，将Runnable的对象传递给ExecutorService的submit方法，则该run方法自动在一个线程上执行，并且会返回执行结果Future对象，但是在该Future对象上调用get方法，将返回null。\n\n遗憾的是，在Java API文档中，这块介绍的很糊涂，估计是翻译人员还没搞清楚的缘故吧。或者说是注释不到位。下面看个例子：\n\njava.util.ArrayList; \n\n java.util.List; \n\n java.util.concurrent.*; \n\n \n\n \n\n CallableDemo { \n\n          main(String[] args) { \n\n                 ExecutorService executorService = Executors.newCachedThreadPool(); \n\n                 List<Future<String>> resultList = ArrayList<Future<String>>(); \n\n \n\n                 \n\n                  ( i = 0; i < 10; i++) { \n\n                          \n\n                         Future<String> future = executorService.submit( TaskWithResult(i)); \n\n                         \n\n                         resultList.add(future); \n\n                 } \n\n \n\n                 \n\n                  (Future<String> fs : resultList) { \n\n                          { \n\n                                 System.out.println(fs.get());     \n\n                         } (InterruptedException e) { \n\n                                 e.printStackTrace(); \n\n                         } (ExecutionException e) { \n\n                                 e.printStackTrace(); \n\n                         } { \n\n                                  //启动一次顺序关闭，执行以前提交的任务，但不接受新任务。如果已经关闭，则调用没有其他作用。 \n\n                                 executorService.shutdown(); \n\n                         } \n\n                 } \n\n         } \n\n } \n\n \n\n \n\n TaskWithResult Callable<String> { \n\n          id; \n\n \n\n          TaskWithResult( id) { \n\n                  .id = id; \n\n         } \n\n \n\n          /** \n\n          * 任务的具体过程，一旦任务传给ExecutorService的submit方法，则该方法自动在一个线程上执行。 \n\n          * \n\n          * @return \n\n          * @throws Exception \n\n          */ \n\n          String call() Exception { \n\n                 System.out.println( + Thread.currentThread().getName()); \n\n                 \n\n                  ( i = 999999; i > 0; i--) ; \n\n                  + id + + Thread.currentThread().getName(); \n\n         } \n\n }\n\n\n\n call()方法被自动调用,干活！！！             pool-1-thread-3 \n\n call()方法被自动调用,干活！！！             pool-1-thread-4 \n\n call()方法被自动调用,干活！！！             pool-1-thread-6 \n\n call()方法被自动调用,干活！！！             pool-1-thread-2 \n\n call()方法被自动调用,干活！！！             pool-1-thread-5 \n\n call()方法被自动调用，任务的结果是：0    pool-1-thread-1 \n\n call()方法被自动调用，任务的结果是：1    pool-1-thread-2 \n\n call()方法被自动调用,干活！！！             pool-1-thread-2 \n\n call()方法被自动调用,干活！！！             pool-1-thread-6 \n\n call()方法被自动调用,干活！！！             pool-1-thread-4 \n\n call()方法被自动调用，任务的结果是：2    pool-1-thread-3 \n\n call()方法被自动调用,干活！！！             pool-1-thread-3 \n\n call()方法被自动调用，任务的结果是：3    pool-1-thread-4 \n\n call()方法被自动调用，任务的结果是：4    pool-1-thread-5 \n\n call()方法被自动调用，任务的结果是：5    pool-1-thread-6 \n\n call()方法被自动调用，任务的结果是：6    pool-1-thread-2 \n\n call()方法被自动调用，任务的结果是：7    pool-1-thread-6 \n\n call()方法被自动调用，任务的结果是：8    pool-1-thread-4 \n\n call()方法被自动调用，任务的结果是：9    pool-1-thread-3 \n\n \n\n Process finished with exit code 0\n\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n call()方法被自动调用,干活！！！             pool-1-thread-1call()方法被自动调用,干活！！！             pool-1-thread-3call()方法被自动调用,干活！！！             pool-1-thread-4call()方法被自动调用,干活！！！             pool-1-thread-6call()方法被自动调用,干活！！！             pool-1-thread-2call()方法被自动调用,干活！！！             pool-1-thread-5call()方法被自动调用，任务的结果是：0    pool-1-thread-1call()方法被自动调用，任务的结果是：1    pool-1-thread-2call()方法被自动调用,干活！！！             pool-1-thread-2call()方法被自动调用,干活！！！             pool-1-thread-6call()方法被自动调用,干活！！！             pool-1-thread-4call()方法被自动调用，任务的结果是：2    pool-1-thread-3call()方法被自动调用,干活！！！             pool-1-thread-3call()方法被自动调用，任务的结果是：3    pool-1-thread-4call()方法被自动调用，任务的结果是：4    pool-1-thread-5call()方法被自动调用，任务的结果是：5    pool-1-thread-6call()方法被自动调用，任务的结果是：6    pool-1-thread-2call()方法被自动调用，任务的结果是：7    pool-1-thread-6call()方法被自动调用，任务的结果是：8    pool-1-thread-4call()方法被自动调用，任务的结果是：9    pool-1-thread-3Process finished with exit code 0////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 因为之前一直是用的execute方法，最近有个情况需要用到submit方法，所以研究了下。 用到返回值的例子，比如说我有很多个做validation的task，我希望所有的task执行完，然后每个task告诉我它的执行结果，是成功还是失败，如果是失败，原因是什么。然后我就可以把所有失败的原因综合起来发给调用者。 意思就是如果你在你的task里会抛出checked或者unchecked exception，而你又希望外面的调用者能够感知这些exception并做出及时的处理，那么就需要用到submit，通过捕获Future.get抛出的异常。 比如说，我有很多更新各种数据的task，我希望如果其中一个task失败，其它的task就不需要执行了。那我就需要catch Future.get抛出的异常，然后终止其它task的执行，代码如下： 51cto上有一篇非常好的文章“Java5并发学习”（http://lavasoft.blog.51cto.com/62575/115112），下面的代码是基于它之上修改的。 \n\n 执行的结果类似于： call()方法被自动调用，任务的结果是： call()方法被自动调用，任务的结果是： 可以看见一旦某个task出错，其它的task就停止执行。\n\n \n\n", "link": "http://blog.csdn.net/yuzhiboyi/article/details/7775266", "publishDate": "2012-07-23 14:34", "title": "\r\n        ExecutorService中submit和execute的区别            \r\n        "}
{"readCount": "1075", "article": "d、自己创建新的线程，然后在新线程中创建Looper，主线程调用子线程中的发消息方法，将消息发给子线程的消息队列。\n\ne、主/子线程均有一个消息队列，然后相互传递消息（这种方式是最灵活的，双向传递，也不复杂）", "link": "http://blog.csdn.net/yuzhiboyi/article/details/7562262", "publishDate": "2012-05-13 14:48", "title": "\r\n        Android之Handler详解（四）            \r\n        "}
{"readCount": "6962", "article": "对Android系统了解的都知道，Android系统有四种基本的数据保存方法，一是SharedPreference，二是文件，三是SQLite,四是ContentProvider。看出来了吧，Preference，对就是使用SharedPreferneces以键值对的形式进行保存的。\n\n做软件开发应该都知道，很多软件会有配置文件，里面存放这程序运行当中的各个属性值，由于其配置信息并不多，如果采用数据库来存放并不划算，因为数据库连接跟操作等耗时大大影响了程序的效率，因此我们使用键值这种一一对应的关系来存放这些配置信息。SharedPreferences正是Android中用于实现这中存储方式的技术。\n\n         SharedPreferences是以键值对的形式存储数据的，其使用非常简单，能够轻松的存放数据和读取数据。\n\n\n\n在具体介绍Android的设置界面的实现之前，我们先来介绍一下预备知识，就是Android数据持久化方法中最简单的一种，即使用Preferences的键值对存储方式。这种方式主要用来存储比较简单的一些数据，而且是标准的Boolean、Int、Float、Long、String等类型。\n\nandroid.content.SharedPreferences是一个接口，用来获取和修改持久化存储的数据。有三种获取系统中保存的持久化数据的方式：\n\n1）. public SharedPreferences getPreferences (int mode)\n\n 通过Activity对象获取，获取的是本Activity私有的Preference，保存在系统中的xml形式的文件的名称为这个Activity的名字，因此一个Activity只能有一个，属于这个Activity。\n\n         2）. public SharedPreferences getSharedPreferences (String name, int mode)\n\n 因为Activity继承了ContextWrapper，因此也是通过Activity对象获取，但是属于整个应用程序，可以有多个，以第一参数的name为文件名保存在系统中。\n\n         3）. public static SharedPreferences getDefaultSharedPreferences (Context context)\n\n PreferenceManager的静态函数，保存PreferenceActivity中的设置，属于整个应用程序，但是只有一个，Android会根据包名和PreferenceActivity的布局文件来起一个名字保存。\n\n         通过以上方式取得SharedPreferences后就可以对数据进行读取或者保存了。\n\n         保存方式如下：\n\n\n\n获得SharedPreferences，如果需要进行保存等修改操作，首先得通过其edit()方法获得SharedPreferences.Editor，然后就可以通过putInt、putString等方法以键值对(key-value)的方式保存数据，或者remove移除某个键(key)，及调用clear方法删除所有内容。最后需要调用commit方法是使修改生效。读取方式如下：\n\n读取就更加简单了，只要获得SharedPreferences后，就可以通过getInt、getString等方法获取对应键(key)保存着的数据，如果没有找到key，则返回第二个参数作为默认值。\n\n在Android开发过程中我们有很大的机会需要用到参数设置功能，那么在Android应用中，我们如何实现参数设置界面及参数存储呢，下面我们来介绍一下Android中的一个特殊Activity–PreferencesActivity。\n\n         PreferencesActivity是Android中专门用来实现程序设置界面及参数存储的一个Activity。\n\n如何创建一个PreferenceActivity。 其实Eclipse提供了相应的创建工具，和创建Layout是基本相同的。步骤如下：\n\n 创建Android项目，并添加一个Android xml文件。注意，这次选择的不是Layout，而是Preference,而且注意Folder路径是 res/xml.\n\n\n\n         添加完成之后，在res/xml/下打开添加的preference.xml文件。可以看到Android也为我们提供两种编辑模式，可视化的结构设计及xml源码设计。推荐使用structure进行创建。如图所示：\n\n\n\n下面我们看看PrefeneceActivity都提供了哪几种元素可供使用。点击Add按钮，在打开的新窗口中可以看到以下几项：\n\n\n\nCheckBoxPreference:CheckBox选择项，对应的值的ture或flase。如图：\n\n\n\nPreferenceScreen:PreferenceActivity的根元素，必须为它。\n\n RingtonePreference：系统玲声选择。\n\n\n\nOK，Preferenc的基本元素介绍完毕，下一节将使用它们创建一个完整的Preference并进行显示。\n\n\n\n分析MusicPlayer Setting，第一部分为“我的位置”，包括“使用无线网线”和“使用GPS”两个部分，而且都是CheckBox，根据上节学习，应该包括一个PreferenceCategory和两个CheckBoxPreference。\n\n Xml代码\n\n\n\n以上代码当然也可以用Android提供的IDE工具直接生成。视频结构如下：\n\nPreferenceCategory属性分析：\n\n          title:显示的标题\n\n          key：唯一标识（至少在同一程序中是唯一），SharedPreferences也将通过此Key值进行数据保存,也可以通过key值获取保存的信息 (以下相同）。\n\n CheckBoxPreference属性分析：\n\n         Key：唯一标识.\n\n         title：显示标题（大字体显示）\n\n        summary:副标题（小字体显示）\n\n        defaultValue:默认值（当然，此处只能是true或false了)\n\n Preference.xml的第二部分为“无线和网络设置”，此部分包括的内容比较多，也稍微复杂，一步一步来分析。\n\n xml代码：\n\n第二部分中前三个都为CheckBoxPreference，不心多说，从<Preference android:key=\"bluetooth_setting\"/>开始。\n\n Preference属性分析：\n\n        Key：唯一标识.\n\n         title：显示标题（大字体显示）\n\n        summary:副标题（小字体显示）\n\n      dependency：附属（嘛意思），即标识此元素附属于某一个元素（通常为CheckBoxPreference)，dependency值为所附属元素的key。上面代码中的Preference元素附属于key等于“apply_bluetooth”的CheckPreference元素，当CheckPreference值为true时，Preference则为可用，否则为不可用。\n\n EditTextPreperence属性分析：\n\n     Key：唯一标识.\n\n      title：显示标题（大字体显示）\n\n ListPreference属性分析：\n\n    Key：唯一标识.\n\n    title：显示标题（大字体显示）\n\n   dialogTitle：弹出对话框的标题\n\n  entries：列表中显示的值。为一个数组，通读通过资源文件进行设置。\n\n entryValues：列表中实际保存的值，也entries对应。为一个数组，通读通过资源文件进行设置。以下代码显示的是arrays.xml文件中内容：\n\n点击“Add”按钮，就会添加新的标签，我们依次添加一个CheckBoxPreference和ListPreference。属于CheckBoxPreference的特有属性主要为Summary On和Summary Off，比较好理解。下面具体来看下ListPreference属性的填写：\n\n\n\n我们可以看到，ListPreference除了继承自Preference的属性外，还有自己ListPreference的属性和继承自DialogPreference的属性。其中属于ListPreference的属性有两个：Entries填的为一个字符串数组，是列表显示出来的值，而Entry Values是长度对应的字符串数组，是和Entries对应的具体的值。DialogPreference只要填一个Dialog title标题和一个取消按钮显示的字即可。在Preference属性的Dependency中我们填写上面一个CheckBoxPreference的Key，这样就会只有在CheckBoxPreference勾选时这个ListPreference才有效。\n\n\n\nRingtonePreference ：玲声（暂时没有用到过），暂时略过。\n\n         OK,Preference.xml内容已经分析完毕，属性都大致相同，相信亲自动力一试也就那么回事。那么如何把Preference.xml中内容展现出来呢？\n\n Layout是通过继续自Activity的类来进行显示的，前面提到过，PreferenceActivity是专门用于显示preference的，所以只要创建一个继承自PreferenceActivity类即可。代码如下：\n\n接下来就是运行程序，显示劳动成果。至此，工作已经完成大半，所有的值都会保存到SharedPreferences中，我们也可以读取到保存的结果。\n\n\n\n研究了一天，貌似ListPreference中根本就没有什么回调函数可以用\n\n 于是，向上一层，把注意力集中于SharedPreferences，\n\n 发现有这么个接口：onSharedPreferenceChanged\n\n 抱着试试看的态度，实现了该接口，发现此方法可行，先将部分代码分享如下：\n\n\n\n实际上，使用如下方法也是可以得到值的：\n\n以上我们分别介绍了Preference对数据的保存及PreferenceActivity设置界面。当PreferenceActivity中的内容改变时，Android系统会自动进行保存和持久化维护，我们只需要在要用的设置界面中数据的地方进行读取就可以了。同时Android还提供了OnPreferenceClickListener和OnPreferenceChangeListener两个与Preference相关的监听接口，当PreferenceActivity中的某一个Preference进行了点击或者改变的操作时，都会回调接口中的函数，这样可以第一个时间向其他Activity等通知系统设置进行了改变。\n\n         下面我们以一个具体的Demo说明PreferenceActivity和其监听接口的使用。\n\n         新建一个工程AndroidPreferenceDemoII，并按上面的步骤添加xml文件夹和其内容Preferenceii.xml，还有values文件夹中的array.xml和strings.xml。\n\n         新建一个名为Settings的class，内容为：\n\n\n\n当然重写PreferenceActivity的 onPreferenceTreeClick的方法就可以了，通过参数preference来判断是对那一个元素进行的，并根据需要进行操作。\n\n两种监听器OnPreferenceChangeListener和OnPreferenceClickListener，OnPreferenceClickListener的意思好理解，但是OnPreferenceChangeListener就不好懂了，所以就写了个Demo分析了一下，代码如下：\n\n程序原理：用一个ListPreference分别注册这两个监听器，然后用Tosat看他们在什么时候响应。../res/xml/preference文件如下：\n\n以下是ListPreference的Entries和EntryValues：\n\n编译好，运行程序：点击mList1Prefs(来电时),Toast显示“-1”。再点击一个选项，对话框消失，Toast显示“-1”，为什么会这样？为什么不是第一次选中时的选项值？\n\n         其实，这是因为设置了OnPreferenceChangeListener。默认情况下，普通的ListPreference第一次选中一个值之后，Android框架会存贮好选中的值，下次打开，会默认选中上次选中的值，但是设置OnPreferenceChangeListener之后，值的存储就要自己来了，详见代码中的mList2Prefs.setValue();“来短信时”这一项就能够正常存贮选中的值。\n\n         现在区别就出来了：\n\n OnPreferenceClickListener：是响应点击preference的事件，比如程序中，一点ListPreference，onPreferenceClick()中就弹出Toast。\n\n OnPreferenceChangeListener：是响应preference的值被改变的事件（此时被改变的值需要自己存贮到SharedPreferences） ，比如程序中，点击ListPreference的某一项，onPreferenceChange()中就会弹出Toast。\n\n         另外：onPreferenceTreeClick（）这个方法感觉和OnPreferenceClickListener的回调方法onPreferenceClick（）的作用差不多，一样是响应点击的事件。\n\n         回头再看OnPreferenceChangeListener的文档：\n\n Interface definition for a callback to be invoked when the value of this Preference has been changed by the user and is about to be set and/or persisted. This gives the client a chance to prevent setting and/or persisting the value.\n\n\n\n在android项目中添加一个 android xml 文件需要注意的是这次选择的是 Preference。而不是以往的Layout\n\n这个文件是保存在 res /xml 路径下的。\n\npreference下的View是有限的，只有下面几个：\n\nandroid:key 唯一标识符。它对应保存的XML保存的配置文件中的节点的 name属性", "link": "http://blog.csdn.net/yuzhiboyi/article/details/7676293", "publishDate": "2012-06-19 13:36", "title": "\r\n        Android的SharedPreferences和PreferenceActivity用法            \r\n        "}
{"readCount": "927", "article": "“玩转BealgeBoard xM——试水Android 4.0 ICS”一文中采用Rowboat项目prebuilt好的Image文件，成功地在BeagleBoard上完成了Android系统的启动。但prebuilt的Image无法根据自己的需要进行修改和定制，比如增加一些特定的设备驱动，修改rootfs加载方式等。因此，最好的方法还是在Rowboat项目提供的source code的基础上，一步步完成系统的配置和编译，实现系统的完全定制。\n\n下面是本人在bb xm上定制Android 4.0 ICS的完整过程：\n\nAndroid源码通过分布式版本管理软件Git进行管理。Android开源软件项目组使用Python编写了Repo脚本，用于更好地使用和管理Android软件仓库。下面是使用Repo下载Android源码的过程。\n\n1、在用户的Home目录下创建一个bin目录，并设置环境变量：\n\nexport PATH=~/bin:$PATH（也可以将该命令添加到~/.bashrc脚本文件中，以便每次登录系统时自动设置好该环境变量）\n\n并将其修改为可执行：", "link": "http://blog.csdn.net/cpuabc/article/details/7831130", "publishDate": "2012-08-04 22:58", "title": "\r\n        玩转BeagleBoard xM——通过Repo下载Android 4.0 ICS源码            \r\n        "}
{"readCount": "1164", "article": "博主：在网上查找关于Android Init源码分析和启动流程的文章时，发现这篇博文。这篇博文对Android init.c分析得非常仔细深入，值得学习。特此感谢原文作者的贡献。\n\n前言\n\n Android系统是运作在linux kernal上的，因此它的启动过程也遵循linux的启动过程，当linux内核启动之后，运行的第一个进程是init，这个进程是一个守护进程，它的生命周期贯穿整个linux内核运行的始终， linux中所有其他的进程的共同始祖均为init进程。当然为了启动并运行整个android系统，google实现了自己的init进程，下面主要分析init进程都做了些什么？\n\n \n\n 1.首先，init是一个守护进程，为了防止init的子进程成为僵尸进程(zombieprocess)，需要init在子进程在结束时获取子进程的结束码，通过结束码将程序表中的子进程移除，防止成为僵尸进程的子进程占用程序表的空间，当程序表的空间达到上限时，则系统就不能再启动新的进程了，那么就会引起很严重的系统问题。\n\n     在linux当中，父程序是通过捕捉SIGCHLD信号来得知子进程结束的情况的；由于系统默认在子进程暂停时也会发送信号SIGCHLD，init需要忽略子进程在暂停时发出SIGCHLD信号，因此将act.sa_flags置为SA_NOCLDSTOP，该标志位的含义是就是要求系统在子进程暂停时不发送SIGCHLD信号。具体的代码如下所示：\n\n    struct sigaction act;\n\n    ………………\n\n    act.sa_handler = sigchld_handler;\n\n    act.sa_flags = SA_NOCLDSTOP;\n\n    act.sa_mask = 0;\n\n    act.sa_restorer = NULL;\n\n    sigaction(SIGCHLD, &act, 0);\n\n \n\n 2.创建文件系统目录并挂载相关的文件系统\n\n \n\n    /* clear the umask */\n\n    umask(0);\n\n \n\n        /* Get the basic filesystem setup we need put\n\n         * together in the initramdisk on / and then we'll\n\n         * let the rc file figure out the rest.\n\n         */\n\n    mkdir(\"/dev\", 0755);\n\n    mkdir(\"/proc\", 0755);\n\n    mkdir(\"/sys\", 0755);\n\n \n\n    mount(\"tmpfs\", \"/dev\", \"tmpfs\", 0,\"mode=0755\");\n\n    mkdir(\"/dev/pts\", 0755);\n\n    mkdir(\"/dev/socket\", 0755);\n\n    mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL);\n\n    mount(\"proc\", \"/proc\", \"proc\", 0, NULL);\n\n    mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL);\n\n \n\n 2.1 清除屏蔽字(file modecreation mask)，保证新建的目录的访问权限不受屏蔽字影响.\n\n \n\n 2.2 在init初始化过程中，Android分别挂载了tmpfs，devpts，proc，sysfs 4类文件系统\n\n \n\n 2.2.1 tmpfs文件系统\n\n    tmpfs是一种虚拟内存文件系统，因此它会将所有的文件存储在虚拟内存中，并且tmpfs下的所有内容均为临时性的内容，如果你将tmpfs文件系统卸载后，那么其下的所有的内容将不复存在。\n\n    tmpfs有些像虚拟磁盘（ramdisk），但不是一回事。说其像虚拟磁盘，是因为它可以使用你的RAM，但它也可以使用你的交换分区。传统的虚拟磁盘是一个块设备，而且需要一个mkfs之类的命令格式化它才能使用。tmpfs是一个独立的文件系统，不是块设备，只要挂接，立即就可以使用。\n\n    tmpfs的大下是不确定的，它最初只有很小的空间，但随着文件的复制和创建，它的大小就会不断变化，换句话说，它会根据你的实际需要而改变大小；tmpfs的速度非常惊人，毕竟它是驻留在RAM中的，即使用了交换分区，性能仍然非常卓越；由于tmpfs是驻留在RAM的，因此它的内容是不持久的，断电后，tmpfs的内容就消失了，这也是被称作tmpfs的根本原因。\n\n     关于tmpfs文件系统请参考linux内核文档：kernel/Documentation/filesystems/tmpfs.txt\n\n \n\n 2.2.2 devpts文件系统   \n\n    devpts文件系统为伪终端提供了一个标准接口，它的标准挂接点是/dev/pts。只要pty的主复合设备/dev/ptmx被打开，就会在/dev/pts下动态的创建一个新的pty设备文\n\n 件。\n\n 2.2.3 proc文件系统\n\n    proc文件系统是一个非常重要的虚拟文件系统，它可以看作是内核内部数据结构的接口，通过它我们可以获得系统的信息，同时也能够在运行时修改特定的内核参数。\n\n     在proc文件系统中，你可以修改内核的参数，是不是很强大？怎么修改呢?你只需要echo一个新的值到对应的文件中即可，但是如果在修改过程中发生错误的话，那么你将别无选择，只能重启设备。\n\n     \n\n     关于proc文件系统请参考linux内核文档：  kernel/Documentation/filesystems/proc.txt\n\n 2.2.4 sysfs文件系统\n\n     与proc文件系统类似，sysfs文件系统也是一个不占有任何磁盘空间的虚拟文件系统。它通常被挂接在/sys目录下。sysfs文件系统是Linux2.6内核引入的，它把连接在系统上的设备和总线组织成为一个分级的文件，使得它们可以在用户空间存取。\n\n \n\n 3.屏蔽标准的输入输出，即标准的输入输出定向到NULL设备。\n\n     这一步是通过调用函数open_devnull_stdio实现的，下面我们研究一下open_devnull_stdio的函数实现\n\n voidopen_devnull_stdio(void)\n\n {\n\n     int fd;\n\n     static const char *name = \"/dev/__null__\";\n\n //创建一个字符专用文件(character special  file) /dev/__null__\n\n     if (mknod(name, S_IFCHR | 0600, (1 << 8) | 3) == 0) {\n\n //获取/dev/__null__的文件描述符，并输出该文件\n\n         fd = open(name, O_RDWR);\n\n         unlink(name);\n\n //将与进程相关的标准输入(0),标准输出(1),标准错误输出(2)，均定向到NULL设备\n\n         if (fd >= 0) {\n\n             dup2(fd, 0);\n\n             dup2(fd, 1);\n\n             dup2(fd, 2);\n\n             if (fd > 2) {\n\n                 close(fd);\n\n             }\n\n            return;\n\n        }\n\n     }\n\n \n\n    exit(1);\n\n }\n\n 这里解释一下\n\n            dup2(fd, 0);\n\n            dup2(fd, 1);\n\n            dup2(fd, 2);\n\n 过程：\n\n 首先说明以下dup2的作用，这个函数主要是复制一个函数的描述符，一般用于重定向进程的stdin，stdout，stderr。它的原型如下：\n\n int dup2(int oldfd,int newfd);\n\n            dup2(fd, 0);\n\n            dup2(fd, 1);\n\n            dup2(fd, 2);\n\n 这三次调用一次将依次代表stdin，stdout，stderr的描述符0，1，2，重定向到dev/null,通过这种方式达到屏蔽标准输入输出的作用。\n\n 4. 初始化内核log系统\n\n     这个过程对应的源码为：\n\n log_init();\n\n 这个函数详细实现为\n\n void log_init(void)\n\n {\n\n     static const char *name = \"/dev/__kmsg__\";\n\n     if (mknod(name, S_IFCHR | 0600, (1 << 8) | 11) == 0) {\n\n         log_fd = open(name, O_WRONLY);\n\n //当进程在进行exec系统调用时，要确保log_fd是关闭的(通过FD_CLOEXEC标志位来设置).\n\n         fcntl(log_fd, F_SETFD, FD_CLOEXEC);\n\n         unlink(name);\n\n     }\n\n }\n\n 有上述实现看出内核的log输出是通过文件描述符log_fd写入的，那到底写入到什么设备呢？/dev/kmsg，这个设备则会把它收到的任何写入都作为printk的输出。printk函数是内核中运行的向控制台输出显示的函数。\n\n \n\n \n\n 5.解析init.rc\n\n \n\n 5.1 Android initlanguage\n\n \n\n    Android init language包含四种类型语句:Actions, Commands, Services, Options。\n\n 它的主要语法风格为:\n\n    1.每一个语句占据一行，所有关键字通过空格来分割。\n\n    2.c语言风格的反斜杠(/)将被转义为插入一个空格；\n\n    3.如果一个关键字含有一个或多个空格，那么怎么保证关键字完整呢？可以使用双引号来确定关键字的范围。\n\n    4.用于行尾的反斜杠表示续行符。\n\n    5.Actions和Services声明一个字段(section)，紧随其后的Commands和Options均属于这个字段，在第一个字段之前的Commands和Options的没有意义。\n\n    6.Actions和Services有独一无二的名字，如果Actions和Services的名字有重名，那么将被视作错误。\n\n \n\n 5.1.1 Actions\n\n    Actions其实就是一组被命名的Commands序列。当满足触发器的事件发生时，这个action就会被置于一个队列中，这个队列存放着将要被执行的action。其格式如下：\n\n    on <trigger>\n\n          <command>\n\n          <command>\n\n          <command>\n\n    on是Actions的关键字，它表明下面的序列是Actions序列。\n\n \n\n 5.1.2 Services\n\n    Services是有init进程启动的或者重新启动的程序。其格式如下：\n\n    service <name> <pathname> [ <argument> ]*\n\n          <option>\n\n          <option>\n\n \n\n 5.1.3 Options\n\n    Options是Services的修饰符，由它来指定何时并且如何启动Services程序。\n\n \n\n 5.1.4 Commands\n\n    Commands即是在满足triger条件后，Actions中执行的内容。\n\n \n\n Options和Commands的取值在这里就不描述里，有兴趣请参考system/core/rootdir/init.rc\n\n \n\n 5.2 init.rc解析过程\n\n     我们继续回到init.c的main函数中，看init.rc的解析过程。init文件有两个init.rc和init.hardware.rc。\n\n \n\n    init_parse_config_file(\"/init.rc\");//解析init.rc\n\n \n\n    /* pull the kernel commandline and ramdisk properties file in */\n\n    import_kernel_cmdline(0);//从/proc/cmdline读取内核启动参数，并保存到相应的变量中\n\n \n\n    get_hardware_name(hardware, &revision);//从/proc/cpuinfo中获取硬件信息\n\n    snprintf(tmp, sizeof(tmp), \"/init.%s.rc\", hardware);\n\n    init_parse_config_file(tmp);//解析硬件相关的init信息\n\n \n\n     着重介绍一下init_parse_config_file过程，这个函数负责init文件的解析。\n\n \n\n    1.首先判断关键字，只能有两种可能on或者service，通过关键字来判定section范围；\n\n    2.根据Actions和Services的格式对section进行逐行解析；\n\n    3.将解析出的内容存放到双向循环链表中。\n\n \n\n     解析过程中的双向循环链表的使用，android用到了一个非常巧妙的链表实现方法，一般情况下如果链表的节点是一个单独的数据结构的话，那么针对不同的数据结构，都需要定义不同链表操作。\n\n     而在初始化过程中使用到的链表则解决了这个问题，它将链表的节点定义为了一个非常精简的结构，只包含前向和后向指针，那么在定义不同的数据结构时，只需要将链表节点嵌入到数据结构中即可。\n\n     例如，链表节点定义如下，\n\n    struct listnode\n\n     {\n\n         struct listnode *next;\n\n         struct listnode *prev;\n\n     };\n\n \n\n     数据结构的定义如下，拿Action的数据结构为例，\n\n \n\n    struct action {\n\n         /* node in list of all actions */\n\n         struct listnode alist;\n\n         /* node in the queue of pending actions */\n\n         struct listnode qlist;\n\n         /* node in list of actions for a trigger */\n\n         struct listnode tlist;\n\n \n\n         unsigned hash;\n\n         const char *name;\n\n         \n\n         struct listnode commands;\n\n         struct command *current;\n\n     };\n\n \n\n     这样的话，所有的链表的基本操作，例如插入，删除等只会针对listnode进行操作，而不是针对特定的数据结构，如action进行操作，那么在多个数据结构使用双向链表时，链表的实现得到了统一，即精简了代码，又提高了效率。\n\n     但是这样的链表实现，存在一个问题，链表节点listnode中只有前向和后向指针，并且前向和后向指针均指向listnode，那么我们通过什么方式来访问数据结构action的内容呢？\n\n     在这里引入了一个宏offsetof，我们man一下这个宏的的定义，发现这个宏是结构体中成员变量的偏移量。这下大家心里是不是已经意识到怎么访问数据结构action了吧，对！就是计算链表节点在数据结构中的偏移量，来计算数据结构实例的地址。\n\n \n\n    Android的init过程是通过下面的宏定义来实现的，\n\n #definenode_to_item(node, container, member) /\n\n    (container *) (((char*) (node)) - offsetof(container, member))\n\n \n\n     小结一下这种链表的优点：(1)所有链表基本操作都是基于listnode指针的，因此添加类型时，不需要重复写链表基本操作函数(2)一个container数据结构可以含有多个listnode成员，这样就可以同时挂到多个不同的链表中。\n\n \n\n 5.3 Actions待执行队列\n\n     当解析完所有的init.rc内容之后，在执行这些action之前，需要按顺序将其置于一个待执行队列中，如\n\n        action_for_each_trigger(\"early-init\",action_add_queue_tail);\n\n \n\n     还有一些没有在init.rc中定义的action，相比init.rc，这些action的共同点是没有参数，如\n\n    queue_builtin_action(wait_for_coldboot_done_action,\"wait_for_coldboot_done\");\n\n \n\n \n\n     下面我们分析一下init中的Actions待执行队列的顺序以及功能\n\n \n\n \n\n    action_for_each_trigger(\"early-init\", action_add_queue_tail);\n\n    queue_builtin_action(wait_for_coldboot_done_action, \"wait_for_coldboot_done\");\n\n \n\n    queue_builtin_action(property_init_action, \"property_init\");\n\n    queue_builtin_action(keychord_init_action, \"keychord_init\");\n\n    queue_builtin_action(console_init_action, \"console_init\");\n\n    queue_builtin_action(set_init_properties_action,\"set_init_properties\");\n\n \n\n        /* execute all the boot actions to get us started */\n\n    action_for_each_trigger(\"init\", action_add_queue_tail);\n\n    action_for_each_trigger(\"early-fs\", action_add_queue_tail);\n\n    action_for_each_trigger(\"fs\", action_add_queue_tail);\n\n    action_for_each_trigger(\"post-fs\", action_add_queue_tail);\n\n \n\n    queue_builtin_action(property_service_init_action,\"property_service_init\");\n\n    queue_builtin_action(signal_init_action, \"signal_init\");\n\n    queue_builtin_action(check_startup_action, \"check_startup\");\n\n \n\n    /* execute all the boot actions to get us started */\n\n    action_for_each_trigger(\"early-boot\", action_add_queue_tail);\n\n    action_for_each_trigger(\"boot\", action_add_queue_tail);\n\n \n\n        /* run all property triggers based on current state of the properties */\n\n    queue_builtin_action(queue_property_triggers_action,\"queue_propety_triggers\");\n\n \n\n \n\n #if BOOTCHART\n\n    queue_builtin_action(bootchart_init_action, \"bootchart_init\");\n\n #endif    \n\n \n\n 5.3.1 early-init\n\n     查看init.rc中的相应字符段为\n\n    start ueventd\n\n     这个action主要目的是通过early-init启动ueventd服务，这个服务负责uevent(userspace event)的处理，uevent是内核向用户空间发出的一个时间通知，使应用程序能够有机会对该event做出反应。\n\n \n\n 5.3.2wait_for_coldboot_done\n\n    android 冷过程结束后会生成dev/.coldboot_done文件，wait_for_coldboot_done这个action会等待dev/.coldboot_done文件的生成，等待时长为5s。当然这个action不会阻塞android的冷启动过程，它会没查询一次就会休眠0.1s，直到冷启动结束。\n\n \n\n 5.3.3 property_init\n\n     几种特殊的属性：\n\n    1.ro.属性，它表示只读属性，它一旦被设置就不能被修改；\n\n    2.net.属性，顾名思义，就是与网络相关的属性，net.属性中有一个特殊的属性：net.change，它记录了每一次最新设置和更新的net.属性，也就是每次设置和更新net.属性时则会自动的更新net.change属性，net.change属性的value就是这个被设置或者更新的net属性的name。例如我们更新了属性net.bt.name的值，由于net有属性发生了变化，那么属性服务就会自动更新net.change，将其值设置为net.bt.name。\n\n    3.persist.属性，以文件的形式保存在/data/property路径下。persist.属性由于将其保存在了用户空间中，所以在property_init中是不能对其更新的，只能将其更新过程交给用户来处理。\n\n    4.ctl.属性，虽然是以属性的形式来进行设置，其实它的目的是为了启动或关闭它指定的service\n\n     初始化android的属性系统，整个的过程分为下面2步\n\n    1.初始化属性区域(property area)，主要工作是将属性设备节点/dev/properties映射到内存空间上，将整个的属性内容作为共享内存来处理，这个共享内存就是属性区域,当前android中使用全局变量__system_property_area__来标记属性区域。\n\n    2.加载并设置/default.prop中定义的属性，default.prop中主要是一些“ro.”只读属性。\n\n \n\n 5.3.4 keychord_init\n\n     这个东东不是太理解，目前的所有service均未用到这个机制。\n\n \n\n 5.3.5 console_init\n\n    1.如果/proc/cmdline指定了控制台终端，那么优先使用这个控制台，如果没有指定，那么将使用默认控制台终端/dev/console。\n\n    2.加载开机图片,参考load_565rle_image函数\n\n    a,通过ioctl函数修改dev/tty0(即终端控制台)为图像显示模式；\n\n    b,尝试打开/initlogo.rle,如果失败，那么将dev/tty0恢复为文本显示模式，则开机时显示\"ANDROID\"文字；\n\n    c,如果打开/initlogo.rle成功，那么init将会打开Framebuffer，下面我们分析一下这个过程\n\n        //logo.c\n\n        static int fb_open(struct FB *fb)\n\n        {\n\n            //打开Framebuffer对应的设备文件/dev/graphics/fb0   \n\n            fb->fd =open(\"/dev/graphics/fb0\", O_RDWR);\n\n            if (fb->fd < 0)\n\n            return -1;\n\n            //通过ioctl函数获得Framebuffer相关信息\n\n            //FBIOGET_FSCREENINFO对应的是Framebuffer的固定信息\n\n            //FBIOGET_VSCREENINFO对应的是Framebuffer的可变信息   \n\n            if (ioctl(fb->fd, FBIOGET_FSCREENINFO,&fb->fi) < 0)\n\n            goto fail;\n\n            if (ioctl(fb->fd, FBIOGET_VSCREENINFO,&fb->vi) < 0)\n\n            goto fail;\n\n            //由于Framebuffer是可以被用户直接读写的，所以需要将/dev/graphics/fb0映射到用户空间的内存区。\n\n            fb->bits = mmap(0, fb_size(fb),PROT_READ | PROT_WRITE,\n\n                   MAP_SHARED, fb->fd, 0);\n\n            if (fb->bits == MAP_FAILED)\n\n            goto fail;\n\n \n\n            return 0;\n\n \n\n        fail:\n\n            close(fb->fd);\n\n            return -1;\n\n        }\n\n        d,将initlogo.rle数据写到Framebuffer中。\n\n \n\n     目前android默认是没有initlogo.rle，如果想自己添加开机图片的话，具体过程请参考http://www.cnmsdn.com/html/201005/1274855679ID5109.html\n\n \n\n 5.3.6set_init_properties\n\n     设置与硬件载频相关的只读属性。\n\n \n\n 5.3.7 init\n\n     执行init.rc中init action字段中定义的处理。init.rc中的actions就不再一一分析了，有兴趣或者有时间在分析。\n\n \n\n 5.3.8property_service_init\n\n    1.读取/system/build.prop，/system/default.prop，/data/local.prop以及/data/property/下的属性并将其设置；\n\n    2.创建一个服务器端UNIX Domain Socket，它的socket文件路径为/dev/socket/property_service，这个socket监听来自客户端的属性修改请求.\n\n \n\n 5.3.9 signal_init\n\n    1.\n\n    2.通过socketpair创建一对已连接的socket，将生成的两个socket设置为O_NONBLOCK模式，也就是将对socket句柄的读写操作设置为非阻塞模式。\n\n \n\n \n\n 5.3.10 check_startup\n\n     确保5.3.8中属性设置socket文件描述符和signal_init中signalsocket文件描述符，如果两个有其一不存在，那么将退出系统。\n\n \n\n 5.3.11 boot\n\n    boot action主要由两部分组成，\n\n    1. 还是一些配置性的工作，例如基本的网络配置；ActivityManagerService中用到的进程管理和资源回收时，需要用到的优先级变量的设置等。\n\n    2. 启动所有init.rc声明的未指定class的service；\n\n     具体的command为class_start default。\n\n     在解析init.rc时，如果service未指定class选项的话，那么会给它的classname默认的指定为“default”，而目前的init.rc中的所有的service均未指定class选项，所以命令“class_startdefault”将按顺序启动所有的service。\n\n     也可以为需要一起启动，一起关闭的services指定一个相同的class，那么就可以对这些service进行统一处理了。\n\n     还需注意：如果service中定义了disabled选项，那么不能通过class_start来启动它，只能显示的一个一个的启动。被disabled修饰的service一般是在\n\n \n\n 5.3.12queue_propety_triggers\n\n     根据init.rc中action指定的property值与属性中的值比较，如果相等则执行对应的command。例如\n\n    on property:ro.secure=0\n\n        start console\n\n     如果当前ro.secure的值为0，那么启动console服务\n\n \n\n 5.3.13bootchart_init\n\n    Bootchart 能够对系统的性能进行分析，并生成系统启动过程的图表，以便为你提供有价值的参考信息。综合所得的信息，你就可以进行相应的改进，从而加快你的 Linux 系统启动过程。\n\n     如果设置了Bootchart，则该过程初始化Bootchart。\n\n \n\n 5.4 init轮询过程\n\n     以上部分将所有需要操作的action均放在了action待执行队列中，那么init进程将要进入一个死循环过程，整个android的将会运行在这个生命周期内。\n\n \n\n    1.执行action待执行队列中的所有command；\n\n    2.重启所有需要重启的service；\n\n    3.注册属性设置property_set_fd，信号signal处理signal_recv_fd，keychordkeychord_fd三个文件描述符的为轮询对象。\n\n    if (!property_set_fd_init && get_property_set_fd() > 0) {\n\n             ufds[fd_count].fd = get_property_set_fd();\n\n             ufds[fd_count].events = POLLIN;\n\n             ufds[fd_count].revents = 0;\n\n             fd_count++;\n\n             property_set_fd_init = 1;\n\n         }\n\n        if (!signal_fd_init && get_signal_fd() > 0) {\n\n             ufds[fd_count].fd = get_signal_fd();\n\n             ufds[fd_count].events = POLLIN;\n\n             ufds[fd_count].revents = 0;\n\n             fd_count++;\n\n             signal_fd_init = 1;\n\n         }\n\n        if (!keychord_fd_init && get_keychord_fd() > 0) {\n\n             ufds[fd_count].fd = get_keychord_fd();\n\n             ufds[fd_count].events = POLLIN;\n\n             ufds[fd_count].revents = 0;\n\n             fd_count++;\n\n             keychord_fd_init = 1;\n\n         }\n\n     \n\n     有以上代码可见，init进程将三个描述符均定义为了POLLIN事件响应，当描述符有可读数据时，对于socket描述符，有连接请求时ufds就会收到POLLIN事件。\n\n \n\n     \n\n    4.下面分别对这3个文件描述符的轮询过程作简单的介绍\n\n        nr = poll(ufds, fd_count, timeout);\n\n        if (nr <= 0)\n\n            continue;\n\n \n\n        for (i = 0; i < fd_count; i++) {\n\n             if (ufds[i].revents == POLLIN) {\n\n                 if (ufds[i].fd == get_property_set_fd())\n\n                     handle_property_set_fd();\n\n                 else if (ufds[i].fd == get_keychord_fd())\n\n                     handle_keychord();\n\n                 else if (ufds[i].fd == get_signal_fd())\n\n                     handle_signal();\n\n             }\n\n        }\n\n     上面的代码为轮询的总体体现，当有POLLIN事件发生时，相应的ufds[i].revents就会被置为POLLIN，然后执行各自的handler\n\n    A，property_set_fd\n\n     收到属性设置的socket请求之后，设置相关属性。           \n\n \n\n    B，signal_recv_fd\n\n     当有子进程终止时，也就是service终止时，内核会给init发送SIGCHLD，此时调用注册的handler函数\n\n    static void sigchld_handler(int s)\n\n     {\n\n         write(signal_fd, &s, 1);\n\n     }\n\n        这个handler函数是向其中的一个socket signal_fd写入数据，由于signal_init过程中初始化了一对已连接的socketsignal_fd和signal_recv_fd，因此此时signal_recv_fd会收到向signal_fd写入的数据，然后查询那个service终止，然后根据该service的属性来作相关的操作，是重启还是结束进行资源回收。\n\n \n\n    C，keychord_fd\n\n     目前的init过程中没有service执行keychord机制。", "link": "http://blog.csdn.net/cpuabc/article/details/7867915", "publishDate": "2012-08-15 10:18", "title": "\r\n        深入Android内核——Android init.c源码深入分析            \r\n        "}
{"readCount": "206", "article": "2.在安装SDK的源文件中新建sources文件。把刚现在到的android...jar文件解压放到sources文件中。", "link": "http://blog.csdn.net/sjz4860402/article/details/23267549", "publishDate": "2014-04-09 14:36", "title": "\r\n        eclipse查看android源码            \r\n        "}
{"readCount": "1250", "article": "top一下，是否发现Linux系统的可用内存越来越少？需要重启系统才能释放内存吗？有一招简单的手动释放内存的方法，写个简单的脚本程序，实现释放功能。", "link": "http://blog.csdn.net/cpuabc/article/details/7870796", "publishDate": "2012-08-15 21:06", "title": "\r\n        Linux内存不足怎么办？写个脚本瞬间释放Linux系统内存            \r\n        "}
{"readCount": "1427", "article": "以往都是在Windows宿主机上安装VMware，这次需要在Ubuntu Linux系统上安装使用VMware，安装过程略有不同，具体如下：\n\n由于Ubuntu 12.04采用了较新3.2.0的内核，执行sudo vmware，直接编译内核会出现“Unable to build kernel module\"的错误。\n\n解决办法是给VMware打个补丁，具体如下：\n\n需要注意到是，在创建VM之前，必须先进行注册。当然，最简单的方法是找个注册机，算个注册码，填进去就OK了。\n\n下面是几个已经算好的注册码 :-)", "link": "http://blog.csdn.net/cpuabc/article/details/7845093", "publishDate": "2012-08-08 21:20", "title": "\r\n        在Ubuntu 12.04上安装VMware Workstation 8.0（解决\"Unable to build kernel module\"问题）            \r\n        "}
{"readCount": "2872", "article": "在使用 QTableView 或 QTableWidget 时，有时我们不想要选中虚框，可以实现一个 ItemDelegate ，重写 drawFocus() 和 drawCheck()  两个虚函数，然后调用 QAbstractItemView 的 setItemDelegate() 把自定义的 itemDelegate 对象传递给 QTableView 即可。需要注意的是，QAbstractItemView 不会删除你设置给它的 ItemDelegate ，需要开发者自己在合适的时候删除它。\n\n如你所见，RowDelegate 类的 drawFocus() 和 drawCheck() 嘛事不干，这样就达到了目的。\n\n对于 QListView 或 QListWidget ，使用上面的代码也可以去掉选中虚框。", "link": "http://blog.csdn.net/foruok/article/details/26286905", "publishDate": "2014-05-20 08:26", "title": "\r\n        Qt on Android：QTableView不显示选中虚框            \r\n        "}
{"readCount": "1936", "article": "目前，许多主流智能手机都采用TI的OMAP系列处理器，如摩托罗拉 Droid X、Droid 2/里程碑2、Defy/ME525、Defy+，ARCHOS 7，诺基亚N9等。本人正在使用的Droid X正是采用的OMAP3630处理器。前段时间通过刷机，将系统升级至了Android 4.0，并刷成了MIUI，系统运行依然非常稳定流畅。单从处理器性能和内存大小来说，bb xm甚至略强于Droid X手机，稳定运行Android 4.0系统应该也不成问题。另外，bb提供了大量外设接口，如USB 2.0、DVI-D、音频输入输出等，将其作为一个小型Android智能设备，尤其是作为电视机顶盒来使用，装上个PPTV，再装个Angry Birds，在电视上看网络视频，玩小鸟，应该非常不错。网上搜了下，淘宝上基于OMAP系列的山寨google机顶盒产品真是不少。。。不过无所谓，自己玩bb xm和买个现成的山寨盒子的感觉必然是大不一样的。\n\n废话少说，开始动手。网上能找不少bb xm上移植Android的资料 。TI为用户提供了Gingerbread、Froyo、IceCream Sanwich移植的开发套件和相关资料，可以根据需要去TI网站上扒一扒。另外，推荐Rowboat Project，该项目致力于将Android移植到基于TI的OMAP系列处理器的设备上，网站上提供了许多有用的资源，以及一些pre-built好的系统镜像，目前已经完成了Android 4.0 ICS的移植，并开放源码。网站链接：http://code.google.com/p/rowboat/\n\n作为初探试水，本篇的工作就是基于Rowboat已经编译好的Android 4.0系统，将其部署到bb xm上。接下来，按部就班：\n\n通过，执行上述命令，可以自动地完成启动TF卡的制作过程。完成后，TF卡将被格成三个分区，重新挂载后，在/media目录下可以看到boot、rootfs和data三个分区目录，分别存放系统镜、根文件系统和用户数据。\n\nOK，真是很简单。完成上述步骤后，可以启动Android 4.0了。\n\n将bb xm串口连接到PC上，打开Putty串口终端。DVI-D接口连接到LCD显示器，并切换到DVI模式。上电，启动，串口终端显示x-loader、u-boot和内核启动信息，顺利完成后就会出现android系统的shell提示符。这时，LCD上会出现ANDROID的启动界面，等待30~40秒，进入开机解锁界面，成功进入Android UI，并能自动认出插上的USB鼠标。\n\n当然，这个Pre-built的Android Image仍然存在一些问题，其中最大的问题是速度慢得令人难以接收。咨询Mr Google，发现最主要是TF卡的问题，将现在用的Class 4的卡换成Class 10后，速度明显有所改观，不过似乎离实用仍有距离。现在所用的Pre-built的Android Image在驱动方面也不是很完整，至少仍无法使用外接的USB无线网卡。要作为机顶盒使用，这些问题都是必须解决的。\n\n上文中提到的开发系统和Putty的建立和设置，参见http://blog.csdn.net/cpuabc/article/details/7796127", "link": "http://blog.csdn.net/cpuabc/article/details/7817015", "publishDate": "2012-08-01 09:56", "title": "\r\n        玩转BealgeBoard xM——试水Android 4.0 ICS            \r\n        "}
{"readCount": "529", "article": "这个错误一般都是字符串中出现了空格引起的，给你的字符串加一个.trim()就可以了", "link": "http://blog.csdn.net/lyhhj/article/details/49000015", "publishDate": "2015-10-09 14:47", "title": "\r\n        Android报错解决 UIL doesn't support scheme(protocol) by default [file:/]. You should impleme            \r\n        "}
{"readCount": "3381", "article": "前面说了, 这一系列是针对c++&3D的, 所以排除Box2D之类的2D引擎.\n\n3D版的, 目前最流行的有3个:\n\n看到这个我就想骂娘了. 你说你开个斯巴达就开吧, 干嘛不让我们写程序啊~\n\n不说了, 你们懂的, 会被和谐的\n\n所以用另找一个吧. 在Chrome Store里找到另一个版本:\n\n有兴趣的可以看看这个东西的视频讲解: Native Client Acceleration Modules, HTML5+NaCl\n\n这个DEMO的渲染部分是使用HTML5做的, 页面交互与C++这边的通信则是通过Json, 是一个不错的案例\n\n不过, 想要渲染性能高, 还是把3D部分也用NaCl实现的好\n\n另外, VS2010的属性表配置真是方便, 安装过NaCl的插件后, 在c:\\Users\\[USERNAME]\\AppData\\Local\\Microsoft\\MSBuild\\v4.0\\下会有NaCl32, NaCl64, PPAPI的配置. 所以, 把现有的C++工程转换成NaCl的版本, 只需要增加对应的配置就可以了, 十分方便", "link": "http://blog.csdn.net/xoyojank/article/details/8197068", "publishDate": "2012-11-18 20:00", "title": "\r\n        从Native到Web(四), NaCl学习笔记: 物理引擎            \r\n        "}
{"readCount": "3280", "article": "GLES2.0封装到shader和vbo结合的部分, 蒙了\n\nvertex layout(或叫vertex declaration)要一个一个element的绑定到一个shader变量上(GL叫attribute), 也就是相当于HLSL的VS_INPUT结构体吧.\n\n问题是, GLSL里没有\"semantic\", 然后问题就来了\n\n在DX中可以通过指定vetex declaration来绑定到指定寄存器, HLSL里通过语义来标明当前输入变量是对应哪个寄存器的:\n\n但是对于GLSL, 它没有vertex declaration这么个东西! 怪不得大家都用CG...无奈手机上用不了CG, 还是要面对这个问题.\n\n起初我是设想的把每种vertex element对应一个固定的attribute名, 如a_position0, a_normal0, a_color1之类, 然后用程序自动绑定. 写shader的时候只能使用程序里规定的attribute名字. 写到glBindAttribLocation时, 问题又来了:\n\n也就是说, 每个effect(vs + ps)要在link之前把所有参数全部手动绑定一遍. 但对于vertex layout来说不太现实. 难道还要自己用XML定义一下所有参数? 昏倒\n\n想来想去, 好像只有OGRE有用GLSL, 查了一下, 我原本想的没有错, 它也是用固定attribute名来绑定element的:\n\n但是它没有在乎vertexlayout究竟是什么样的, 一鼓脑的全绑定上了", "link": "http://blog.csdn.net/xoyojank/article/details/4683613", "publishDate": "2009-10-16 21:15", "title": "\r\n        看得让人DT的GLSL            \r\n        "}
{"readCount": "14", "article": "我们在开发过程中，利用app通过API去调用系统相机拍照的时候，不同的机型有时候拍出来的图片角度不对，被旋转了90°或者180°。例如三星的S4，在调用其相机拍照的时候，拍出来的照片就旋转了90℃或者是270℃。这不是我们想要的，遇到这种情况不得不手动将拍出来的照片旋转一定的角度。下面就大家提供关于图片旋转的方法。", "link": "http://blog.csdn.net/loveyaozu/article/details/51177221", "publishDate": "2016-04-18 09:35", "title": "\r\n        Android之图片旋转            \r\n        "}
{"readCount": "2518", "article": "关于为什么使用.9图，我就不长篇大论了，就是为了减少图片资源体积，我们这篇文章重点解决.9图的制作的一些小问题。\n\n.9的制作，实际上就是在原图片上添加1px的边界，然后按照我们的需求，把对应的位置设置成黑色线，系统就会根据我们的实际需求进行拉伸。\n\n下图是对.9图的四边的含义的解释，左上边代表拉伸区域，右下边代表padding box，就是间隔区域，在下面，我们给出一个例子，方便大家理解。\n\n上图和下图的区别，就在于右下边的黑线不一样，具体的效果的区别，看右边的效果图。上图效果图中深蓝色的区域，代表内容区域，我们可以看到是在正中央的，这是因为我们在右下边的是两个点，这两个点距离上下左右四个方向的距离就是padding的距离，所以深蓝色内容区域在图片正中央，我们再看下图，由于右下边的黑线是图片长度，所以就没有padding，从效果图上的表现就是深蓝色区域和图片一样大，因此，我们可以利用右下边来控制内容与背景图边缘的padding。\n\n如果你还不明白，那么我们看下面的效果图，我们分别以图一和图二作为背景图，下面是效果图。\n\n我们可以看到，使用wrap_content属性设置长宽，图一比图二的效果大一圈，这是为什么呢？还记得我上面说的padding吗？\n\n这就是padding的效果提现，怎么证明呢？我们再看下面一张图，给图一添加padding=0，这样背景图设置的padding效果就没了，是不是两个一样大了？\n\nok，我想你应该明白右下边的黑线的含义了，下面我们再看一下左上边的效果。\n\n上面的线没有包住图标，下面的线正好包住了图标，从右边的效果图应该可以看出差别，黑线所在的区域就是拉伸区域，上图黑线所在的全是纯色，所以图标不变形，下面的拉伸区域包裹了图标，所以在拉伸的时候就会对图标进行拉伸，但是这样就会导致图标变形。注意到下面红线区域了嘛？这是系统提示我们的，因为这样拉伸，不符合要求，所以会提示一下。\n\n介绍了这么多，你应该会用ninepatch了吧？不会的话就留言，我看到就给你答疑解惑，嘻嘻", "link": "http://blog.csdn.net/zhaokaiqiang1992/article/details/42968333", "publishDate": "2015-01-21 14:47", "title": "\r\n        【Android界面实现】关于Android中9patch图的一点小解释            \r\n        "}
{"readCount": "4903", "article": "Exif(Exchangeable Image File 可交换图像文件)是一种图象文件格式，它的数据存储与JPEG格式是完全相同的。实际上Exif格式就是在JPEG格式头部插入了数码照片的信息，包括拍 摄时的光圈、快门、白平衡、ISO、焦距、日期时间等各种和拍摄条件以及相机品牌、型号、色彩编码、拍摄时录制的声音以及全球定位系统（GPS）、缩略图 等。简单地说，Exif=JPEG+拍摄参数。因此，你可以利用任何可以查看JPEG文件的看图软件浏览Exif格式的照片，但并不是所有的图形程序都能 处理 Exif信息。\n\n \n\n 所有的JPEG文件以字符串“0xFFD8”开头，并以字符串“0xFFD9”结束。文件头中有一系列“0xFF??”格式的字符串，称为“标识”，用来 标记JPEG文件的信息段。“0xFFD8”表示图像信息开始，“0xFFD9”表示图像信息结束，这两个标识后面没有信息，而其它标识紧跟一些信息字 符。\n\n 　　0xFFE0 -- 0xFFEF之间的标识符称为“应用标记”，没有被常规JPEG文件利用，Exif正是利用这些信息串记录拍摄信息如快门速度、光圈值等，甚至可以包括全 球定位信息。按照Exif2.1标准对这些标识符的定义，数码相机可以把各种拍摄信息记入数码图像中，应用软件可以读取这些数据，再按照Exif2.1标 准，检索出它们的具体含义,一般而言包括以下一些信息：\n\n 　　Image Description 图像描述、来源. 指生成图像的工具\n\n 　　Artist作者 有些相机可以输入使用者的名字\n\n 　　Make 生产者 指产品生产厂家\n\n 　　Model 型号 指设备型号\n\n 　　Orientation方向 有的相机支持，有的不支持\n\n 　　XResolution/YResolution X/Y方向分辨率 本栏目已有专门条目解释此问题。\n\n 　　ResolutionUnit分辨率单位 一般为PPI\n\n 　　Software软件 显示固件Firmware版本\n\n 　　DateTime日期和时间\n\n 　　YCbCrPositioning 色相定位\n\n 　　ExifOffsetExif信息位置，定义Exif在信息在文件中的写入，有些软件不显示。\n\n 　　ExposureTime 曝光时间 即快门速度\n\n 　　FNumber光圈系数\n\n 　　ExposureProgram曝光程序 指程序式自动曝光的设置，各相机不同,可能是Sutter Priority（快门优先）、Aperture Priority（快门优先）等等。\n\n 　　ISO speed ratings感光度\n\n 　　ExifVersionExif版本\n\n 　　DateTimeOriginal创建时间\n\n 　　DateTimeDigitized数字化时间\n\n 　　ComponentsConfiguration图像构造（多指色彩组合方案）\n\n 　　CompressedBitsPerPixel(BPP)压缩时每像素色彩位 指压缩程度\n\n 　　ExposureBiasValue曝光补偿。\n\n 　　MaxApertureValue最大光圈\n\n 　　MeteringMode测光方式， 平均式测光、中央重点测光、点测光等。\n\n 　　Lightsource光源 指白平衡设置\n\n 　　Flash是否使用闪光灯。\n\n 　　FocalLength焦距，一般显示镜头物理焦距，有些软件可以定义一个系数，从而显示相当于35mm相机的焦距 MakerNote(User Comment)作者标记、说明、记录\n\n 　　FlashPixVersionFlashPix版本 （个别机型支持）\n\n 　　ColorSpace色域、色彩空间\n\n 　　ExifImageWidth(Pixel X Dimension)图像宽度 指横向像素数\n\n 　　ExifImageLength(Pixel Y Dimension)图像高度 指纵向像素数\n\n 　　Interoperability IFD通用性扩展项定义指针 和TIFF文件相关，具体含义不详\n\n 　　FileSource源文件 Compression压缩比。\n\n\n\n 在Android Camera程序开发过程中，要用到Exif相关的知识，如果处理不当，会导致拍摄的JPEG图片无法正常浏览。\n\n 在Froyo(Android 2.2)源码中的Camera应用是不对Exif信息进行写操作，而只是读操作，对于Exif的写操作是交给Camera硬件抽象层去完成，这是 google的设计逻辑。但是不同的Android平台及其相关子平台，再加上不同的Camera应用，相互交替，排列组合，或许会出现这样一种情况：底 层没有去写Exif，而上层应用也没有写Exif信息，那么图片的显示信息将会丢失。其中影响最为严重的是Orientation这个参数。\n\n \n\n Froyo camera的逻辑是这样的：\n\n 在Camera这个Activity中，有一个内部类ImageCapture，其中包含一个重要的方法：\n\n private void capture() {\n\n // Set rotation.\n\n mParameters.setRotation(mLastOrientation);\n\n ....................\n\n .....................\n\n  mCameraDevice.setParameters(mParameters);\n\n \n\n mCameraDevice.takePicture(mShutterCallback, mRawPictureCallback, mPostViewPictureCallback, new JpegPictureCallback(loc));\n\n }\n\n \n\n 大致流程是这样的：\n\n 1.将拍照时相机的方向添加进Camera.Parameters的实例中;\n\n 2.将全部相机拍照参数传给android.hardware.Camera的对象;\n\n 3.调用方法takePicture，并设置好非常重要的4个callback;\n\n 4.生成Exif数据的事情就由HAL来完成;\n\n 5.第4个callback返回数据(这个callback是最重要的，而且是不可缺省的，也就是说前3个callback设置成Null也不会影响拍照功能),见如下代码：\n\n private final class JpegPictureCallback implements PictureCallback {\n\n public void onPictureTaken(final byte[] jpegData, final android.hardware.Camera camera) {\n\n //jpegData为JPEG数据，是由HAL层根据应用传输的各种参数(即Camera.Parameters的实例)以及JPEG压缩算法生成的。\n\n mImageCapture.storeImage(jpegData, camera, mLocation);\n\n }\n\n }\n\n\n\n 什么地方用到Exif信息呢？我遇到的至少有如下这么几个地方：\n\n 1.生成右上角所略图;\n\n 2.图片显示应用，例如android自带的gallery3d应用;\n\n 3.图片回显;\n\n 4.短(彩)信等需要添加camera附件的应用.\n\n \n\n 看看源码： ImageManager中是这样读取Exif方向参数的。\n\n     public static int getExifOrientation(String filepath) {\n\n         int degree = 0;\n\n         ExifInterface exif = null;\n\n         try {\n\n             exif = new ExifInterface(filepath);\n\n         } catch (IOException ex) {\n\n             Log.e(TAG, \"cannot read exif\", ex);\n\n         }\n\n         if (exif != null) {\n\n             int orientation = exif.getAttributeInt(\n\n                 ExifInterface.TAG_ORIENTATION, -1);\n\n             if (orientation != -1) {\n\n                 // We only recognize a subset of orientation tag values.\n\n                 switch(orientation) {\n\n                     case ExifInterface.ORIENTATION_ROTATE_90:\n\n                         degree = 90;\n\n                         break;\n\n                     case ExifInterface.ORIENTATION_ROTATE_180:\n\n                         degree = 180;\n\n                         break;\n\n                     case ExifInterface.ORIENTATION_ROTATE_270:\n\n                         degree = 270;\n\n                         break;\n\n                 }\n\n \n\n             }\n\n         }\n\n         return degree;\n\n     }\n\n \n\n 这个方法可以进一步优化，从而对于Exif信息的写入不再依赖底层。那就是比较一下传输给底层的orientation与实际返回的是否相等，不相等就是底层写入Exif信息出错，我们就可以在应用层进行修正。\n\n 可以添加一个判断分支如下：（其中EXIF_ORIENTATION是我们缓存的应用传给底层的值）。\n\n else if(orientation == 0 && EXIF_ORIENTATION != 0) {\n\n                 switch (EXIF_ORIENTATION) {\n\n                 case 90:\n\n                     orientation = ExifInterface.ORIENTATION_ROTATE_90;\n\n                     degree = 90;\n\n                     break;\n\n                 case 180:\n\n                     orientation = ExifInterface.ORIENTATION_ROTATE_180;\n\n                     degree = 180;\n\n                     break;\n\n                 case 270:\n\n                     orientation = ExifInterface.ORIENTATION_ROTATE_270;\n\n                     degree = 270;\n\n                     break;\n\n                 }\n\n                 exif.setAttribute(ExifInterface.TAG_ORIENTATION, Integer.toString(orientation));\n\n                 try {\n\n                     exif.saveAttributes();\n\n                 } catch (IOException e) {\n\n                      Log.e(TAG, \"cannot save exif\", e);\n\n                 }\n\n             }\n\n \n\n \n\n 在应用层对于Exif的操作是通过android.media.ExifInterface接口完成的。\n\n 通过public void setAttribute (String tag, String value) 来设置，而获取可以通过 public int getAttributeInt (String tag, int defaultValue) 和 public String getAttribute (String tag) 两种方法都可以，getAttributeInt 重载方法一第二个参数为我们设置的默认值，如果成功则返回相应Tag的值;特定的整数内容为该方法直接返回值。而重载方法二该方法直接返回结果，如果失败 则为null。\n\n这样，经过简单改造(只是添加了对Exif信息校验以及写操作的逻辑)的Camera应用将更加健壮，不依赖平台底层是否处理了Exif信息，即使出现异常，应用能够自动修正。\n\n 这里只是以Exif中的 Orientation参数为例，其他参数可以以此类推，保证拍摄出来的图片符合标准。", "link": "http://blog.csdn.net/zoe6553/article/details/6297409", "publishDate": "2011-04-02 11:03", "title": "\r\n        Android 下的EXIF            \r\n        "}
{"readCount": "8795", "article": "在activity(或者是fragement)被杀掉之前调用保存每个实例的状态,以保证该状态可以在onCreate(Bundle)或者onRestoreInstanceState(Bundle) (传入的Bundle参数是由onSaveInstanceState封装好的)中恢复。这个方法在一个activity被杀死前调用，当该activity在将来某个时刻回来时，可以恢复其先前状态。例如，如果activity B启用后位于activity A的前端，在某个时刻activity A因为系统回收资源的问题要被杀掉，A通过onSaveInstanceState将有机会保存其用户界面状态，使得将来用户返回到activity A时能通过onCreate(Bundle)或者onRestoreInstanceState(Bundle)恢复界面的状态。\n\n不要将这个方法和activity生命周期回调如onPause()或onStop()搞混淆了，onPause()在activtiy被放置到背景或者自行销毁时总会被调用，onStop()在activity被销毁时被调用。一个会调用onPause()和onStop()，但不触发onSaveInstanceState的例子是当用户从activity B返回到activity A时：没有必要调用B的onSaveInstanceState(Bundle)，此时的B实例永远不会被恢复，因此系统会避免调用它。一个调用onPause()但不调用onSaveInstanceState的例子是当activity B启动并处在activity A的前端：如果在B的整个生命周期里A的用户界面状态都没有被破坏的话，系统是不会调用activity A的onSaveInstanceState(Bundle)的。\n\n\n\n默认的实现负责了大部分UI实例状态的保存，采用的方式是调用UI层上每个拥有id的view的onSaveInstanceState() ，并且保存当前获得焦点的view的id(所有保存的状态信息都会在默认的onRestoreInstanceState(Bundle)实现中恢复。如果你覆写这个方法来保存额外的没有被各个view保存的信息，你可能想要在默认实现过程中调用或者自己保存每个视图的所有状态。如果被调用，这个方法会在onStop()前被触发，但系统并不保证是否在onPause()之前或者之后触发。\n\n\n\n以上是API文档中的解释，我们在项目中一般在onSaveInstanceState()方法中保存数据，然后再onCreate()或者是onRestoreInstanceState(Bundle)中对界面进行恢复。\n\n一个项目中的使用情景是，在onSaveInstanceState()中记录当前的可见的第一条listview的item的position信息，然后在onRestoreInstanceState(Bundle)中对listview调用setSelection()方法对位置进行定位，这样对用户体验更加友好", "link": "http://blog.csdn.net/zhaokaiqiang1992/article/details/19481197", "publishDate": "2014-02-19 11:55", "title": "\r\n        【Android进阶】Activity和Fragement中onSaveInstanceState()的使用详解            \r\n        "}
{"readCount": "3364", "article": "经过在网上查了一些相关的资料后总结出一下两个类的用法可以对内存进行优化。在Android应用程序开发中，由于手机的资源有限，所以我们经常会需要观察某对象什么时候会被垃圾收集的执行绪清除，你必须要用一个 reference 记住它，以便随时观察，但是却因此造成此对象的 reference 数目一直无法为零， 使得对象无法被清除。\n\n这时候可以使用 Weak Reference 这个类。如果你希望能随时取得某对象的信息，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象，而不是使用一般的 reference。\n\n在此例中，透过 get() 可以取得此 Reference 的所指到的对象，如果传出值为 null 的话，代表此对象已经被清除。\n\n这类的技巧，在设计 Optimizer 或 Debugger 这类的程序时常会用到，因为这类程序需要取得某对象的信息，但是不可以 影响此对象的垃圾收集。\n\nSoft Reference 虽然和 Weak Reference 很类似，但是用途却不同。 被 Soft Reference 指到的对象，即使没有任何 Direct Reference，也不会被清除。一直要到 JVM 内存不足时且 没有 Direct Reference 时才会清除，SoftReference 是用来设计 object-cache 之用的。如此一来 SoftReference 不但可以把对象 cache 起来，也不会造成内存不足的错误 （OutOfMemoryError）。我觉得 Soft Reference 也适合拿来实作 pooling 的技巧。", "link": "http://blog.csdn.net/yuzhiboyi/article/details/7775963", "publishDate": "2012-07-23 16:31", "title": "\r\n        进行Android内存优化的SoftReference 和 WeakReference            \r\n        "}
{"readCount": "550", "article": "在开发Android应用时必须遵守单线程模型的原则： Android UI操作并不是线程安全的并且这些操作必须在UI线程中执行。\n\n在开发Android应用时必须遵守单线程模型的原则： Android UI操作并不是线程安全的并且这些操作必须在UI线程中执行。在单线程模型中始终要记住两条法则： \n\n 1. 不要阻塞UI线程 \n\n 2. 确保只在UI线程中访问Android UI工具包 \n\n 当一个程序第一次启动时，Android会同时启动一个对应的主线程(Main Thread)，主线程主要负责处理与UI相关的事件，如：用户的按键事件，用户接触屏幕的事件以及屏幕绘图事件，并把相关的事件分发到对